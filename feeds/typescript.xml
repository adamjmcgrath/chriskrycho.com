<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - typescript</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Fri, 05 May 2017 00:10:00 -0400</lastBuildDate><item><title>Typing Your Ember, Part 1</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In this first post in the series, we’re going to keep things simple and easy: we’re going to get an Ember.js app configured to use TypeScript. Later posts will cover some of the other details.&lt;/p&gt;
&lt;p&gt;Because of the lovely &lt;a href="https://ember-cli.com"&gt;Ember CLI&lt;/a&gt; ecosystem, this is a pretty straightforward process. I’m going to start from &lt;em&gt;zero&lt;/em&gt; so that even if you’ve never written an Ember app before, you can get this up and running by following these instructions. These instructions have also been tested and confirmed to work across platforms—you can do this equally on Windows, macOS, or Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Make sure you have Ember’s prerequisites installed. Get &lt;a href="https://nodejs.org/en/"&gt;Node&lt;/a&gt; for your platform. Optionally (but highly recommended) install &lt;a href="https://yarnpkg.com"&gt;Yarn&lt;/a&gt; to manage your Node packages.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the Ember command lines tools globally:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;yarn global add ember-cli&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;npm install --global ember-cli&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create an Ember app.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember new my-ts-app --yarn&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the &lt;code&gt;--yarn&lt;/code&gt; flag will make it so your app uses &lt;a href="https://yarnpkg.com"&gt;Yarn&lt;/a&gt; and creates a &lt;code&gt;yarn.lock&lt;/code&gt; file instead of using npm when it installs its dependencies.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;a href="https://emberobserver.com/addons/ember-cli-typescript"&gt;&lt;code&gt;ember-cli-typescript&lt;/code&gt; add-on&lt;/a&gt;. From within the root of the newly created application directory (where we’ll carry out everything from this point forward):&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate your first UI component.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;sh    $ ember generate component some-input&lt;/code&gt;&lt;/p&gt;
&lt;ol start="6" type="1"&gt;
&lt;li&gt;Rename the files it generated from &lt;code&gt;.js&lt;/code&gt; to &lt;code&gt;.ts&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app/components/some-input.js&lt;/code&gt; → &lt;code&gt;app/components/some-input.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests/integration/components/some-input-test.js&lt;/code&gt; → &lt;code&gt;tests/integration/components/some-input-test.ts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add some content to the files:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{!-- some-input.hbs --}}
{{input value=theValue change=(mut theValue)}}
{{theValue}}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// some-input.ts
import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Component.extend({
  theValue: &amp;#39;&amp;#39;,
});&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update your &lt;code&gt;application.hbs&lt;/code&gt; file to remove the default &lt;code&gt;{{welcome}}&lt;/code&gt; template and replace it with &lt;code&gt;{{some-input}}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Serve the Ember application. In the root of your application directory:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember serve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll likely note some warnings: the TypeScript compiler won’t be able to find some of the modules imported in your files. I’ll have more to say about this in a future post. For now, suffice it to say: don’t worry, Ember CLI is still resolving and compiling your modules just fine.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Load the application by going to &lt;code&gt;localhost:4200&lt;/code&gt; in your browser. You should see a blank white screen with an input in it. Type in it, and see the input rendered to the page. Simple enough, but that’s using a TypeScript file compiled along the way!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s it: we’re done setting up an Ember.js app to use TypeScript! In the next post, I’ll talk a bit about strategies for migrating an existing app to TypeScript—not just the mechanics of it, but also where and how to start actually integrating types into your code.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I strongly prefer to use &lt;code&gt;yarn&lt;/code&gt; over &lt;code&gt;npm&lt;/code&gt; because &lt;code&gt;yarn&lt;/code&gt; installs are predictable and repeatable, and if there’s one thing I don’t need to spend time on when developing our Ember.js app at Olo, it’s chasing problems with transitive dependencies that are different in the build server than in my local development environment. Yarn’s lockfiles mean what ends up built on the server is &lt;em&gt;exactly&lt;/em&gt; what ended up built on my machine.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;But if you’re curious, here’s a preview: we really need more &lt;a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html"&gt;type definitions&lt;/a&gt; for the Ember ecosystem. I’ll be covering &lt;em&gt;how&lt;/em&gt; we build those in much more detail in a future installment.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 05 May 2017 00:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-05:/2017/typing-your-ember-part-1.html</guid><category>typescript</category><category>emberjs</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title></title><link>http://www.chriskrycho.com/2017/01-04-1046.html</link><description>&lt;p&gt;Follow-up from Twitter &lt;a href="http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html"&gt;on my latest bit on TypeScript and &lt;code&gt;keyof&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.&lt;/p&gt;
&lt;p&gt;— Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 04 Jan 2017 10:46:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-04:/2017/01-04-1046.html</guid><category>TypeScript</category></item><item><title>TypeScript keyof Follow-Up</title><link>http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html</link><description>&lt;p&gt;I recently wrote up some neat things you can do with &lt;a href="http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html"&gt;&lt;code&gt;keyof&lt;/code&gt; and mapped types&lt;/a&gt; in TypeScript 2.1. In playing further with those bits, I ran into some interesting variations on the approach I outlined there, so here we are.&lt;/p&gt;
&lt;p&gt;In the previous post, I concluded with an example that looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};

type State
  = &amp;#39;Pending&amp;#39;
  | &amp;#39;Started&amp;#39;
  | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;UnionKeyToValue&amp;lt;State&amp;gt;&lt;/code&gt; type constraint requires us to fill out the &lt;code&gt;STATE&lt;/code&gt; object as expected. The whole point of this exercise was to give us the benefit of code completion with that STATE type so we could use it and not be worried about the kinds of typos that too-often bite us with stringly-typed arguments in JavaScript.&lt;/p&gt;
&lt;p&gt;It turns out we don’t &lt;em&gt;need&lt;/em&gt; that to get completion, though. All editors which use the TypeScript language service will give us the same degree of completion if we start typing a string and then trigger completion:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://cdn.chriskrycho.com/images/more-ts.gif" title="screen capture of string completion in VS Code" alt="string completion with TypeScript 2.1" /&gt;&lt;figcaption&gt;string completion with TypeScript 2.1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Granted that you have to know this is a string (though the JetBrains &lt;abbr title="integrated development environment"&gt;IDE&lt;/abbr&gt;s will actually go a step further and suggest the right thing &lt;em&gt;without&lt;/em&gt; needing the string key). But that’s roughly equivalent to knowing you need to import the object literal constant to get the completion that way. Six one, half dozen the other, I think.&lt;/p&gt;
&lt;p&gt;This makes it something of a wash with the original approach, as long as you’re dealing in a pure-TypeScript environment. The big advantage that the original approach still has, of course, is that it also plays nicely with a mixed TypeScript and JavaScript environment. If you’re just progressively adding TypeScript to an existing JavaScript codebase, that’s possibly reason enough to stick with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: an additional reason to prefer my original solution:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;
&lt;p lang="en" dir="ltr"&gt;
&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.
&lt;/p&gt;
— Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 03 Jan 2017 20:35:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-03:/2017/typescript-keyof-follow-up.html</guid><category>programming languages</category><category>software development</category><category>typescript</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/12-18-1614.html</link><description>&lt;p&gt;Spent a chunk of the afternoon figuring out how to implement Rust’s &lt;code&gt;Result&lt;/code&gt; type in TypeScript. Pretty cool!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 18 Dec 2016 16:14:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-18:/2016/12-18-1614.html</guid><category>programming languages</category><category>rust</category><category>typescript</category></item><item><title>keyof and Mapped Types In TypeScript 2.1</title><link>http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html</link><description>&lt;p&gt;In the last few months, I’ve been playing with both &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt; and &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; as tools for increasing the quality and reliability of the JavaScript I write at Olo. Both of these are syntax that sits on top of normal JavaScript to add type analysis—basically, a form of &lt;a href="https://en.wikipedia.org/wiki/Gradual_typing"&gt;gradual typing&lt;/a&gt; for JS.&lt;/p&gt;
&lt;p&gt;Although TypeScript’s tooling has been better all along&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I initially preferred Flow’s type system quite a bit: it has historically been much more focused on &lt;a href="http://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems"&gt;soundness&lt;/a&gt;, especially around the &lt;em&gt;many&lt;/em&gt; problems caused by &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, than TypeScript. And it had earlier support for &lt;a href="https://flowtype.org/docs/disjoint-unions.html"&gt;tagged unions&lt;/a&gt;, a tool I’ve come to find invaluable since picking them up from my time with Rust.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But the 2.0 and 2.1 releases of TypeScript have changed the game substantially, and it’s now a &lt;em&gt;very&lt;/em&gt; compelling language in its own right—not to mention a great tool for writing better JavaScript. So I thought I’d highlight how you can get a lot of the benefits you would get from the type systems of languages like Elm with some of those new TypeScript features: the &lt;em&gt;&lt;code&gt;keyof&lt;/code&gt; operator&lt;/em&gt; and &lt;em&gt;mapped types&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i&gt;Some readers may note that what I’m doing here is a &lt;em&gt;lot&lt;/em&gt; of wrangling to cajole TypeScript into giving me the kinds of things you get for free in an ML-descended language. Yep. The point is that you &lt;em&gt;can&lt;/em&gt; wrangle it into doing this.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="plain-old-javascript" class="level3"&gt;
&lt;h3&gt;Plain old JavaScript&lt;/h3&gt;
&lt;p&gt;Let’s say we want to write a little state machine in terms of a function to go from one state to the next, like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case &amp;#39;Pending&amp;#39;: return &amp;#39;Started&amp;#39;;
    case &amp;#39;Started&amp;#39;: return &amp;#39;Completed&amp;#39;;
    case &amp;#39;Completed&amp;#39;: return &amp;#39;Completed&amp;#39;;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, and it’ll even throw an error if you hand it the wrong thing. But you’ll find out at runtime if you accidentally typed &lt;code&gt;nextState('Pednign')&lt;/code&gt; instead of &lt;code&gt;nextState('Pending')&lt;/code&gt;—something I’ve done more than once in the past. You’d have a similar problem if you’d accidentally written &lt;code&gt;case 'Strated'&lt;/code&gt; instead of &lt;code&gt;case 'Started'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many contexts like this one in JavaScript—perhaps the most obvious being &lt;a href="http://redux.js.org/docs/basics/Actions.html"&gt;Redux actions&lt;/a&gt;, but I get a lot of mileage out of the pattern in Ember, as well. In these contexts, I find it’s convenient to define types that are kind of like pseudo-enums or pseudo-simple-unions, like so:&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you’ve defined an object this way, instead of using strings directly in functions that take it as an argument, like &lt;code&gt;nextState('Started')&lt;/code&gt;, you can use the object property: &lt;code&gt;nextState(STATE.Started)&lt;/code&gt;. You can rewrite the function body to use the object definition instead as well:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case STATE.Pending: return STATE.Started;
    case STATE.Started: return STATE.Completed;
    case STATE.Completed: return STATE.Completed;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the object and its keys instead gets you something like a namespaced constant. As a result, you can get more help with things like code completion from your editor, along with warnings or errors from your linter if you make a typo. You’ll also get &lt;em&gt;slightly&lt;/em&gt; more meaningful error messages if you type the wrong thing. For example, if you type &lt;code&gt;STATE.Strated&lt;/code&gt; instead of &lt;code&gt;STATE.Started&lt;/code&gt;, any good editor will give you an error—especially if you’re using a linter. At Olo, we use &lt;a href="http://eslint.org"&gt;ESLint&lt;/a&gt;, and we have it &lt;a href="https://github.com/ember-cli/ember-cli-eslint/"&gt;set up&lt;/a&gt; so that this kind of typo/linter error fails our test suite (and we never merge changes that don’t pass our test suite!).&lt;/p&gt;
&lt;p&gt;This is about as good a setup as you can get in plain-old JavaScript. As long as you’re disciplined and always use the object, you get some real benefits from using this pattern. But you &lt;em&gt;always&lt;/em&gt; have to be disciplined. If someone who is unfamiliar with this pattern types &lt;code&gt;nextState('whifflebats')&lt;/code&gt; somewhere, well, we’re back to blowing up at runtime. Hopefully your test suite catches that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="typescript-to-the-rescue" class="level3"&gt;
&lt;h3&gt;TypeScript to the rescue&lt;/h3&gt;
&lt;p&gt;TypeScript gives us the ability to &lt;em&gt;guarantee&lt;/em&gt; that the contract is met (that we’re not passing the wrong value in). As of the latest release, it also lets us guarantee the &lt;code&gt;STATES&lt;/code&gt; object to be set up the way we expect. And last but not least, we get some actual productivity boosts when writing the code, not just when debugging it.&lt;/p&gt;
&lt;p&gt;Let’s say we decided to constrain our &lt;code&gt;nextState&lt;/code&gt; function so that it had to both take and return some kind of &lt;code&gt;State&lt;/code&gt;, representing one of the states we defined above. We’ll leave a &lt;code&gt;TODO&lt;/code&gt; here indicating that we need to figure out how to write the type of &lt;code&gt;State&lt;/code&gt;, but the function definition would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// TODO: figure out how to define `State`
function nextState(state: State): State {
  // the same body...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript has had &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt; since the &lt;a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html"&gt;1.4 release&lt;/a&gt; so they might seem like an obvious choice, and indeed we could write easily a type definition for the strings in &lt;code&gt;STATES&lt;/code&gt; as a union:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you can’t write something like &lt;code&gt;State.Pending&lt;/code&gt; somewhere; you have to write the plain string &lt;code&gt;'Pending'&lt;/code&gt; instead. You still get some of the linting benefits you got with the approach outlined above via TypeScript’s actual type-checking, but you don’t get &lt;em&gt;any&lt;/em&gt; help with autocompletion. Can we get the benefits of both?&lt;/p&gt;
&lt;p&gt;Yes! (This would be a weird blog post if I just got this far and said, “Nope, sucks to be us; go use Elm instead.”)&lt;/p&gt;
&lt;p&gt;As of the 2.1 release, TypeScript lets you define types in terms of keys, so you can write a type like this:&lt;a href="#fn4" class="footnoteRef" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can use that type any place you need to constrain the type of a variable, or a return, or whatever:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const goodState: StateFromKeys = STATE.Pending;

// error: type &amp;#39;&amp;quot;Blah&amp;quot;&amp;#39; is not assignable to type &amp;#39;State&amp;#39;
const badState: StateFromKeys = &amp;#39;Blah&amp;#39;;

interface StateMachine {
  (state: StateFromKeys): StateFromKeys;
}

const nextState: StateMachine = (state) =&amp;gt; {
  // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The upside to this is that now you can guarantee that anywhere you’re supposed to be passing one of those strings, you &lt;em&gt;are&lt;/em&gt; passing one of those strings. If you pass in &lt;code&gt;'Compelte'&lt;/code&gt;, you’ll get an actual error—just like if we had used the union definition above. At a minimum, that will be helpful feedback in your editor. Maximally, depending on how you have your project configured, it may not even generate any JavaScript output.&lt;a href="#fn5" class="footnoteRef" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; So that’s a significant step forward beyond what we had even with the best linting rules in pure JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="going-in-circles" class="level3"&gt;
&lt;h3&gt;Going in circles&lt;/h3&gt;
&lt;p&gt;But wait, we can do more! TypeScript 2.1 &lt;em&gt;also&lt;/em&gt; came with a neat ability to define “mapped types,” which map one object type to another. They have a few &lt;a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types"&gt;interesting examples&lt;/a&gt; which are worth reading. What’s interesting to us here is that you can write a type like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in keyof typeof STATE]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, you can simplify that using the type we defined above, since &lt;code&gt;StateFromKeys&lt;/code&gt; was just &lt;code&gt;keyof typeof STATE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve now defined an object type whose &lt;em&gt;key&lt;/em&gt; has to be one of the items in the &lt;code&gt;State&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Now, by itself, this isn’t all that useful. Above, we defined that as the keys on the &lt;code&gt;STATE&lt;/code&gt; object, but if we tried to use that in conjunction with this new type definition, we’d just end up with a recursive type definition: &lt;code&gt;StateFromKeys&lt;/code&gt; defined as the keys of &lt;code&gt;STATE&lt;/code&gt;, &lt;code&gt;StateAsMap&lt;/code&gt; defined in terms of the elements of &lt;code&gt;StateFromKeys&lt;/code&gt;, and then &lt;code&gt;STATE&lt;/code&gt; defined as a &lt;code&gt;StateAsMap&lt;/code&gt;…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: StateAsMap = {
  Pending: &amp;#39;Pending&amp;#39;,
  Active: &amp;#39;Active&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}

type StateFromKeys = keyof typeof STATE;

type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You end up with multiple compiler errors here, because of the circular references. This approach won’t work. If we take a step back, though, we can work through this (and actually end up someplace better).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="join-forces" class="level3"&gt;
&lt;h3&gt;Join forces!&lt;/h3&gt;
&lt;p&gt;First, let’s start by defining the mapping generically. After all, the idea here was to be able to use this concept all over the place—e.g. for &lt;em&gt;any&lt;/em&gt; Redux action, not just one specific one. We don’t need this particular &lt;code&gt;State&lt;/code&gt;; we just need a constrained set of strings (or numbers) to be used as the key of an object:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type MapKeyAsValue&amp;lt;Key extends string&amp;gt; = {
  [K in Key]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In principle, if we didn’t have to worry about the circular references, we could use that to constrain our definition of the original &lt;code&gt;STATE&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: MapKeyAsValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how to get around the problem of circular type definitions? Well, it turns out that the &lt;code&gt;K&lt;/code&gt; values in these &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; and &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; types are equivalent:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// Approach 1, using an object
const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;
type StateObjectKeyToValue = {
  [K in StateFromKeys]: K  // &amp;lt;- K is just the keys!
};

// Approach 2, using unions
type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;
type StateUnionKeyToValue = {
  [K in StateUnion]: K  // &amp;lt;- K is also just the keys!
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, unlike the &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; version, &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; doesn’t make any reference to the &lt;code&gt;STATE&lt;/code&gt; object. So we can use &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; to constrain &lt;code&gt;STATE&lt;/code&gt;, and then just use &lt;code&gt;StateUnion&lt;/code&gt; to constrain all the places we want to &lt;em&gt;use&lt;/em&gt; one of those states. Once we put it all together, that would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

type StateUnionKeyToValue = {
  [K in StateUnion]: K
};

const STATE: StateUnionKeyToValue = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By doing this, we get two benefits. First, &lt;code&gt;STATE&lt;/code&gt; now has to supply the key and value for &lt;em&gt;all&lt;/em&gt; the union’s variants. Second, we know that the key and value are the same, and that they map to the union’s variants. These two facts mean that we can be 100% sure that wherever we define something as requiring a &lt;code&gt;State&lt;/code&gt;, we can supply one of the items on &lt;code&gt;STATE&lt;/code&gt; and it will be guaranteed to be correct. If we change the &lt;code&gt;State&lt;/code&gt; union definition, everything else will need to be updated, too.&lt;/p&gt;
&lt;p&gt;Now we can make this generic, so it works for types besides just this one set of states—so that it’ll work for &lt;em&gt;any&lt;/em&gt; union type with string keys, in fact. (That string-key constraint is important because objects in TypeScript can currently only use strings or numbers as keys; whereas union types can be all sorts of things.) Apart from that constraint on the union, though, we can basically just substitute a generic type parameter &lt;code&gt;U&lt;/code&gt;, for “union,” where we had &lt;code&gt;StateUnion&lt;/code&gt; before.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any object we say conforms to this type will take a union as its type parameter, and every key on the object must have exactly the same value as the key name:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of those don’t have &lt;em&gt;exactly&lt;/em&gt; the same value as the key name, you’ll get an error. So, each of the following value assignments would fail to compile, albeit for different reasons (top to bottom: capitalization, misspelling, and missing a letter).&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const BAD_STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;pending&amp;#39;,  // look ma, no capitals
  Started: &amp;#39;Strated&amp;#39;,  // St-rated = whuh?
  Completed: &amp;#39;Complete&amp;#39;,  // so tense
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll see a compiler error that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div style="white-space: pre-line;"&gt;[ts]
Type ‘{ Pending: “pending”; Started: “Strated”; Completed: “Complete” }’ is not assignable to type ‘UnionKeyToValue&lt;State&gt;’.
  Types of property ‘Pending’ are incompatible.
    Type ‘“pending”’ is not assignable to type ‘“Pending”’.&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the key and the name don’t match, the compiler tells us we didn’t keep the constraint we defined on what these types should look like. Similarly, if you forget an item from the union, you’ll get an error. If you add an item that isn’t in the original union, you’ll get an error. Among other things, this means that you can be confident that if you add a value to the union, the rest of your code won’t compile until you include cases for it. You get all the power and utility of using union types, &lt;em&gt;and&lt;/em&gt; you get the utility of being able to use the object as a namespace of sorts.&lt;a href="#fn6" class="footnoteRef" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the TypeScript language service—which you can use from a &lt;em&gt;lot&lt;/em&gt; of editors, including VS Code, Atom, Sublime Text, and the JetBrains IDEs—will actually give you the correct completion when you start definition a type. So imagine we were defining some other union type elsewhere in our program to handle events. Now we can use the same &lt;code&gt;UnionKeyToValue&lt;/code&gt; type to construct this type, with immediate, &lt;em&gt;correct&lt;/em&gt; feedback from the TypeScript language service:&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt; &lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/completion.mp4'&gt; &lt;/video&gt;
&lt;figcaption&gt;
TypeScript live code completion of the mapped type
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;By inverting our original approach of using &lt;code&gt;keyof&lt;/code&gt; (itself powerful and worth using in quite a few circumstances) and instead using the new mapped types, we get a &lt;em&gt;ton&lt;/em&gt; of mileage in terms of productivity when using these types—errors prevented, and speed of writing the code in the first place increased as well.&lt;/p&gt;
&lt;p&gt;Yes, it’s a little verbose and it does require duplicating the strings whenever you define one of these types.&lt;a href="#fn7" class="footnoteRef" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; But, and this is what I find most important: there is only one &lt;em&gt;source&lt;/em&gt; for those string keys, the union type, and it is definitive. If you change that central union type, everything else that references it, including the namespace-like object, will fail to compile until you make the same change there.&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt; &lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/change-union.mp4'&gt; &lt;/video&gt;
&lt;figcaption&gt;
Updating a union
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So it’s a lot more work than it would be in, say, Elm. But it’s also a lot more guarantees than I’d get in plain-old-JavaScript, or even TypeScript two months ago.&lt;/p&gt;
&lt;p&gt;I’ll call that a win.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;it’s no surprise that Microsoft’s developer tooling is stronger than Facebook’s&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;along with all the other ML-descended languages I’ve played with, including Haskell, F&lt;sup&gt;♯&lt;/sup&gt;, PureScript, and Elm.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Aside: to be extra safe and prevent any confusion or mucking around, you should probably call &lt;code&gt;Object.freeze()&lt;/code&gt; on the object literal, too:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = Object.freeze({
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both convention and linters make it unlikely you’ll modify something like this directly—but impossible is better than unlikely.&lt;a href="#fnref3"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Flow has supported this feature for some time; you can write &lt;code&gt;$Keys&amp;lt;typeof STATE&amp;gt;&lt;/code&gt;—but the feature is entirely undocumented.&lt;a href="#fnref4"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Set your &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; key in your &lt;code&gt;tsconfig.json&lt;/code&gt; to include &lt;code&gt;&amp;quot;noEmitOnError&amp;quot;: true,&lt;/code&gt;.&lt;a href="#fnref5"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;For namespacing in a more general sense, you should use… &lt;a href="http://www.typescriptlang.org/docs/handbook/namespaces.html"&gt;namespaces&lt;/a&gt;.&lt;a href="#fnref6"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;It would be great if we could get these benefits without the duplication—maybe someday we’ll have better support in JS or TS natively.&lt;a href="#fnref7"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Dec 2016 23:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-17:/2016/keyof-and-mapped-types-in-typescript-21.html</guid><category>javascript</category><category>typescript</category><category>software development</category><category>programming languages</category></item></channel></rss>