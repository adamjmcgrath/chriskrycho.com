<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - javascript</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Fri, 11 Nov 2016 23:30:00 -0500</lastBuildDate><item><title>What is Functional Programming?</title><link>http://www.chriskrycho.com/2016/what-is-functional-programming.html</link><description>&lt;p&gt;&lt;i class='editorial'&gt;The following is a script I wrote for a tech talk I gave on functional programming. The recording isn’t (and won’t be) publicly available; but a script is often easier to reference anyway!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; updated with corrected performance characterstics.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Hello, everyone. Today, we are going to talk about functional programming—asking what it is, and why we should care.&lt;/p&gt;
&lt;section id="clearing-the-table-functional-programmings-reputation" class="level2"&gt;
&lt;h2&gt;Clearing the Table: Functional Programming’s Reputation&lt;/h2&gt;
&lt;p&gt;Functional programming has something of a reputation: on the one hand, as incredible difficult, dense, full of mathematical jargon, applicable only to certain fields like machine learning or massive data analysis; on the other hand, as a kind of panacea that solves all of your problems. The reality, I think, is a little bit of both.&lt;/p&gt;
&lt;p&gt;The world of functional programming &lt;em&gt;does&lt;/em&gt; include a lot of jargon from the math world, and there are good reasons for that, but there is also a lot we could do to make it more approachable to people who don’t have a background in, say category. Category theory is useful, of course, and I think there are times when we might want to be able to draw on it. But gladly, functional programming doesn’t require you to know what an &lt;em&gt;applicative functor&lt;/em&gt; is to be able to use it. (And, gladly, there’s a lot of increasingly-solid teaching material out there about functional programming which &lt;em&gt;doesn’t&lt;/em&gt; lean on math concepts.)&lt;/p&gt;
&lt;p&gt;On the other side, functional programming does give us some real and serious benefits, and that’s what I’m going to spend the first third or so of this talk looking at. But of course, it’s still just a tool, and even though it is a very helpful and very powerful tool, it can’t keep us from writing bugs. Still, every tool we can add to our belt for writing correct software is a win.&lt;/p&gt;
&lt;p&gt;One more prefatory note before we get into the meat of this talk: unfamiliar terminology is not specific to functional programming. So, yes, when you see this list, it might seem a little out there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functor&lt;/li&gt;
&lt;li&gt;Applicative&lt;/li&gt;
&lt;li&gt;Monoid&lt;/li&gt;
&lt;li&gt;Monad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And in truth, a number of those could have better names. &lt;em&gt;But&lt;/em&gt; we have plenty of terminology we throw around in the world of imperative, object-oriented programming. To pick just one, obvious and easy example—what are the &lt;abbr&gt;SOLID&lt;/abbr&gt; principles?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single reponsibility&lt;/li&gt;
&lt;li&gt;Open/closed&lt;/li&gt;
&lt;li&gt;Liskov substitution&lt;/li&gt;
&lt;li&gt;Interface segregation&lt;/li&gt;
&lt;li&gt;Dependency inversion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may not remember what it felt like the first time you encountered &lt;abbr&gt;SOLID&lt;/abbr&gt;, but suffice it to say: “Liskov substitution principle” isn’t any more intuitive or obvious than “Monad”. You’re just familiar with one of them. The same is true of “applicative” and “Visitor pattern”. And so on. Granted, again: it would be nice for some of these things to have easier names, a &lt;em&gt;big&lt;/em&gt; part of the pain here is just unfamiliarity.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, what &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming" class="level2"&gt;
&lt;h2&gt;What is functional programming?&lt;/h2&gt;
&lt;p&gt;Functional programming is a style of programming that uses &lt;em&gt;pure functions&lt;/em&gt; and &lt;em&gt;immutable data&lt;/em&gt; for as many things as possible, and builds programs primarily out of &lt;em&gt;functions&lt;/em&gt; rather than other abstractions. I’ll define all of those terms in a moment, but first…&lt;/p&gt;
&lt;section id="why-do-we-care" class="level3"&gt;
&lt;h3&gt;Why do we care?&lt;/h3&gt;
&lt;p&gt;We care, frankly, because &lt;em&gt;we’re not that smart&lt;/em&gt;. Let’s think about some of the kinds of things we’re doing with, say, restaurant software: clients, with locations, building baskets, composed of products with options and modifiers, which have a set of rules for what combinations are allowed both of products and of their elements as making up a basket, which turn into orders, which have associated payment schemes (sometimes a lot of them), which generate data to send to a point-of-sale as well as summaries for the customer who ordered it, and so on. There are a &lt;em&gt;lot&lt;/em&gt; of moving pieces there. I’m sure a missed some non-trivial pieces, too. And if all of that is &lt;em&gt;stateful&lt;/em&gt;, that’s a lot of state to hold in your head.&lt;/p&gt;
&lt;p&gt;Let me be a bit provocative for a moment. Imagine you were reading a JavaScript module and it looked like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var foo = 12;
var bar = &amp;#39;blah&amp;#39;;
var quux = { waffles: &amp;#39;always&amp;#39; };

export function doSomething() {
  foo = 42;
}

export function getSomething() {
  bar = quux;
  quux.waffles = &amp;#39;never&amp;#39;;
  return bar;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everyone watching would presumably say, “No that’s bad, don’t do that!” Why? Because there is &lt;em&gt;global state&lt;/em&gt; being changed by those functions, and there’s nothing about the functions which tells you what’s going on. Global variables are bad. Bad bad bad. We all know this. Why is it bad? Because you have no idea when you call &lt;code&gt;doSomething()&lt;/code&gt; or &lt;code&gt;getSomething()&lt;/code&gt; what kinds of side effects it might have. And if &lt;code&gt;doSomething()&lt;/code&gt; and &lt;code&gt;getSomething()&lt;/code&gt; affect the same data, then the order you call them in matters.&lt;/p&gt;
&lt;p&gt;In a previous job, I spent literally months chasing a bunch of bugs in a C codebase where all of the state was global. &lt;em&gt;We don’t do this anymore.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;But really, what’s different about this?&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class AThing {
  constructor() {
    this.foo = 12;
    this.bar = &amp;#39;blah&amp;#39;;
    this.quux = { waffles: &amp;#39;always&amp;#39; };
  }

  doSomething() {
    this.foo = 42;
  }

  getSomething() {
    this.bar = this.quux;
    this.quux.waffles = &amp;#39;never&amp;#39;;
    return this.bar;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have some “internal” data, just like we had in the module up above. And we have some public methods which change that state. In terms of these internals, it’s the same. There are differences in terms of having &lt;em&gt;instances&lt;/em&gt; and things like that, but in terms of understanding the behavior of the system—understanding the state involved—it’s the same. It’s global, mutable state. Now it’s not global like attaching something to the &lt;code&gt;window&lt;/code&gt; object in JavaScript, and that’s good, but still: at the module or class level, it’s just global mutable state, with no guarantees about how anything works. And this is normal—endemic, even—in object-oriented code. We encapsulate our state, but we have &lt;em&gt;tons&lt;/em&gt; of state, it’s all mutable, and as far as any given class method call is concerned, it’s all global to that class.&lt;/p&gt;
&lt;p&gt;You have no idea, when you call a given object method, what it might do. The fact that you call it with an &lt;code&gt;Int&lt;/code&gt; and get out a &lt;code&gt;String&lt;/code&gt; tells you almost nothing. For all you know, it’s triggering a &lt;abbr&gt;JSON-RPC&lt;/abbr&gt; call using the int as the &lt;abbr&gt;ID&lt;/abbr&gt; for the endpoint, which in turn triggers an operation, responds with another &lt;abbr&gt;ID&lt;/abbr&gt;, which you then use to query a database, and load a string from there, which you then set on some other member of the object instance, and then return. Should you write a method that does that? Probably not. But you can; nothing stops you.&lt;/p&gt;
&lt;p&gt;When you call a method, you have no idea what it will do. JavaScript, TypeScript, C&lt;sup&gt;♯&lt;/sup&gt;, it doesn’t matter. You have literally no idea. And that makes things &lt;em&gt;hard&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It often makes fixing bugs hard, because it means you have to figure out which particular &lt;em&gt;state&lt;/em&gt; caused the issue, and find a way to reproduce that state. Which usually means calling methods in a particular order.&lt;/li&gt;
&lt;li&gt;It makes testing hard. Again, it often entails calling methods in a particular order. It also means you often need mocks for all those outside-world things you’re trying to do.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Functional programming is an out. An escape hatch. An acknowledgement, a recognition, that holding all of this in our heads is too much for us. No one is that smart. And our software, even at its best, is hard to hold in our heads, hard to make sure that our changes don’t break something seemingly unrelated, hard to see how the pieces fit together—hard, in a phrase you’ll often hear from functional programming fans, hard to reason about.&lt;/p&gt;
&lt;p&gt;So, how do we solve these problems? With functional programming!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming-1" class="level3"&gt;
&lt;h3&gt;What &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/h3&gt;
&lt;p&gt;Functional programming is basically combining four bigs ideas:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;First class functions&lt;/li&gt;
&lt;li&gt;Higher-order functions&lt;/li&gt;
&lt;li&gt;Pure functions&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The combination of these things leads us to a &lt;em&gt;very&lt;/em&gt; different style of programming than traditional &lt;abbr&gt;OOP&lt;/abbr&gt;. Let’s define them.&lt;/p&gt;
&lt;section id="first-class-functions-and-higher-order-functions" class="level4"&gt;
&lt;h4&gt;First class functions and higher-order functions&lt;/h4&gt;
&lt;p&gt;We’ll start by looking at the things that are probably most familiar to you if you’re a JavaScript developer (even if you haven’t necessarily heard the names): first-class functions and higher-order functions.&lt;/p&gt;
&lt;p&gt;When we talk about &lt;em&gt;first class functions,&lt;/em&gt; we mean that functions are just data—they’re first-class items in the language just like any other type. As such, a function is just another thing you can hand around as an argument to other functions. There’s no distinction between a function and a number or a string or some complex data structure. This is essential because, when you combine it with higher-order functions, it allows for incredible &lt;em&gt;simplicity&lt;/em&gt; and incredible &lt;em&gt;reusability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Higher-order functions, in turn, are functions which take other functions as parameters or return them as their values. We’ll see this in detail in a worked example in a few, but for right now, let’s just use a really simple example that will be familiar to anyone who’s done much JavaScript: using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we have a collection like an array and we want to transform every piece of data in it, we could of course do it with a for loop, and with iterable types we could use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;&lt;code&gt;for ... of&lt;/code&gt;&lt;/a&gt;. But with &lt;code&gt;map&lt;/code&gt;, we can just leave the implementation details of &lt;em&gt;how&lt;/em&gt; the items in the array are iterated through, and instead worry about what we want to change. We can do that because &lt;code&gt;map&lt;/code&gt; takes functions as arguments.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(value =&amp;gt; value * 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We did it there with a function explicitly, but we could just as easily extract the function like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const double = value =&amp;gt; value * 2;
const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(double);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is possible because &lt;em&gt;functions are just data&lt;/em&gt;—they’re first-class members of the language—and therefore &lt;em&gt;functions can be arguments or return values&lt;/em&gt;—the language supports higher-order functions.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="pure-functions" class="level4"&gt;
&lt;h4&gt;Pure functions&lt;/h4&gt;
&lt;p&gt;What about &lt;em&gt;pure functions&lt;/em&gt;? Pure functions are functions with &lt;em&gt;no effects&lt;/em&gt;. The input directly translates to the output, every time. The examples we looked at just a moment ago with &lt;code&gt;map&lt;/code&gt; are all pure functions (and it’s a really weird antipattern to use effectful functions with &lt;code&gt;map&lt;/code&gt;! Don’t do that! Use &lt;code&gt;forEach&lt;/code&gt; if you must have an effect). Here are a few more super simple examples:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const toString = (number) =&amp;gt; `The value is ${number}`;
const toLength = (list) =&amp;gt; list.length;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are some examples of straightforward functions which are &lt;em&gt;not&lt;/em&gt; pure:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const logDataFromEndpoint = (endpoint) =&amp;gt; {
  fetch(endpoint).then(response =&amp;gt; {
    console.log(response);
  });
};

let foo = 42;
const setFoo = (newValue) =&amp;gt; {
  foo = newValue;
};

const getFoo = () =&amp;gt; foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a pure function is one whose output is &lt;em&gt;solely&lt;/em&gt; determined by its input That means no talking to a database, no making &lt;abbr&gt;API&lt;/abbr&gt; calls, no reading from or writing to disk.&lt;/p&gt;
&lt;p&gt;And of course, you can’t do anything meaningful with &lt;em&gt;just&lt;/em&gt; pure functions. We need user input, and we need to put the results of our computation somewhere. So the goal isn’t to write &lt;em&gt;only&lt;/em&gt; pure functions. It’s to write &lt;em&gt;mostly&lt;/em&gt; pure functions and to &lt;em&gt;isolate&lt;/em&gt; all impure functions.&lt;/p&gt;
&lt;p&gt;What this gets us is two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;A much smaller list of things to worry about when we’re looking at a given function.&lt;/li&gt;
&lt;li&gt;The ability to &lt;em&gt;compose&lt;/em&gt; functions together more easily.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have fewer things to keep in our heads when we look at any given pure function, because we don’t have to worry at all about whether something it touches has been changed by another function or not. We have inputs. We transform them into outputs. That’s it. Compare these two things in practice.&lt;/p&gt;
&lt;p&gt;Here’s a traditional &lt;abbr&gt;OOP&lt;/abbr&gt; approach:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class Order {
  constructor() {
    this.subTotal = 0.0;
    this.taxRate = 0.01;
  }

  getTotal() {
    return this.subTotal * (1 + this.taxRate);
  }
}

const order = new Order();
order.subTotal = 42.00;

const total = order.getTotal();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the total is always dependent on what has happened in the object. If we write &lt;code&gt;order.subTotal = 43&lt;/code&gt;, &lt;code&gt;order.total&lt;/code&gt; will change. So if we want to test how &lt;code&gt;total&lt;/code&gt; behaves, or if there’s a bug in it, we need to make sure we’ve made all the appropriate transformations to the object ahead of time. That’s no big deal here; the &lt;code&gt;total&lt;/code&gt; getter is incredibly simple (and in fact, we’d normally just write it with a property getter). But still, we have to construct an order and make sure all the relevant properties are set to get the right value out of &lt;code&gt;getTotal()&lt;/code&gt;. Things outside the method call itself affect what we get back. We have no way to test &lt;code&gt;getTotal()&lt;/code&gt; by itself, and no way to debug it if there’s a bug without first doing some object setup.&lt;/p&gt;
&lt;p&gt;Now, here’s a functional approach.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const order = {
  subTotal: 42.0,
  taxRate: 0.01
}

const getTotal = (subTotal, taxRate) =&amp;gt; subTotal * (1 + taxRate);
const total = orderTotal(order.subTotal, order.taxes);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the object is &lt;em&gt;just data&lt;/em&gt;. It’s a &lt;em&gt;record&lt;/em&gt;. And the function just takes a couple of arguments. If there needed to be a more complicated transformation internally, we could do that just as easily. Note that it also decouples the structure of the data from the actual computation (though we could pass in a record as well if we had a good reason to).&lt;/p&gt;
&lt;p&gt;This makes it easily testable, for free. Want to make sure different tax rates get the correct output? Just… pass in a different tax rate. You don’t have to do any complicated work setting up an object instance first (which is especially important for more complex data types). It also makes it easier to chase down any bugs: the only thing you have to care about is that simple function body. There’s no other state to think about, because there’s no state at all here from the perspective of the function: just inputs and outputs.&lt;/p&gt;
&lt;p&gt;This has one other &lt;em&gt;really&lt;/em&gt; important consequence, which goes by the name &lt;strong&gt;referential transparency&lt;/strong&gt;. All that means is that anywhere you see a pure function, you can always substitute the value it produces, or vice versa. This is quite unlike the &lt;code&gt;Order::getTotal()&lt;/code&gt; method, where (a) it’s attached to an object instance and (b) it’s dependent on other things about that object. You can’t just substitute it in, or freely move it around, when you’re doing a refactor. &lt;em&gt;Maybe&lt;/em&gt; you can, but you’d better hope that all the other state is shuffled around with it correctly. Whereas, with the standalone &lt;code&gt;getTotal()&lt;/code&gt; function, all you need is its arguments, and you’ll always get the same thing back.&lt;/p&gt;
&lt;p&gt;This is just like math: if you say, &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = 5&lt;/span&gt; when solving an algebraic equation, you can put &lt;span class="math inline"&gt;5&lt;/span&gt; &lt;em&gt;anywhere you see &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;; or, if it’s useful for factoring the equation or something, you can just as easily put &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; anywhere you see &lt;span class="math inline"&gt;5&lt;/span&gt;. And in math, that’s true for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; as well. When we use pure functions, it’s true for programming, too! That makes refactoring much easier.&lt;/p&gt;
&lt;p&gt;As we’ll see in the example I walk through in a minute, it also lets us &lt;em&gt;compose&lt;/em&gt; functions together far more easily. If all we have are inputs and outputs, then I can take the output from one function and use it as the input to the next.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="immutable-data" class="level4"&gt;
&lt;h4&gt;Immutable data&lt;/h4&gt;
&lt;p&gt;Complementing the use of mostly pure functions is to use &lt;em&gt;immutable data&lt;/em&gt;. Instead of having objects which we mutate, we create copies of the data as we transform it.&lt;/p&gt;
&lt;p&gt;You’re probably wondering how in the world this can work (and also how you avoid it being incredibly computationally expensive). For the most part, we can rely on two things: smart compilers and runtimes, and the fact that we often don’t need to reuse the &lt;em&gt;exact&lt;/em&gt; same data because we’re transforming it. However, as we’ll see below, in languages which don’t have native support for immutability, it can impose a performance penalty. Gladly, there are ways to work around this!&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="a-worked-example" class="level2"&gt;
&lt;h2&gt;A Worked Example&lt;/h2&gt;
&lt;p&gt;Let’s get down to a real example of these ideas. This is a ‘code kata’ I do every so often. In this particular kata, you get a list of burger orders which looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;[
  { condiments: [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;, &amp;#39;pickles&amp;#39;] },
  { condiments: [&amp;#39;tomatoes&amp;#39;] },
  { condiments: [&amp;#39;mustard&amp;#39;, &amp;#39;ketchup&amp;#39;] },
  // etc...
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re supposed to take this list (of 10,000-some-odd burger variations!) and determine what the top ten most common orders (not just condiments, but orders) are. (The truth is, the list actually mostly looks like &lt;code&gt;condiments: ['ketchup']&lt;/code&gt; over and over again.) So as a preliminary, you can assume that the data is being loaded like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getBurgers = () =&amp;gt;
  fetch(&amp;#39;http://files.example.com/burgers.json&amp;#39;)
    .then(request =&amp;gt; request.json());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we’ll print our results (which will always end up in the same format) like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const descAndCountToOutput = descAndCount =&amp;gt; `${descAndCount[0]}: ${descAndCount[1]}`;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is actually a perfect case to demonstrate how functional programming ideas can help us solve a problem.&lt;/p&gt;
&lt;section id="imperative" class="level3"&gt;
&lt;h3&gt;Imperative&lt;/h3&gt;
&lt;p&gt;First, let’s look at what I think is a &lt;em&gt;relatively&lt;/em&gt; reasonable imperative approach. Our basic strategy will be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  let totals = {};

  // 2. Build up a mapping from description to count.
  for (let burger of burgers) {
    // 1. Convert condiments to descriptions.
    // 1.1. Convert the objects to just their lists of condiments.
    const condiments = burger.condiments;
    // 1.2. Sort those strings.
    condiments.sort();
    // 1.3. Turn them into descriptions by joining them with a comma.
    const description = condiments.join(&amp;#39;, &amp;#39;);

    // 2. Build up a mapping from description to count.
    const previousCount = totals[description];
    totals[description] = previousCount ? previousCount + 1 : 1;
  }

  // 3. Sort that by count.
  const sortableCondiments = Object.entries(totals);
  sortableCondiments.sort((a, b) =&amp;gt; b[1] - a[1]);
  // 4. Get the top 10.
  const topTen = sortableCondiments.slice(0, 10);
  // 5. Print out the results.
  for (let descAndCount of topTen) {
    console.log(descAndCountToOutput(descAndCount));
  }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s pretty well-factored. But it’s pretty wrapped up on the specific details of this problem, and there’s basically nothing here I could reuse. It’s also relatively hard to test. There aren’t really a lot of pieces there we could break up into smaller functions if we wanted to figure out why something was broken. The way you’d end up fixing a bug here is probably by dropping &lt;code&gt;debugger&lt;/code&gt; or &lt;code&gt;console.log()&lt;/code&gt; statements in there to see what the values are at any given spot.&lt;/p&gt;
&lt;p&gt;And this is where functional programming really does give us a better way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="functional" class="level3"&gt;
&lt;h3&gt;Functional&lt;/h3&gt;
&lt;p&gt;Instead of thinking about the specific details of &lt;em&gt;how&lt;/em&gt; to get from A to B, let’s think about what we start with and what we finish with, and see if we can build up a pipeline of transformations that will get us there.&lt;/p&gt;
&lt;p&gt;We start with a &lt;em&gt;list&lt;/em&gt; of &lt;em&gt;objects&lt;/em&gt; containing &lt;em&gt;arrays&lt;/em&gt; of &lt;em&gt;strings&lt;/em&gt;. We want to end up with a &lt;em&gt;list&lt;/em&gt; of the &lt;em&gt;distinct combinations&lt;/em&gt; and their &lt;em&gt;frequency&lt;/em&gt;. How can we do this? Well, the basic idea is the same as what we did above:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To someone acquainted with functional programming, that looks like a bunch of &lt;code&gt;map&lt;/code&gt;s, a &lt;code&gt;reduce&lt;/code&gt;, and some &lt;code&gt;sort&lt;/code&gt;s. And each of those using just simple, pure functions. Let’s see what that might look like. First, what are our transformations?&lt;/p&gt;
&lt;p&gt;The step 1 transformations are all quite straightforward:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
// 1.1. Convert the objects to just their lists of condiments.
const toCondiments = burger =&amp;gt; burger.condiments ? burger.condiments : [];
// 1.2. Sort those strings.
const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();
// 1.3. Turn them into descriptions by joining them with a comma.
const toDescriptions = condiments =&amp;gt; condiments.join(&amp;#39;, &amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2 is a little more involved: it involves building up a new data structure (&lt;code&gt;totals&lt;/code&gt;) from an old one. This function is a &lt;em&gt;reducer&lt;/em&gt;: it will build up &lt;code&gt;totals&lt;/code&gt; by updating &lt;code&gt;totals&lt;/code&gt; with each &lt;code&gt;description&lt;/code&gt; from an array of them.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 2. Build up a mapping from description to count.
const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  totals[description] = count;
  return totals;
};

// 3. Sort that by count.
const byCount = (a, b) =&amp;gt; b[1] - a[1];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll see how to get just 10 in a moment; for now, let’s also wrap up the output:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 5. Print it out
const output = value =&amp;gt; { console.log(value); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are our base building blocks, and we’ll re-use them in each of the approaches I cover below. Note that we’ve now taken those same basic steps from our imperative approach and turned them into standalone, testable functions. They’re small and single-purpose, which always helps. But more importantly, (with two exceptions we’ll talk about in a minute) all of those transformations are &lt;em&gt;pure functions&lt;/em&gt;, we know that we’ll get the same results every time we use them. If I want to make sure that burger condiments are converted correctly, I can test &lt;em&gt;just that function&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;describe(&amp;#39;toCondiments&amp;#39;, () =&amp;gt; {
  it(&amp;#39;returns an empty list when there is no `condiments`&amp;#39;, () =&amp;gt; {
    toCondiments({}).should.deepEqual([]);
  });

  it(&amp;#39;returns the list of condiments when it is passed&amp;#39;, () =&amp;gt; {
    const condiments = [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;];
    toCondiments({ condiments }).should.deepEqual(condiments);
  });
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a trivial example, of course, but it gets the point across: all we have to do to test this is pass in an object. It doesn’t depend on anything else. It doesn’t have &lt;em&gt;any knowledge&lt;/em&gt; of how we’re going to use it. It doesn’t know that it’s going to be used with data coming from an array. All it knows is that if you give it an object with a &lt;code&gt;condiments&lt;/code&gt; property, it’ll hand you back the array attached to that property.&lt;/p&gt;
&lt;p&gt;The result is that, with all of these functions, we don’t have to deal with mocks or stubs or anything like that to be testable. Input produces output. Pure functions are great for this. Now, some of you may be thinking, “That’s great, but what about IO, or databases, or any other time we actually interact with the world? What about talking to a point-of-sale?” I actually have some tentative thoughts about a future tech talk to look at how to do that in some detail, but for today, just remember that the goal is to write as many pure functions as possible, and to isolate the rest of your code from knowing about that. And of course, that’s best practice anyway! We’re just codifying it. We’ll see what that looks like in practice in jus ta minute.&lt;/p&gt;
&lt;p&gt;Now, while we’re on the topic of pure functions, some of you with quick eyes may have noticed that two of these little functions we laid out are actually &lt;em&gt;not&lt;/em&gt; pure: JavaScript’s &lt;code&gt;Array.sort&lt;/code&gt; method operates in-place, for performance reasons, and so does our &lt;code&gt;toTotals&lt;/code&gt; function. So a truly pure version of the sorting function looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we &lt;em&gt;could&lt;/em&gt; define the &lt;code&gt;toTotals&lt;/code&gt; to return a new object every time, like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  const update = { [description]: count };
  return Object.assign({}, totals, update);
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, given the amount of data we’re dealing with, that’s prohibitively expensive. We end up spending a &lt;em&gt;lot&lt;/em&gt; of time allocating objects and garbage-collecting them. As a result, it’s tens of thousands of times slower. Running it on my 4GHz iMac, the in-place version takes less than 40ms. Doing it the strictly pure way—returning copies every time—takes ~53s. And if you profile it, almost all of that time is spent in &lt;code&gt;assign&lt;/code&gt; (52.95s).&lt;/p&gt;
&lt;p&gt;This takes us to an important point, though: it’s actually not a particularly big deal to have this particular data changed in place, because we’re not going to do anything &lt;em&gt;else&lt;/em&gt; with it. And in fact, under the hood, this is exactly what pure functional languages do with these kinds of transformations—precisely because it’s perfectly safe to do so, because we’re the only ones who have access to this data. We’re generating a &lt;em&gt;new&lt;/em&gt; data structure from the data that we were originally handed, and the next function will make its own new data structure (whether a copy or something else).&lt;/p&gt;
&lt;p&gt;In other words, when we’re talking about a &lt;em&gt;pure function&lt;/em&gt;, we don’t really care about internal mutability (though of course, that can bite us if we’re not careful). We’re really concerned about &lt;em&gt;external&lt;/em&gt; mutability. As long as the same inputs get the same outputs every time, the rest of the world doesn’t have to care how we got that result.&lt;/p&gt;
&lt;p&gt;Now let’s see how we use these functions.&lt;/p&gt;
&lt;section id="pure-javascript" class="level4"&gt;
&lt;h4&gt;Pure JavaScript&lt;/h4&gt;
&lt;p&gt;First, here’s a pure-JavaScript approach, but a more functional one instead of an imperative one:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const descriptionToCount = burgers
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(toDescriptions)
    .reduce(toTotals, {})

  const entries = Object.entries(descriptionToCount);

  [...entries]
    .sort(byCount)
    .slice(0, 10)  // 4. Get the top 10.
    .map(descAndCountToOutput)
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, the good: our transformation is no longer all jumbled together. In fact, our code reads a lot like our original description did. Also, notice that we just have a bunch of functions operating on data: none of the functions used here have any knowledge about where the data comes from that they operate on.&lt;/p&gt;
&lt;p&gt;But then we also have a couple things that are a &lt;em&gt;little&lt;/em&gt; bit clunky. The main thing that sticks out is that sudden stop in the chain in the middle.&lt;/p&gt;
&lt;p&gt;When we’re dealing with the &lt;code&gt;Array&lt;/code&gt; type, everything is fine, but when we convert our data into a &lt;code&gt;Map&lt;/code&gt;, we no longer have that option, so we have to jump through some hoops to do the transformation back into the data type we need. We’re stuck if the object type doesn’t have the method we need. We’re kind of trying to mash together the imperative and functional styles, and it’s leaving us in a little bit of a weird spot.&lt;/p&gt;
&lt;p&gt;There’s another issue here, though, and it’s the way that using the method-style calling convention obscures something important. When we call &lt;em&gt;most&lt;/em&gt; of those methods, we’re doing something quite different from what most &lt;em&gt;methods&lt;/em&gt; do. A method normally is an operation on an object. These methods—most of them—are operations that return &lt;em&gt;new&lt;/em&gt; objects. So it’s nice from a syntax perspective, but if we’re not &lt;em&gt;already&lt;/em&gt; familiar with the behavior of a given method, it won’t be clear at all that we’re actually generating a bunch of totally new data by calling those methods.&lt;/p&gt;
&lt;p&gt;And… two of these methods (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt;) &lt;em&gt;are&lt;/em&gt; not doing that, but are modifying an array in place instead.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="lodash" class="level4"&gt;
&lt;h4&gt;Lodash&lt;/h4&gt;
&lt;p&gt;The first step away from this problem is to use a tool like &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// More functional, with _:
// We tweak how a few of these work slightly to play nicely.
const _toDescriptions = condiments =&amp;gt; _.join(condiments, &amp;#39;, &amp;#39;);
const _byCount = _.property(1);

getBurgers().then(burgers =&amp;gt; {
  const condiments = _.map(burgers, toCondiments);
  const sortedCondiments = _.map(condiments, toSortedCondiments);
  const descriptions = _.map(sortedCondiments, _toDescriptions);
  const totals = _.reduce(descriptions, toTotals, {});
  const totalPairs = _.toPairs(totals);
  const sortedPairs = _.sortBy(totalPairs, _byCount);
  const sortedPairsDescending = _.reverse(sortedPairs);
  const topTen = _.take(sortedPairsDescending, 10);
  const forOutput = _.map(topTen, descAndCountToOutput)
  _.forEach(forOutput, output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it seems like we lost something when we moved away from the object-oriented approach. Being able to chain things, so that each item worked with the previous item, was actually pretty nice. And needing all these intermediate variables is &lt;em&gt;not&lt;/em&gt; so nice.&lt;/p&gt;
&lt;p&gt;One way around this is to use Lodash’s &lt;code&gt;_.chain&lt;/code&gt; method. That would have let us write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const foo = _.chain(burgers)
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(_toDescriptions)
    .reduce(toTotals, {})
    .toPairs()
    .sortBy(_byCount)
    .reverse()
    .take(10)
    .map(descAndCountToOutput)
    .value()
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that &lt;em&gt;is&lt;/em&gt; a win. But it only works because JavaScript is &lt;em&gt;incredibly&lt;/em&gt; dynamic and lets us change the behavior of the underlying &lt;code&gt;Array&lt;/code&gt; type. (You’d have a much harder time doing that in Java or C&lt;sup&gt;♯&lt;/sup&gt;!)&lt;/p&gt;
&lt;p&gt;Perhaps just as importantly, it requires us to make sure that we do that &lt;code&gt;_.chain()&lt;/code&gt; call on on anything we want to tackle this way. So, can we get the benefits of this some &lt;em&gt;other&lt;/em&gt; way? Well, obviously the answer is &lt;em&gt;yes&lt;/em&gt; because I wouldn’t be asking otherwise.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="with-ramda." class="level4"&gt;
&lt;h4&gt;With Ramda.&lt;/h4&gt;
&lt;p&gt;But we can actually go a bit further, and end up in a spot where we don’t need to modify the object prototype at all. We can just do this with a series of standalone functions which don’t depend on being attached to &lt;em&gt;any&lt;/em&gt; object. If we use the &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; library,&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; we can tackle this with nothing but functions.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
  R.reduce(toTotals, {}),
  R.toPairs,
  R.sortBy(R.prop(1)),  // will give us least to greatest
  R.reverse,
  R.take(10),
  R.map(descAndCountToOutput)
);

return getBurgers()
  .then(getTop10Burgers)
  .then(R.forEach(output));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the difference between here and even where we started with Lodash: we’re no longer dependent on a specific piece of data being present. Instead, we’ve created a standalone function which can operate on that data, simply by “piping” together—that is, &lt;em&gt;composing&lt;/em&gt;—a bunch of other, smaller functions. The output from each one is used as the input for the next.&lt;/p&gt;
&lt;p&gt;One of the many small niceties that falls out of this is that we can refactor this just by pulling it apart into smaller acts of compositions.&lt;/p&gt;
&lt;p&gt;Here’s an example of how we might use that. We defined those simple transformations for the condiments as a set of three functions, which converted them from objects with &lt;code&gt;condiments&lt;/code&gt; elements, sorted them, and joined them into a string. Now, let’s build those into meaningful functions for each step:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
const burgerRecordsToDescriptions = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
);

// 2. Build up a mapping from description to count.
const descriptionsToUniqueCounts = R.pipe(
  R.reduce(toTotals, {}),
  R.toPairs,
);

// 3. Sort that by count.
const uniqueCountsToSortedPairs = R.pipe(
  R.sortBy(R.prop(1)),
  R.reverse,
);

// For (4), to get the top 10, we&amp;#39;ll just use `R.take(10)`.
// We could also alias that, but it doesn&amp;#39;t gain us much.

// 5. Print it out
const sortedPairsToConsole = R.pipe(
  R.map(descAndCountToOutput),
  R.forEach(output)
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can put those together into another, top-level function to do &lt;em&gt;exactly&lt;/em&gt; our steps.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  burgerRecordsToDescriptions,  // (1)
  descriptionsToUniqueCounts,   // (2)
  uniqueCountsToSortedPairs,    // (3)
  R.take(10)                    // (4)
);

getBurgers()
  .then(getTop10Burgers)
  .then(sortedPairsToConsole);  // (5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, because each step is just composing together functions, “refactoring” is easy. And, to be sure, you have to be mindful about what comes in and out of each function. But that’s true in the imperative approach, too: you always have to keep track of the state of the object you’re building up, but there you’re doing it in the middle of a loop, so you’re keeping track of a lot &lt;em&gt;more&lt;/em&gt; state at any given time. Functions with simple inputs and outputs give us a more explicit way of specifying the structure and state of the data at any given time. That’s true even in JavaScript, but it goes double if we’re in a typed language like F&lt;sup&gt;♯&lt;/sup&gt;, Elm, etc., where we can specify those types for the function as a way of designing the flow of the program. (That’s such a helpful way of solving problems, in fact, that I may also do a talk on type-driven design in the future!)&lt;/p&gt;
&lt;p&gt;Note, as well, that we’ve now completely isolated our input and output from everything else. The middle there is a chain of pure functions, built out of other pure functions, which neither know nor care that the data came in from an &lt;abbr&gt;API&lt;/abbr&gt; call, or that we’re going to print it to the console when we finish.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;So this takes us back around to that first question: why do we care? At the end of the day, is this really a win over the imperative style? Is the final version, using Ramda, really better than the pure-JavaScript mostly-functional version we used at first?&lt;/p&gt;
&lt;p&gt;Obviously, I think the answers there are yes. The Ramda version there at the end is &lt;em&gt;way&lt;/em&gt; better than the imperative version, and substantially better than even the first “functional” JavaScript versions we wrote.&lt;/p&gt;
&lt;p&gt;For me, at least, the big takeaway here is this: we just built a small but reasonable transformation of data out of a bunch of really small pieces. That has two big consequences—consequences we’ve talked about all along the way, but which you’ve now seen in practice:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Those pieces are easy to test. If something isn’t working, I can easily take those pieces apart and test them individually, or test the result of any combination of them. As a result, I can test any part of that pipe chain, and I can &lt;em&gt;fix&lt;/em&gt; pieces independent of each other. No part depends on being in the middle of a looper where transformations are done to other parts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because they’re small and do one simple things, I can recombine those pieces any way I like. And you see that in the Ramda examples in particular: most of what we’re doing in those examples is not even something we wrote ourselves. They’re also &lt;em&gt;really&lt;/em&gt; basic building blocks, available in basically every standard library.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One last thing: if you’re curious about performance… you should know that it does matter for data at scale. In my tests (which are admittedly extremely unscientific; unfortunately, I couldn’t get JSPerf running nicely with this particular set of variations), I found that the time it took to run these varied depending on the approach &lt;em&gt;and&lt;/em&gt; the library. With a ~10k-record data set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The imperative version, unsurprisingly, was the fastest, taking ~16–17ms.&lt;/li&gt;
&lt;li&gt;After that, the chained lodash version and the pure-JS version were comparable, at ~32–36ms, or around twice as long to finish as the imperative version.&lt;/li&gt;
&lt;li&gt;The plain lodash version was consistently a &lt;em&gt;little&lt;/em&gt; slower yet, at ~38–43ms.&lt;/li&gt;
&lt;li&gt;Ramda is &lt;em&gt;slow&lt;/em&gt;: both variations consistently took over 90ms to finish.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those differences added up on larger data sets: dealing with ~10,000,000 records, the times ranged from ~12s for the imperative version, to ~15s for the lodash and pure-JS variants, to ~50s for the Ramda version.&lt;/p&gt;
&lt;p&gt;They were all pretty darn quick. Compilers, including JavaScript JITs, are incredibly smart. Mostly you can just trust them; come back and profile before you even &lt;em&gt;think&lt;/em&gt; about optimizing things. But you &lt;em&gt;should&lt;/em&gt; know the performance characteristics of different libraries and consider the implications of what the language does well and what it doesn’t. Ramda is likely slower because of the way it curries every function—something that works well in languages with native support for it, e.g. F&lt;sup&gt;♯&lt;/sup&gt; or Elm or Haskell, but imposes a penalty in languages which don’t… like JavaScript. That said, if you’re not in the habit of processing tens of thousands of records, you’re probably okay using any of them.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;or &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt;, but Ramda is a bit better documented and I just like it a little better&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 Nov 2016 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-11:2016/what-is-functional-programming.html</guid><category>functional programming</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/11-05-1524.html</link><description>&lt;p&gt;Pro tip: use &lt;code&gt;Map&lt;/code&gt; and not &lt;code&gt;Object&lt;/code&gt; for dictionaries/hash-tables in JavaScript. Performance difference is A LOT. (I haven’t measured, but for a simple example I was playing with (~12k items) it was at least a couple orders of magnitude.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; Belay that: the problem was an allocation-speed issue: I wasn’t reallocating a &lt;code&gt;Map&lt;/code&gt;. Updating in-place is much more comparable.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 05 Nov 2016 15:24:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-05:2016/11-05-1524.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/10-08-0922.html</link><description>&lt;p&gt;People, React is great—truly! But the fact that you only learned about the ideas it uses from React doesn’t make React itself the paradigm.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 08 Oct 2016 09:22:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-10-08:2016/10-08-0922.html</guid><category>software development</category><category>javascript</category><category>reactjs</category></item><item><title></title><link>http://www.chriskrycho.com/2016/10-08-0740.html</link><description>&lt;p&gt;People, React is great—truly! But the fact that you only learned about the ideas it uses from React doesn’t make React itself the paradigm.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 08 Oct 2016 07:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-10-08:2016/10-08-0740.html</guid><category>javascript</category><category>software development</category><category>reactjs</category></item><item><title>Rust vs. React Native—What?</title><link>http://www.chriskrycho.com/2016/rust-vs-react-native-what.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was recently discussing some thoughts I’ve had on building a top-notch application experience in a Slack team I belong to, and noted that I believe that a Rust core with native UIs is a &lt;em&gt;massively&lt;/em&gt; winning strategy. A friend in the group responded that he thinks “React + JS is eating the world right now” and that “Rust as awesome for if you want to write a JS vm, or something like that… or a compiler… anything involving lots of speed and stability.” What follows is my response, lightly edited to remove details specific to that friend and to add a few further thoughts.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Here’s the thing: I don’t &lt;em&gt;care&lt;/em&gt; what’s eating the world today, for three reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I just want to build the best stuff I can build, and native UIs are still massively better than React and even React Native&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in innumerable ways. There are clear advantages to React Native + JavaScript, and times when you absolutely should take that approach. But there are also a lot of times and reasons why you shouldn’t. Heck, even if you just want killer performance &lt;em&gt;in browsers&lt;/em&gt;, our future includes things like Rust-to-WebAssembly, and that’s a good thing.&lt;/li&gt;
&lt;li&gt;What was eating the world five years ago? Ten? Is it still eating the world today? I don’t feel obliged to follow those trends (not least because, not being a consultancy, following those trends doesn’t buy me anything for the things I want to do; your tradeoffs and mine look way different).&lt;/li&gt;
&lt;li&gt;I’m actually getting really tired of just treating as acceptable or normative the performance characteristics of browsers. Browsers are awesome. But we can (and should) do a &lt;em&gt;lot&lt;/em&gt; better in terms of user experience, and I don’t see browsers catching up to what you can do with e.g. Cocoa (Touch). Sure, that doesn’t matter that much for building yet-another-storefront. (Again, there are different tradeoffs for every single app!) But why in the world are we in a spot now where one of the most popular text editors in the world is &lt;em&gt;slower&lt;/em&gt; than any text editor of five years ago? That’s not a &lt;em&gt;necessary&lt;/em&gt; decision, and you can (and should) go after the same degree of ease-of-extensibility that Atom has had—perhaps even using things like HTML and CSS for skinning!—while not tying yourself to the browser and its upsides and downsides for &lt;em&gt;everything&lt;/em&gt;. We have &lt;em&gt;incredibly&lt;/em&gt; powerful machines, and the user experience is often getting &lt;em&gt;slower&lt;/em&gt;. I’m looking for ways to change that.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, JS+React&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; may be &lt;em&gt;exactly&lt;/em&gt; the right tradeoff for a lot of apps, and given what consultancies (like my friends’s!) are doing, I think doing that with ReactNative for apps is a &lt;em&gt;very&lt;/em&gt; good move. It makes good sense business-wise, and it makes good sense in terms of the apps you’re likely to be delivering. Don’t hear me for a second saying Rust is the best for &lt;em&gt;everything&lt;/em&gt;. I think it, or something like it, is a very good choice for &lt;em&gt;many&lt;/em&gt; things, though, and it shouldn’t be dismissed simply because it’s a very different world from doing Ruby or Elixir or JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;So much for my initial response. On reflection, I wanted to expand it a bit. So here’s another few hundred words!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Beyond this, I think there’s a bit of a false dichotomy here: the idea that “lots of speed and stability” &lt;em&gt;aren’t&lt;/em&gt; values we should be seeking more aggressively for &lt;em&gt;all&lt;/em&gt; our apps. Fully granted that not every app needs the same &lt;em&gt;degree&lt;/em&gt; of each of those, and moreover that there are a lot of ways to get to those goals. Still: speed and stability are &lt;em&gt;core&lt;/em&gt; user experience values. I don’t really care how you get at those goals, whether it’s with Rust, or Elixir or Clojure, or, yes, React with TypeScript or &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt;. I &lt;em&gt;do&lt;/em&gt; think that Rust is, for the moment at least, uniquely positioned to add real value in this space because it gives screaming performance but with so many niceties we’re used to when writing languages like Python or Ruby and so much of the power you get in languages like OCaml or F♯.&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; But at the end of the day, I think &lt;em&gt;all&lt;/em&gt; apps should focus much more on speed and stability than they do today. We have supercomputers in our pockets, and we’re often shipping apps that are slower and more finicky.&lt;/p&gt;
&lt;p&gt;But I have this dream of a world where apps aren’t needlessly power-hungry or memory-intensive, where every swipe and or click or scroll results in buttery-smooth responses. We won’t get there by saying, “You know, Facebook is doing &lt;em&gt;x&lt;/em&gt; so that’s good enough for me.”&lt;/p&gt;
&lt;p&gt;Of course every developer, and any given product shop or consultancy, is going to have to make decisions about which stacks it invests in. If you’re primarily shipping web applications, investing in Elixir and React with React Native for your apps is a very sensible move. Most of your clients’ native apps may not &lt;em&gt;need&lt;/em&gt; the degree of polished performance you might get from writing their iOS app in Swift and their Android app in Kotlin and the core in Rust (or even C++). That tradeoff is a &lt;em&gt;tradeoff&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But let’s remember that there is real value there, and that some apps &lt;em&gt;do&lt;/em&gt; deserve that investment. We should evaluate the tradeoffs at every turn, and our core considerations should enduringly include &lt;em&gt;speed and stability&lt;/em&gt;. Don’t dismiss Rust (or Swift, or F♯) out of hand.&lt;/p&gt;
&lt;p&gt;Equally importantly, we need to stop assuming that just because something is eating the world today means it’s also the future. Betting big on Flash in the mid-2000s wasn’t a &lt;em&gt;bad&lt;/em&gt; move by a long shot. But its massive popularity then wasn’t a good predictor for its future. That goes double, frankly, for projects coming out of Facebook or Google or similar: big companies like that have the resources to drop everything and use a new language, or a new tool, as it suits them. If you don’t believe me, look at the actual open-source records of both of those companies! What’s hot today is far more relevant to a consultancy than to a product shop. And in both cases, choosing tech suitable for the job at hand is more important yet.&lt;/p&gt;
&lt;p&gt;My friend gets that, for what it’s worth. He’s making the right moves for his business as the owner of a consultancy. I just want him—and lots of other people—to see where languages like Rust and Swift and F♯ might be worth considering. And speed and stability matter in a lot of places besides just compilers and VMs.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I’m aware that React-Native ultimately binds down to native widgets. It’s still not quite the same.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;or, frankly, Ember or whatever else; React is great, but it is also overhyped.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Swift too, and honestly for a lot of things Swift is an easier experience for not &lt;em&gt;that&lt;/em&gt; much less performance than Rust. But as of today you &lt;em&gt;can’t&lt;/em&gt; ship core functionality in Swift for Android or Windows.&lt;a href="#fnref3"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Oct 2016 08:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-10-07:2016/rust-vs-react-native-what.html</guid><category>JavaScript</category><category>Rust</category><category>Swift</category><category>F Sharp</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/08-17-0825.html</link><description>&lt;p&gt;I’m writing a talk on test-driven development with &lt;a href="http://emberjs.com"&gt;Ember.js&lt;/a&gt; for &lt;a href="http://www.olo.com"&gt;Olo&lt;/a&gt;’s in-house tech talks. How? By building a real feature and capturing the process!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 17 Aug 2016 08:25:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-08-17:2016/08-17-0825.html</guid><category>software development</category><category>testing</category><category>javascript</category><category>emberjs</category></item><item><title></title><link>http://www.chriskrycho.com/2016/08-15-0628.html</link><description>&lt;p&gt;My &lt;a href="https://twitter.com/hashtag/firstsevenlanguages"&gt;#firstsevenlanguages&lt;/a&gt;—looking strictly at what I’d used &lt;em&gt;at all&lt;/em&gt;; ignoring HTML and CSS):&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Visual Basic&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;Fortran&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In terms of what I learned well enough to use, though:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Fortran&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;/ol&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 15 Aug 2016 06:28:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-08-15:2016/08-15-0628.html</guid><category>programming languages</category><category>visual basic</category><category>cplusplus</category><category>fortran</category><category>java</category><category>c</category><category>php</category><category>javascript</category><category>python</category></item><item><title></title><link>http://www.chriskrycho.com/2016/07-30-1048.html</link><description>&lt;p&gt;I’m quickly discovering a desire for actual, enforceable types as I’m trying to compose a series of functions. It’s &lt;em&gt;hard&lt;/em&gt; without them.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 30 Jul 2016 10:48:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-30:2016/07-30-1048.html</guid><category>software development</category><category>javascript</category><category>programming languages</category></item><item><title></title><link>http://www.chriskrycho.com/2016/07-28-2040.html</link><description>&lt;p&gt;I’m so used to dealing with layout distinctly from &lt;em&gt;behavior&lt;/em&gt; with the HTML/CSS/JS separation that learning how to lay things out in macOS apps feels &lt;em&gt;weird&lt;/em&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 28 Jul 2016 20:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-28:2016/07-28-2040.html</guid><category>javascript</category><category>swift</category><category>software development</category><category>html</category><category>css</category></item><item><title></title><link>http://www.chriskrycho.com/2016/07-16-1253.html</link><description>&lt;p&gt;I am trying to fix a bug in a Node.js back end I wrote 18 months ago. And I have never been so tempted in my life to rip out the entire Node back end and replace it with one written in Rust.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 16 Jul 2016 12:53:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-16:2016/07-16-1253.html</guid><category>software development</category><category>javascript</category><category>rust</category></item><item><title></title><link>http://www.chriskrycho.com/2016/07-08-1536.html</link><description>&lt;p&gt;I haven’t gotten almost anything done today. I think I’m calling today my day off for this week and I’ll hammer at productive things later.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 08 Jul 2016 15:36:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-08:2016/07-08-1536.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/07-06-0700.html</link><description>&lt;p&gt;Wow: a minimal (but extremely useful) &lt;a href="https://lodash.com"&gt;lodash&lt;/a&gt; install is only 4kb minified and gzipped. I… need to have this available to use everywhere now, please.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 06 Jul 2016 07:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-06:2016/07-06-0700.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/06-30-1114.html</link><description>&lt;p&gt;I’d love—&lt;em&gt;love&lt;/em&gt;—to see an open standard for embedding browser engines (a la Chromium/Electron) emerge, so you can embed whichever you like.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 30 Jun 2016 11:14:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-30:2016/06-30-1114.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/06-22-1510.html</link><description>&lt;p&gt;The build worked on &lt;code&gt;develop&lt;/code&gt; last night. We have made no commits. Now it fails.&lt;/p&gt;
&lt;p&gt;Current best guess: transitive dependencies. Thanks, npm.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 22 Jun 2016 15:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-22:2016/06-22-1510.html</guid><category>software development</category><category>javascript</category></item><item><title>Y Combinators, how do they even work?</title><link>http://www.chriskrycho.com/2016/y-combinators-how-do-they-even-work.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was reading &lt;a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/"&gt;a post&lt;/a&gt; by &lt;a href="http://matt.might.net"&gt;Matt Might&lt;/a&gt;, a computer science professor at the University of Utah, about Y Combinators, and I was having a hard time tracking with some of it just by reading. The way I normally solve this problem is to write it out—and, optimally, to write it out in something roughly like &lt;a href="https://wiki.haskell.org/Literate_programming"&gt;Literate Haskell&lt;/a&gt; or &lt;a href="http://coffeescript.org/#literate"&gt;Literate CoffeeScript&lt;/a&gt;. That’s exactly what you’ll find below; this is basically &lt;em&gt;commentary&lt;/em&gt; on Might’s original post.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;A few other prefatory notes:&lt;/i&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;i class=editorial&gt;Since this is commentary, I’m not focusing on explaining combinators in general. For a very helpful explanation, though, both of what combinators are and why you’d ever want to use them, &lt;a href="http://programmers.stackexchange.com/a/117575"&gt;read this&lt;/a&gt;.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;The Y Combinator itself isn’t all that useful for ordinary programming. It &lt;em&gt;is&lt;/em&gt; really useful as a way of thinking about how programming &lt;em&gt;works&lt;/em&gt;, and that’s why I was reading about it and trying to figure out what was going on in Might’s original post.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;This didn’t actually all make sense to me until I also read Might’s post, &lt;a href="http://matt.might.net/articles/python-church-y-combinator/"&gt;“Equational derivations of the Y combinator and Church encodings in Python”&lt;/a&gt;. Which is a crazy post. But kind of fun. &lt;/i&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Note for background (this was new to me today): &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;v&lt;/em&gt;.&lt;em&gt;e&lt;/em&gt;&lt;/span&gt; is the function which maps v to e. In ECMAScript 2015 or later (hereafter just JS):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λv_e = v =&amp;gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Y Combinator is a higher-order functional: it is a function which takes a functional/higher-order function. Quoting from Might:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Y combinator takes a functional as input, and it returns the (unique) fixed point of that functional as its output. A functional is a function that takes a function for its input. Therefore, the fixed point of a functional is going to be a function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And a “fixed point” is an input to a function equal to the &lt;em&gt;output&lt;/em&gt; of the function. (Not all functions have such.) A fixed point is where &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;. He uses the example &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; − 1&lt;/span&gt;, which has two solutions, two &lt;em&gt;fixed points&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;He starts out with the total recursion form—also known as the “crash all the things!” form—of the Y-combinator. (I’m using letters to denote the version of the combinator; this is Y-naive.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yn = (F) =&amp;gt; F(Yn(F))  // all the recursing!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“Crash all the things”… because of one pesky little detail: it calls itself immediately, and so recurses infinitely. Which is actually kind of a problem.&lt;/p&gt;
&lt;p&gt;Might then asks: What if we transformed this a bit? He notes that we can &lt;em&gt;transform&lt;/em&gt; with lambda calculus to expand what we’re doing, so:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)=&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;(I haven’t done this kind of thing since undergraduate math work I did for physics, but as I was thinking about it, it made sense. I’m used to trying to &lt;em&gt;remove&lt;/em&gt; extraneous variables when dealing with software, but in this case we’re using it as a tool for transforming the equation into a form that is &lt;em&gt;equivalent&lt;/em&gt; but &lt;em&gt;expressed differently&lt;/em&gt;.)&lt;/p&gt;
&lt;p&gt;And &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; is equivalent to the fixed point. It’s the function which takes &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as an argument and results in &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;; but &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; is just another argument, so this looks just like our original &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;, but with &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; substituted for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;&lt;/span&gt;. Can we write this in JS?&lt;/p&gt;
&lt;p&gt;Here’s my implementation, using modern JS; note that it still recurses. (I’m calling this updated Y-transformed, so &lt;code&gt;Yt&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yt = (F) =&amp;gt; F((x) =&amp;gt; Yt(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His version:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function Y(F) { return F(function(x) { return Y(F)(x); }); }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mine and his are equivalent; here’s his version transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; F((x) =&amp;gt; Y(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Might then says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using another construct called the U combinator, we can eliminate the recursive call inside the Y combinator, which, with a couple more transformations gets us to:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I hated it when profs (or books!) did this when I was in college, and it frustrates me here, too. I want to &lt;em&gt;see&lt;/em&gt; the transformation. I really wish Might didn’t skip how the U combinator works or what transformations he applies, because then he jumps to this form:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt; = (&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;Writing this out in JS is going to be a real bear. More to the point, I don’t know how he got to it; now I need to go look up the U Combinator it seems.&lt;/p&gt;
&lt;p&gt;…which I’ve &lt;a href="http://www.ucombinator.org"&gt;now done&lt;/a&gt;. So:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the theory of programming languages, the U combinator, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;&lt;/span&gt;, is the mathematical function that applies its argument to its argument; that is &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)=&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;, or equivalently, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt; = &lt;em&gt;λ&lt;/em&gt;&lt;em&gt;f&lt;/em&gt;.&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;That is, the U Combinator is the case where you apply a function to itself: &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)=&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;—you can see that in the result there, where the first expression is the same as the argument handed to it (and both are functions). It’s also there in the &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;)&lt;/span&gt; calls.&lt;/li&gt;
&lt;li&gt;The transformations are just transforming from a function-argument for to a lambda form, I think. The kind of thing where you go from &lt;code&gt;function a(b) { return c }&lt;/code&gt; to &lt;code&gt;var a = function(b) { return c }&lt;/code&gt; in JS. (Better, in &lt;em&gt;modern&lt;/em&gt; JS, to &lt;code&gt;const a = (b) =&amp;gt; c&lt;/code&gt;.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I’ll return to that in a moment. First, writing up the JS. The innermost term is (repeated) &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;, so we’ll start by writing this out.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λ_inner = (x) =&amp;gt; (h(h)(F))(x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need the definition of &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;&lt;/span&gt; next; this comes from further out, the transformation &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;)&lt;/span&gt; (where we’re substituting the &lt;code&gt;λ_inner&lt;/code&gt; we just wrote to make this a bit easier to get our heads around).&lt;/p&gt;
&lt;p&gt;Remembering that each “.” in the equation represents a mapping, i.e. a JS function call, we have this (writing it with function definitions starting new lines to clarify):&lt;/p&gt;
&lt;p&gt;Here’s what I came up with as a fairly direct translation into JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
) (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His (note that things are aligned as they are so that it’s clear which functions match up):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var Y = function (F) {
 return (function (x) {
  return F(function (y) { return (x(x))(y);});
  })
        (function (x) {
  return F(function (y) { return (x(x))(y);});
  }) ;
} ;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
) (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His and mine are not &lt;em&gt;quite&lt;/em&gt; the same (though I know they’re equivalent because they both work). I really wish he’d explained how he got &lt;em&gt;this&lt;/em&gt; substitution as well! More importantly, I wish he’d been consistent in his notation; changing variable names is… frustrating when you’re trying to follow someone’s work.&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;When I get stuck on something like &lt;em&gt;this&lt;/em&gt;, the way I figure it out is by writing out how the substitutions would work at each step. See below.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;In any case, now that we have the Y combinator, we can use it with &lt;code&gt;FactGen&lt;/code&gt;, a functional which, if you pass it the factorial function, passes back the factorial function. &lt;code&gt;FactGen&lt;/code&gt; itself isn’t recursive. But with the Y Combinator, it builds a function which is &lt;em&gt;not&lt;/em&gt; recursive; it doesn’t reference itself anywhere. It just needs the right kind of “factory”: a function which returns &lt;em&gt;another&lt;/em&gt; funtion which itself &lt;em&gt;is&lt;/em&gt; recursive. Here’s a standard recursive factorial implementation (identical to the one Might supplies, though modernized):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const FactGen =
  (fact) =&amp;gt;
    (n) =&amp;gt; n === 0 ? 1 : n * fact(n - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You call that like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;Y(FactGen)(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Y(FactGen)&lt;/code&gt; call gets back a function which then runs on whatever input you hand it (a fairly standard pattern with curried arguments), so you could also write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const factorial = Y(FactGen)
factorial(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I’m still not sure how his and mine are equivalent.&lt;/p&gt;
&lt;p&gt;A note: wrapping things in &lt;code&gt;(...)&lt;/code&gt; in JS defines that wrapped content as a distinct &lt;em&gt;expression&lt;/em&gt;. As long as the type of a given expression is a function, it can be called with an argument. So &lt;code&gt;(function() {})()&lt;/code&gt; or &lt;code&gt;(() =&amp;gt; {})()&lt;/code&gt; takes a no-operation function and immediately executes it.&lt;/p&gt;
&lt;p&gt;So in his Y combinator, the substitution goes like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (  // F is FactGen
  // x is the identical function passed as argument below
  (x) =&amp;gt;
    // Run FactGen by taking the function below as its `fact`
    // argument.
    F(
      // `y` is the argument passed to the result of Y, e.g.
      // `fact(5)`. Recall that `x` is the function below; we
      // call it with itself. Calling x(x) will get the actual
      // factorial function returned by `FactGen`.
      (y) =&amp;gt; x(x)(y)
    )
// We close the *expression* which defines the outer function,
// and call it with this next expression as an argument.
) (
  // and x here is the same function, passed as argument
  (x) =&amp;gt;
    // Again, run `FactGen` with this function as its argument.
    F(
      // `y`, again, will be the integer. `x(x)` again will be
      // the actual factorial function.
      (y) =&amp;gt; x(x)(y)
    )
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty funky! But it works; the two anonymous functions call &lt;em&gt;each other&lt;/em&gt; rather than recursing directly.&lt;/p&gt;
&lt;p&gt;In mine, it goes like this, instead:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Ymine = (
  // Where in Might&amp;#39;s example, the `x` function was where the
  // U Combinator was applied, here (because I followed the
  // original notation he gave) it&amp;#39;s `h`. So it&amp;#39;s `h` which is
  // the same function handed back and forth as argument
  // to itself.
  (h) =&amp;gt;
    // `h` takes a functional, which takes `FactGen` as its
    // parameter. This is similar to the outermost function in
    // Might&amp;#39;s version.
    (F) =&amp;gt;
      // As in Might&amp;#39;s version, we call `FactGen` here.
      F(
        // The form is *similar* but not identical to his,
        // because of the extra call structure. `h(h)(F)` is the
        // factorial function.
        //
        // Note that then he has `y` where I have `x`; my `x`
        // and his `y` are just the result of the computation
        // (in this case, the integer factorial).
        (x) =&amp;gt; (h(h)(F))(x))
) (
  // This is identical to the above; it&amp;#39;s using the U Combinator.
  (h) =&amp;gt; (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is how his simplification worked: instead of generating the factorial function each time, it generated it just the once and then &lt;em&gt;used&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;I still couldn’t &lt;em&gt;do&lt;/em&gt; the simplification he did myself. It’ll take more practice using and thinking about combinators and combinatorial logic before I get there, but that’s okay. That’s how learning works.&lt;/p&gt;
&lt;p&gt;And that’s enough playing with combinatorials for now. (Except that I’m kind of tempted to see if I can go implement the U or Y combinators—or both—in Rust.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;If you’re curious how I worked this out… I expanded the JS representations of the final forms (&lt;a href="//www.chriskrycho.com/extra/ycombinator.js"&gt;here’s the code&lt;/a&gt;) and then stepped through the result in my JavaScript dev tools, watching how the function calls worked and what the values of each intermediate value were. It’s fascinating, and well worth your time.&lt;/i&gt;&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 19 Jun 2016 09:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-19:2016/y-combinators-how-do-they-even-work.html</guid><category>javascript</category><category>software development</category><category>programming languages</category></item><item><title></title><link>http://www.chriskrycho.com/2016/11-1729.html</link><description>&lt;p&gt;I spent the afternoon modernizing a large chunk of Node.js code in preparation for fixing a bug—and I’ve caught &lt;em&gt;multiple&lt;/em&gt; other bugs along the way. (Also, my comfort level with JavaScript and functional programming has taken a massive leap since I originally wrote this!)&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 11 Jun 2016 17:29:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-11:2016/11-1729.html</guid><category>javascript</category><category>software development</category><category>nodejs</category></item><item><title>Testing Ember.js Mixins With a Container</title><link>http://www.chriskrycho.com/2016/testing-emberjs-mixins-with-a-container.html</link><description>&lt;p&gt;Today I was working on an Ember.js &lt;a href="http://emberjs.com/api/classes/Ember.Mixin.html#content"&gt;mixin&lt;/a&gt; for the new mobile web application we’re shipping at Olo, and I ran into an interesting problem when trying to test it.&lt;/p&gt;
&lt;p&gt;When you’re testing mixins, you’re generally not working with the normal Ember container.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; In fact, the default test setup for mixins doesn’t have &lt;em&gt;any&lt;/em&gt; container in play. It just looks like this (assuming you ran &lt;code&gt;ember generate mixin bar&lt;/code&gt; in an app named &lt;code&gt;foo&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;
import BarMixin from &amp;#39;foo/mixins/bar&amp;#39;;
import { module, test } from &amp;#39;qunit&amp;#39;;

module(&amp;#39;Unit | Mixin | bar&amp;#39;);

// Replace this with your real tests.
test(&amp;#39;it works&amp;#39;, function(assert) {
  let BarObject = Ember.Object.extend(BarMixin);
  let subject = BarObject.create();
  assert.ok(subject);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It uses the basic Qunit &lt;code&gt;module&lt;/code&gt; setup, not the ember-qunit &lt;code&gt;moduleFor&lt;/code&gt; setup.&lt;/li&gt;
&lt;li&gt;It assumes you’re generating a new object instance for every single test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of those assumptions are fine, &lt;em&gt;if you don’t need to interact with the container&lt;/em&gt;. In many cases, that’s perfectly reasonable—I’d go so far as to say that most mixins probably &lt;em&gt;shouldn’t&lt;/em&gt; have any dependency on the container.&lt;/p&gt;
&lt;p&gt;In the specific case I was working on, however, the point of the mixin was to abstract some common behavior which included all the interactions with a &lt;a href="https://guides.emberjs.com/v2.6.0/applications/services/"&gt;service&lt;/a&gt;. This meant making sure the dependency injection worked in the unit test. This in turn meant dealing with the container. So let’s see what was involved in that.&lt;/p&gt;
&lt;p&gt;We start by switching from the basic &lt;code&gt;qunit&lt;/code&gt; helpers to using the &lt;code&gt;ember-qunit&lt;/code&gt; helpers.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// Replace this...
import { module, test } from &amp;#39;qunit&amp;#39;;
module(&amp;#39;Unit | Mixin | bar&amp;#39;);

// with this:
import { moduleFor, test } from &amp;#39;ember-qunit&amp;#39;;
moduleFor(&amp;#39;mixin:bar&amp;#39;, &amp;#39;Unit | Mixin | Bar&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;moduleFor()&lt;/code&gt; helper has two things going for it—one of which we &lt;em&gt;need&lt;/em&gt;, and one of which isn’t strictly &lt;em&gt;necessary&lt;/em&gt;, but has some nice functionality. In any case, this will help when registering a container. Those two features:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It does support the use of the container. In fact, it’s declaring how this mixin relates to the container in the first argument to the helper function: &lt;code&gt;'mixin:foo'&lt;/code&gt; is the definition of the mixin for injection into the container.&lt;/li&gt;
&lt;li&gt;Any functions we define on the options argument we can pass to the &lt;code&gt;moduleFor()&lt;/code&gt; helper are available on the &lt;code&gt;this&lt;/code&gt; of the test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, in the first version of this, I had set up a common &lt;code&gt;Ember.Object&lt;/code&gt; which had mixed in the &lt;code&gt;BarMixin&lt;/code&gt;, so:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const BarObject = Ember.Object.extend(BarMixin);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in each test, I created instances of this to use:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;test(&amp;#39;test some feature or another&amp;#39;, function(assert) {
  const subject = BarObject.create();
  // ...do stuff and test it with `assert.ok()`, etc.
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem was that any of those tests which required a container injection always failed. Assume we have a service named &lt;code&gt;quux&lt;/code&gt;, and that it’s injected into the mixin like this in &lt;code&gt;foo/app/mixins/bar.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Mixin.create({
  quux: Ember.inject.service()
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any test which actually tried to &lt;em&gt;use&lt;/em&gt; &lt;code&gt;quux&lt;/code&gt; would simply fail because of the missing container (even if you specified in the test setup that you needed the service):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test(&amp;#39;it uses quux somehow&amp;#39;, function(assert) {
  const subject = BarObject.create();
  const quux = subject.get(&amp;#39;quux&amp;#39;);  // throws Error
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Specifically, you will see &lt;code&gt;Attempting to lookup an injected property on an object without a container&lt;/code&gt; if you look in your console.&lt;/p&gt;
&lt;p&gt;Taking advantage of the two &lt;code&gt;ember-qunit&lt;/code&gt; features, though, we can handle all of this.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;
import { moduleFor, test } from &amp;#39;ember-qunit&amp;#39;;

const { getOwner } = Ember;

moduleFor(&amp;#39;mixin:bar&amp;#39;, &amp;#39;Unit | Mixin | bar&amp;#39;, {
  // The `needs` property in the options argument tells the test
  // framework that it needs to go find and instantiate the `quux`
  // service. (Note that if `quux` depends on other injected
  // services, you have to specify that here as well.)
  needs: [&amp;#39;service:quux&amp;#39;],

  // Again: any object we create in this options object will be
  // available on the `this` of every `test` function below. Here,
  // we want to get a &amp;quot;test subject&amp;quot; which is attached to the
  // Ember container, so that the container is available to the
  // test subject itself for retrieving the dependencies injected
  // into it (and defined above in `needs`).
  subject() {
    BarObject = Ember.Object.extend(BarMixin);

    // This whole thing works because, since we&amp;#39;re in a
    // `moduleFor()`, `this` has the relevant method we need to
    // attach items to the container: `register()`.
    this.register(&amp;#39;test-container:bar-object&amp;#39;, BarObject);

    // `Ember.getOwner` is the public API for getting the
    // container to do this kind of lookup. You can use it in lots
    // of places, including but not limited to tests. Note that
    // that because of how the dependency injection works, what we
    // get back from the lookup is not `BarObject`, but an
    // instance of `BarObject`. That means that we don&amp;#39;t need to
    // do `BarObject.create()` when we use this below; Ember
    // already did that for us.
    return getOwner(this).lookup(&amp;#39;test-container:bar-object&amp;#39;);
  }
});

test(&amp;#39;the mixin+service does what it should&amp;#39;, function(assert) {
  // We start by running the subject function defined above. We
  // now have an instance of an `Ember.Object` which has
  // `BarMixin` applied.
  const subject = this.subject();

  // Now, because we used a test helper that made the container
  // available, declared the dependencies of the mixin in `needs`,
  // and registered the object we&amp;#39;re dealing with here, we don&amp;#39;t
  // get an error anymore.
  const quux = subject.get(&amp;#39;quux&amp;#39;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, in summary:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Use the &lt;code&gt;ember-qunit&lt;/code&gt; helpers if you need the container.&lt;/li&gt;
&lt;li&gt;Define whatever dependencies you have in &lt;code&gt;needs&lt;/code&gt;, just as you would in any other test.&lt;/li&gt;
&lt;li&gt;Register the mixin-derived object (whether &lt;code&gt;Ember.Object&lt;/code&gt;, &lt;code&gt;Ember.Route&lt;/code&gt;, &lt;code&gt;Ember.Component&lt;/code&gt;, or whatever else) in a method on the options argument for &lt;code&gt;moduleFor()&lt;/code&gt;. Use that to get an instance of the object and you’re off to the races!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One final consideration: while in this case it made good sense to use this approach and make the service injection available for the test, there’s a reason that the tests generated by Ember CLI don’t use &lt;code&gt;moduleFor()&lt;/code&gt; by default. It’s a quiet but clear signal that you should reevaluate whether this &lt;em&gt;is&lt;/em&gt; in fact the correct approach.&lt;/p&gt;
&lt;p&gt;In general, mixins are best used for self-contained units of functionality. If you &lt;em&gt;need&lt;/em&gt; dependency injection for them, it may mean that you should think about structuring things in a different way. Can all the functionality live on the service itself? Can all of it live in the mixin instead of requiring a service? Can the service calls be delegated to whatever type is using the mixin?&lt;/p&gt;
&lt;p&gt;But if not, and you &lt;em&gt;do&lt;/em&gt; need a mixin which injects a service, now you know how to do it!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Side note:&lt;/strong&gt; The documentation around testing mixins is relatively weak, and in general the testing docs are the weak bits in the Ember guides right now.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; After a conversation with &lt;a href="https://github.com/rwjblue"&gt;@rwjblue&lt;/a&gt; on the &lt;a href="https://ember-community-slackin.herokuapp.com"&gt;Ember Community Slack&lt;/a&gt;, though, I was able to get a handle on the issue, and here we are. Since it stumped me, I’m guessing I’m not the only one.&lt;/p&gt;
&lt;p&gt;When this happens, &lt;em&gt;write it up&lt;/em&gt;. I’ve been guilty of this too often in the past few months: learning something new that I couldn’t find anywhere online, and then leaving it stored in my own head. It doesn’t take a particularly long time to write a blog post like this, and if you’re stuck, chances are &lt;em&gt;very&lt;/em&gt; good someone else is too.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re not familiar with the “container”, this is where all the various dependencies are registered, and where Ember looks them up to inject them when you use methods like &lt;code&gt;Ember.inject.service()&lt;/code&gt;.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Something I intend to help address in the next week or two via a pull request, so if you’re my Ember.js documentation team friend and you’re reading this… it’s coming. 😉&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 09 Jun 2016 20:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-09:2016/testing-emberjs-mixins-with-a-container.html</guid><category>emberjs</category><category>javascript</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/09-1242.html</link><description>&lt;p&gt;JavaScript with semicolons written by hand is such a &lt;em&gt;sad&lt;/em&gt; language. Almost every line, it’s crying:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 09 Jun 2016 12:42:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-09:2016/09-1242.html</guid><category>javascript</category><category>programming languages</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-05-19-1928.html</link><description>&lt;p&gt;I needed to write a tiny server to test out some quirky single-page app stuff I’m doing for Olo right now. So I did it with Python and Flask.&lt;/p&gt;
&lt;p&gt;And you know what? Python is still—and forever, I suspect—so much better than JavaScript.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 19 May 2016 19:28:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-05-19:2016/2016-05-19-1928.html</guid><category>software development</category><category>programming languages</category><category>python</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-05-16-1431.html</link><description>&lt;p&gt;Just bumped into another person who (quite reasonably) didn’t know that ES6 &lt;code&gt;class&lt;/code&gt;es are just syntactic sugar for prototypes. I like classes… but they’re more confusing than not, I think.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 16 May 2016 14:31:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-05-16:2016/2016-05-16-1431.html</guid><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-25-0709.html</link><description>&lt;p&gt;I &lt;em&gt;hate&lt;/em&gt; npm’s non-deterministic installs. Reproducible builds are essential, not optional.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 25 Apr 2016 07:09:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-25:2016/2016-04-25-0709.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-23-1006.html</link><description>&lt;p&gt;I’ve been working for a few weeks now on what has ended up being a much larger feature than I expected. &lt;a href="https://github.com/AlDanial/cloc/"&gt;CLOC&lt;/a&gt; tells me it’s a +1,320-lines-of-code change. But of those, 951 are &lt;em&gt;tests&lt;/em&gt;. As it should be when writing JavaScript.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 23 Apr 2016 10:06:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-23:2016/2016-04-23-1006.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-21-2003.html</link><description>&lt;p&gt;Just finished a massive cleanup of about 4000 lines of an AngularJS codebase. It’s not &lt;em&gt;amazing&lt;/em&gt;, but it’s a heck of a lot easier to deal with now.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 21 Apr 2016 20:03:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-21:2016/2016-04-21-2003.html</guid><category>software development</category><category>angularjs</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-19-1744.html</link><description>&lt;p&gt;I still love EmberJS—but if I have one complaint, it’s that it’s &lt;em&gt;slightly&lt;/em&gt; too heavy on convention-based magic. I want it to be a little more explicit, so that I can have a little more insight into what it’s going. Yes, even if that means a little more boilerplate. Explicit is better than implicit.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 19 Apr 2016 17:44:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-19:2016/2016-04-19-1744.html</guid><category>javascript</category><category>emberjs</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-14-1454.html</link><description>&lt;p&gt;Things I want basically &lt;em&gt;all the time&lt;/em&gt; when writing JavaScript:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strong types&lt;/li&gt;
&lt;li&gt;enums with values (tagged unions)&lt;/li&gt;
&lt;li&gt;pattern-matching&lt;/li&gt;
&lt;li&gt;immutability (more easily than with &lt;code&gt;Object.freeze&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;actual constants (not just fixed bindings like &lt;code&gt;const&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically: an ML, I guess.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 14 Apr 2016 14:54:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-14:2016/2016-04-14-1454.html</guid><category>javascript</category><category>programming languages</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-14-1100.html</link><description>&lt;p&gt;After looking at &lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt; a little, and discovering it doesn’t have &lt;a href="https://www.haskell.org"&gt;Haskell&lt;/a&gt;-style &lt;a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101"&gt;typeclasses&lt;/a&gt; (&lt;em&gt;a la&lt;/em&gt; &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;’s &lt;a href="https://doc.rust-lang.org/book/traits.html"&gt;traits&lt;/a&gt;), I was a bit disappointed. Then I discovered &lt;a href="http://www.purescript.org"&gt;PureScript&lt;/a&gt;, which &lt;em&gt;does&lt;/em&gt;. Intrigued all over again.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 14 Apr 2016 11:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-14:2016/2016-04-14-1100.html</guid><category>programming languages</category><category>javascript</category><category>purescript</category><category>elm</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-11-0846.html</link><description>&lt;p&gt;Betting I’m not the only one who thinks it a little weird that the &lt;code&gt;Event.target&lt;/code&gt; in the DOM APIs is the &lt;em&gt;source&lt;/em&gt; of the event.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 11 Apr 2016 08:46:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-11:2016/2016-04-11-0846.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-09-1019.html</link><description>&lt;p&gt;It is utterly infuriating how many parts of the DOM API are “array-like” but don’t have the basic &lt;code&gt;Array&lt;/code&gt; API actually attached. Want to iterate over a &lt;code&gt;HTMLCollection&lt;/code&gt;? You get to use a &lt;code&gt;for&lt;/code&gt; loop with an index! Lucky you! 😐&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 09 Apr 2016 10:19:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-09:2016/2016-04-09-1019.html</guid><category>javascript</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-07-0830.html</link><description>&lt;p&gt;The more time I spend with languages with pattern matching and expressive type systems, the more I feel frustrated by things I just can’t express in JavaScript. If I could write Ember in something &lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;… I think I’d be &lt;em&gt;giddy&lt;/em&gt;.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 07 Apr 2016 08:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-07:2016/2016-04-07-0830.html</guid><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-04-06-1228.html</link><description>&lt;p&gt;&lt;em&gt;Why isn’t this updating?&lt;/em&gt; :looks around for five minutes: Oh. It’s because I’m just serving an old version, and don’t have it rebuilding as I make changes.&lt;/p&gt;
&lt;p&gt;Yeah…&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 06 Apr 2016 12:28:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-04-06:2016/2016-04-06-1228.html</guid><category>javascript</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-03-14-0849.html</link><description>&lt;p&gt;Apparently, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger"&gt;&lt;code&gt;debugger;&lt;/code&gt;&lt;/a&gt; is a thing. My life would have been &lt;em&gt;so&lt;/em&gt; much easier if I had known about this sooner than ten minutes ago.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 14 Mar 2016 08:49:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-14:2016/2016-03-14-0849.html</guid><category>javascript</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-03-09-1236.html</link><description>&lt;p&gt;Pro tip for tracking down oddities with &lt;a href="http://emberjs.com"&gt;Ember.js&lt;/a&gt; during testing: &lt;code&gt;ember test --serve --filter '&amp;lt;some pattern&amp;gt;'&lt;/code&gt; is &lt;em&gt;great&lt;/em&gt;. E.g. &lt;code&gt;ember t -s --filter 'Unit'&lt;/code&gt; for just unit tests.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 09 Mar 2016 12:36:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-09:2016/2016-03-09-1236.html</guid><category>software development</category><category>javascript</category><category>emberjs</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-03-06-1221.html</link><description>&lt;p&gt;Seriously. All I want to do is transpile ES6 to ES5 and make it runnable in browser. And I need Browserify or Webpack for this? &lt;em&gt;sigh&lt;/em&gt;&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Mar 2016 12:21:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-06:2016/2016-03-06-1221.html</guid><category>software development</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-03-06-1115.html</link><description>&lt;p&gt;Trying to do a little tweaking with the lightweight scripts I use on this site. Trying to automate things with Babel, browser imports, etc.&lt;/p&gt;
&lt;p&gt;This is still far, far worse than it should be in 2016. Here’s hoping it’s (substantially!) better a year from now.&amp;quot;&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Mar 2016 11:15:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-06:2016/2016-03-06-1115.html</guid><category>javascript</category><category>software development</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-03-04-0851.html</link><description>&lt;p&gt;I ran into a &lt;a href="https://medium.com/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf#.syiwijz9h"&gt;Medium post&lt;/a&gt; arguing against ES6’s &lt;code&gt;class&lt;/code&gt; implementation, and got linked to &lt;a href="http://martinfowler.com/bliki/CallSuper.html"&gt;this argument&lt;/a&gt; against &lt;code&gt;super()&lt;/code&gt;. &lt;em&gt;Strongly concur.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Inheritance is fragile. Useful when appropriate, but fragile. Prefer composition.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 04 Mar 2016 08:51:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-04:2016/2016-03-04-0851.html</guid><category>software development</category><category>javascript</category></item><item><title>The Future of JavaScript</title><link>http://www.chriskrycho.com/2016/the-future-of-javascript.html</link><description>&lt;p&gt;I gave a short tech talk at my new employer &lt;a href="http://www.olo.com"&gt;Olo&lt;/a&gt; today, covering a number of the changes current and forthcoming in ECMAScript 2015 and later. Alas, I ran out of time in preparation and didn’t get to cover everything I wanted—I would have liked very much to cover modules, and to cover fat-arrow-functions in more depth than I did. I’ll look forward to hopefully giving further tech talks at Olo in the future, and perhaps giving this one, expanded and finished out a bit, elsewhere. (If you’d like me to give a talk, including this one, just let me know!) In the meantime, you can take a look at the &lt;a href="//www.chriskrycho.com/talks/es-future-olo"&gt;slides&lt;/a&gt;, which I think will be helpful and interesting!&lt;/p&gt;
&lt;p&gt;And yes, there &lt;em&gt;were&lt;/em&gt; a lot of really delightful &lt;em&gt;Doctor Who&lt;/em&gt; references in this talk. Because &lt;em&gt;of course&lt;/em&gt; there were!&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 02 Mar 2016 12:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-02:2016/the-future-of-javascript.html</guid><category>talks</category><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-02-25-0758.html</link><description>&lt;p&gt;I have an irrational-but-ridiculously-strong desire to build an Atom package that is a tiny JavaScript wrapper around a Rust implementation. Just because.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 25 Feb 2016 07:58:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-25:2016/2016-02-25-0758.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>javascript</category></item><item><title></title><link>http://www.chriskrycho.com/2016/2016-02-20-0823.html</link><description>&lt;p&gt;Of course, there’s another challenge with &lt;a href="http://www.chriskrycho.com/2016/2016-02-20-0814.html"&gt;picking back up&lt;/a&gt;: I’ve gotten spoiled by having &lt;a href="https://babeljs.io/docs/learn-es2015/"&gt;ES2015&lt;/a&gt; available and want to add it to this Angular project.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 20 Feb 2016 08:23:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-20:2016/2016-02-20-0823.html</guid><category>software development</category><category>javascript</category></item><item><title>HTML5 Location, &lt;base&gt;, and SVG</title><link>http://www.chriskrycho.com/2015/html5-location-base-and-svg.html</link><description>&lt;p&gt;For quite some time, I have been frustrated by a bug in HolyBible.com: Firefox would not render SVGs using the &lt;code&gt;&amp;lt;use xlink:xhref=&amp;quot;#some-SVG-ID&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;&lt;/code&gt; pattern. Today, I set aside my ongoing work on new user-facing functionality and dedicated what working time I had to hunting down the cause of this and fixing it at last.&lt;/p&gt;
&lt;p&gt;I was surprised to find the culprit: the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag. If you don’t know what the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag is, you’re not alone. It is &lt;em&gt;not&lt;/em&gt; used all that much in general, and I had never actually seen it on a site before starting on this project last year.&lt;/p&gt;
&lt;p&gt;So what went wrong? How do these two things play together?&lt;/p&gt;
&lt;p&gt;I am using (and reusing) SVG items throughout the HolyBible.com interface, taking advantage of the ability to define symbols and reference them with the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, like so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;svg version=&amp;quot;1.1&amp;quot; xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; xmlns:xlink=&amp;quot;http://www.w3.org/1999/xlink&amp;quot; xmlns:ev=&amp;quot;http://www.w3.org/2001/xml-events&amp;quot; style=&amp;quot;display: none&amp;quot;&amp;gt;
  &amp;lt;symbol id=&amp;quot;logo-shape&amp;quot; viewBox=&amp;quot;0 0 256 256&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Logo&amp;lt;/title&amp;gt;
    &amp;lt;desc&amp;gt;The HolyBible.com logo: sunrise breaking over an open book (the Bible).&amp;lt;/desc&amp;gt;
    &amp;lt;path id=&amp;quot;logo-light&amp;quot; d=&amp;quot;M172.1 116.3l5.1-4.1-12.5-.5 32-26.3-41.4 18.4 11-20.1L148 96l12.2-37.5L138.8 91l.1-36.2-10.3 34.4L114 36.1l4.3 54.9-22.2-34.9 13 39.9-18.3-12.4 11 20.1-42.5-19.2 32.8 26.9-10.4.8 4.4 3.9c13.1-1.6 27.4-2.7 42.4-2.7 15.4 0 30.1 1.2 43.6 2.9z&amp;quot;/&amp;gt;
    &amp;lt;path id=&amp;quot;logo-book&amp;quot; d=&amp;quot;M199.9 219.9c-47.4-9.8-96.4-9.8-143.8 0-6-28.9-12-57.7-17.9-86.6 59.3-12.3 120.4-12.3 179.7 0-6 28.9-12 57.8-18 86.6z&amp;quot;/&amp;gt;
  &amp;lt;/symbol&amp;gt;
&amp;lt;/svg&amp;gt;

&amp;lt;!-- somewhere else on the page --&amp;gt;
&amp;lt;svg&amp;gt;
  &amp;lt;use xlink:href=&amp;quot;#logo-shape&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Throughout all my early prototyping, this worked perfectly across all modern browsers. (For more, see &lt;a href="https://css-tricks.com/svg-sprites-use-better-icon-fonts/"&gt;CSS Tricks&lt;/a&gt;.) Now, when I started moving from the prototype phase into actually building the application in Angular last fall, I learned that you have to set the base URL for the application using the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag to use the HTML5 Location API with Angular 1.x. If you want URL-based, rather than &lt;code&gt;#&lt;/code&gt;-based navigation in an Angular app, you need this. Following the recommendation of whatever documentation and tutorials I found, I set it so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;base href=&amp;quot;/&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this was the recommendation I saw in every bit of documentation and every tutorial, so I assumed it would have no problems. As it turns it, that’s not the case. (This is a &lt;a href="http://www.chriskrycho.com/2015/how-to-build-a-single-page-app-api-right.html"&gt;recurring theme&lt;/a&gt; in my experience with Angular.) In Chrome, Safari, and IE9+, this works exactly as expected. In Firefox, however, it does &lt;em&gt;not&lt;/em&gt;. The use of the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag changes the behavior of &lt;code&gt;#&lt;/code&gt;-based URLs on a page. Specifically, it makes it so that if you’re at a URL that &lt;em&gt;isn’t&lt;/em&gt; the base route, anchor links don’t behave as expected. In order to make the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag as expected, we would have to use the same URL as the base tag. Among other things, this would require making sure that any place we used the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, we would have to set that—not exactly a good idea, given that it would entail an awful lot of changes if the base URL were ever changed.&lt;/p&gt;
&lt;p&gt;What if, instead, we did this?&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;script&amp;gt;document.write(&amp;#39;&amp;lt;base href=&amp;quot;&amp;#39; + document.location.origin + &amp;#39;&amp;quot; /&amp;gt;&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, when the page renders, it writes the document location based on the &lt;em&gt;current&lt;/em&gt; location. The URL history still behaves as expected with Angular, but the relative URLs for IDs behave as expected in Firefox again, while not breaking the behavior in any other browsers.&lt;/p&gt;
&lt;p&gt;But… then you’ll navigate to another page, and Firefox will be back to not working.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/angular/angular.js/issues/8934#issuecomment-56568466"&gt;solution&lt;/a&gt;, it turns out, only came into being after I’d done the initial implementation, and I have no idea how much later it found its way into the Angular docs. However, even though it now &lt;em&gt;exists&lt;/em&gt; in the docs, it’s by no means obvious why you should do it this way, and certainly no mention of SVG! This might not seem odd to you… but it should, given that the only reason that Angular introduced this API change was to account for &lt;em&gt;exactly this issue&lt;/em&gt;.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As the Angular docs note, leaving out the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag means all your URLs have to be absolute if you want to use HTML5 location and the &lt;code&gt;$locationProvider&lt;/code&gt;. If you want to use SVGs with &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; and Firefox, though, that’s what you have to do (and therefore that’s what I’m doing).&lt;/p&gt;
&lt;p&gt;Fun times, right?&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;The closest it gets is this reference:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Links that only contain a hash fragment (e.g. &lt;code&gt;&amp;lt;a href=&amp;quot;#target&amp;quot;&amp;gt;&lt;/code&gt;) will only change &lt;code&gt;$location.hash()&lt;/code&gt; and not modify the url otherwise. This is useful for scrolling to anchors on the same page without needing to know on which page the user currently is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even this, however, only &lt;em&gt;hints&lt;/em&gt; at the root of the SVG issue.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 20 Jun 2015 10:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-06-20:2015/html5-location-base-and-svg.html</guid><category>software development</category><category>angularjs</category><category>javascript</category></item><item><title>How to Build a Single-Page App API Right</title><link>http://www.chriskrycho.com/2015/how-to-build-a-single-page-app-api-right.html</link><description>&lt;p&gt;When I was first working on HolyBible.com, I struggled for quite a while to wrap my head around the right way to structure its API—and in truth, I actually didn’t come up with what I would call the &lt;em&gt;right&lt;/em&gt; solution. I came up with a &lt;em&gt;working&lt;/em&gt; solution, and the site performs all right, most of the time. However, our goal as developers shouldn’t be “all right, most of the time.” It should be “really well, all the time.” A big part of what I did wrong came from the bad advice I found in reading up on the issue along the way. This is my shot at helping you, dear reader, avoid making the same mistake.&lt;/p&gt;
&lt;section id="the-challenge" class="level2"&gt;
&lt;h2&gt;The challenge&lt;/h2&gt;
&lt;p&gt;When building a client-side application, we need to get the data for each view so that we can render it. In the case of HolyBible.com, that means everything from actual Bible text to study Bible notes, about pages, etc. The question is &lt;em&gt;how&lt;/em&gt; to do this: we need to be able to load an actual page from our server, and we need a way to request data (rather than whole pages) from the server.&lt;/p&gt;
&lt;p&gt;(More experienced developers already know where this is going: that last sentence there has the key to this whole thing. I know. But the internet &lt;em&gt;doesn’t.&lt;/em&gt; I learned this the hard way.)&lt;/p&gt;
&lt;section id="the-mistake" class="level3"&gt;
&lt;h3&gt;The mistake&lt;/h3&gt;
&lt;p&gt;Here’s the mistake I made: I built the Bible data API as (essentially) a &lt;em&gt;single&lt;/em&gt; endpoint. When I went looking for advice on how to build this in Angular and Node/Express, every single tutorial or blog post I found outlined the same basic solution: routes for your data endpoints, and catch-all route that returns the basic frame page for everything else. So, for HolyBible.com, that would come out with route matchers for e.g. &lt;code&gt;/data/gen.1.1&lt;/code&gt;, and for any other specific routes needed (for other views, static resources, etc.), with a default behavior of just dropping a static, basically empty template at the catchall &lt;code&gt;*&lt;/code&gt; route. Then, once the application has loaded, it can inspect the URL and load the relevant data.&lt;/p&gt;
&lt;p&gt;This works. It’s exactly what I did on HolyBible.com, in fact. But it’s &lt;em&gt;slow&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: the time until the initial page load is actually relatively quick (though I plan to improve it substantially over the next couple months). The real problem is that the initial page load &lt;em&gt;doesn’t include any content&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;hate&lt;/em&gt; this. That’s why people are on the site: not to see my neat skills with JavaScript, just to read the Bible. And they have to wait, because once the page &lt;em&gt;does&lt;/em&gt; load, Angular has to spin up the full application, see what content &lt;em&gt;should&lt;/em&gt; have been loaded, and request it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-solution" class="level3"&gt;
&lt;h3&gt;The solution&lt;/h3&gt;
&lt;p&gt;Don’t write &lt;em&gt;one&lt;/em&gt; API. Write &lt;em&gt;two&lt;/em&gt;. They should be structured nearly identically, but one of them will be a &lt;em&gt;page&lt;/em&gt; API endpoint, and one will be a &lt;em&gt;data&lt;/em&gt; API endpoint. In the context of HolyBible.com, here’s how that would play out.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; One endpoint would be based purely on the standard URL, something like &lt;code&gt;holybible.com/jhn.3.16&lt;/code&gt;. The other would be to retrieve a set of &lt;em&gt;data&lt;/em&gt; associated with a given address, like &lt;code&gt;holybible.com/data/jhn.3.16&lt;/code&gt;. This is only a little different from the approach suggested above, but that small difference matters—in fact, it matters a &lt;em&gt;lot&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Instead of having the &lt;code&gt;/jhn.3.16&lt;/code&gt; route get handled by a catchall &lt;code&gt;*&lt;/code&gt; route on the back end, it gets its own API endpoint, which looks for URLS of this shape and hands back a full page. That API endpoint is responsible to actually render the content of the page appropriately—in this case, with something like the whole chapter of John 3.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;em&gt;That&lt;/em&gt; gets handed back to the browser, so the very first thing the user sees is not a blank page while the JavaScript framework spins up and requests data, but rather &lt;em&gt;the Bible text they asked for in the first place&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Meanwhile, the JavaScript framework &lt;em&gt;can&lt;/em&gt; spin up, and load any required session data, etc. and start managing the UI like normal. Once we get to this point, the framework can go ahead and request a data payload from the &lt;code&gt;/data/&amp;lt;reference&amp;gt;&lt;/code&gt; endpoint. So, for example, if there is a navigation control on the page (as on HolyBible.com and indeed most sites), clicking to navigate to Job 14 could, instead of requesting &lt;code&gt;/job.14.4&lt;/code&gt;, fetch the data from the other endpoint by running an AJAX request to &lt;code&gt;/data/job.14.4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The backend thus supplies &lt;em&gt;both&lt;/em&gt; a &lt;code&gt;/&amp;lt;resource&amp;gt;&lt;/code&gt; and a &lt;code&gt;/data/&amp;lt;resource&amp;gt;&lt;/code&gt; route. This might seem redundant, but we’ve just seen why it isn’t, Moreover, if you have any logic that needs to be in place—in our example here, a Bible reference parser, for example, to decide what content should be supplied—you can easily reuse it between the two routes. The differences is simply in the form of the data returned: is it a fully-rendered template, or just the data?&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="so-what" class="level2"&gt;
&lt;h2&gt;So what?&lt;/h2&gt;
&lt;p&gt;This approach has two big advantages over the catch-all approach that was frequently recommended in e.g. Angular SPA tutorials I read.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s &lt;em&gt;progressive enhancement&lt;/em&gt;. If the JavaScript fails, or the user has it disabled, or it fails to load because it’s loaded asynchronously, the user still gets the page they asked for. Moreover, as long as the page content is build carefully (links built appropriately for other content, and so on), the entire application could continue to work even if the JavaScript &lt;em&gt;never&lt;/em&gt; becomes available.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s &lt;em&gt;performant&lt;/em&gt;. Loading the content this way will be &lt;em&gt;much&lt;/em&gt; faster than the standard approach recommended for single-page apps. As noted above, it gets the content to the user immediately, then lets the JavaScript UI bits come into play. Since future page loads can take advantage of both caching and smaller data payloads, the whole thing can actually be faster than either a pure client-side &lt;em&gt;or&lt;/em&gt; a pure server-side approach. That is, once the client-side application is running, it can just update its views with data delivered via AJAX, rather than reloading the whole page. But &lt;em&gt;before&lt;/em&gt; that, the user doesn’t have to wait to see something useful until the JavaScript framework spins up.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It’s not often an approach gives you progressive enhancement and actually increases the performance of an application, but this one does. Better yet, you can apply this in just about any framework: it’s equally applicable to AngularJS with ExpressJS, Backbone with Rails, Ember with Django, Aurelia with Phoenix, or any other combination you come up with.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note: this is &lt;em&gt;not&lt;/em&gt; the actual API structure of HolyBible.com, or even particularly close to it. Remember, I learned everything I’m writing here by doing it &lt;em&gt;wrong&lt;/em&gt;.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Or possibly a section which constitutes a semantic block of data. I have some thoughts on chunking Bible data semantically rather than by chapter and verse for this kind of thing. That’s another post for another day, though.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 09 Jun 2015 22:16:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-06-09:2015/how-to-build-a-single-page-app-api-right.html</guid><category>software development</category><category>javascript</category></item><item><title>Lessons Learned</title><link>http://www.chriskrycho.com/2015/lessons-learned.html</link><description>&lt;p&gt;Since mid July 2014, I have been working on a complete redesign and re-build of &lt;a href="//holybible.com"&gt;HolyBible.com&lt;/a&gt;. The good folks at &lt;a href="//prts.edu"&gt;Puritan Reformed Theological Seminary&lt;/a&gt; who own the site wanted to replace its previous content with a Bible reading tool. While there’s still a lot to wrap up, the project is &lt;em&gt;nearing&lt;/em&gt; its conclusion, and I thought I’d note a few things I’ve learned (in some cases, learned &lt;em&gt;again&lt;/em&gt;) along the way. I want to say up front, lest these be taken the wrong way: I’m extremely proud of the work I’ve done, and the application I’ve delivered &lt;em&gt;does&lt;/em&gt; work to the specifications I was hired to meet. More than that, it does it well. But, of course, it could do it &lt;em&gt;better&lt;/em&gt;. The following thoughts are therefore not, “How I failed” but rather “How I will do this &lt;em&gt;even better&lt;/em&gt; next time around.”&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Single page apps are great, but not always the right choice.&lt;/em&gt; I made the decision, based on my expectations and understandings of what I would need, to develop the site as a single-page web application. This was a mistake. Not the worst mistake ever: it has its upsides, including performance &lt;em&gt;once the app spins up&lt;/em&gt;, but for the kind of content I have here, I would take a different tack today. Better in this case to deliver static content and &lt;em&gt;update&lt;/em&gt; it dynamically as appropriate than to try to load all the content dynamically every time.&lt;/p&gt;
&lt;p&gt;At a technical level, that would probably mean supplementing standard HTML with &lt;a href="//backbonejs.org"&gt;Backbone&lt;/a&gt; instead of developing it as a single-page app in &lt;a href="//angularjs.org"&gt;Angular&lt;/a&gt;. For the backend, while I did it in Node.js and that would work fine, I’d probably do a straight Django app (especially with a few of the goals I learned about &lt;em&gt;after&lt;/em&gt; the project was well along in development).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Progressive enhancement or graceful degradation are hard in web applications, but they still matter.&lt;/em&gt; In the past, I’ve always taken a hard line on making sure things either degrade gracefully or are simply enhanced by JavaScript content. In the architecture decisions I made for this app, I failed to take that into account (largely because I thought it would just &lt;em&gt;need&lt;/em&gt; to work as a web app, but see above). I regret that enormously at this point; it would be much better in this particular case to have content available even if the additional functionality doesn’t work. Even if you &lt;em&gt;are&lt;/em&gt; doing something where you are building an &lt;em&gt;app&lt;/em&gt;, finding ways to make it work on poor connections, older browsers, etc. matters. I’m still thinking a &lt;em&gt;lot&lt;/em&gt; about the best way to do this in the future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;More popular doesn’t mean better.&lt;/em&gt; Angular has a ton of traction and uptake, and that was deceptive early on. I won’t so easily be fooled in the future. Angular is so very popular in part because Google can put serious money behind its development—and its marketing. But it’s &lt;em&gt;not&lt;/em&gt; the best for many applications; if you’re not in the business of developing your own custom framework, it’s not even &lt;em&gt;close&lt;/em&gt; to the best. Use Ember or Knockout or any number of other full-stack frameworks rather than a meta-framework.&lt;/p&gt;
&lt;p&gt;How to avoid making that mistake? Well, for my part since then, I’ve learned to look not just as the &lt;em&gt;quantity&lt;/em&gt; of material in a given community, but its &lt;em&gt;quality&lt;/em&gt;. For example, &lt;a href="//emberjs.com"&gt;Ember&lt;/a&gt; has &lt;em&gt;incredible&lt;/em&gt; documentation (far better than Angular’s), and they also have a much clearer vision and a more dependable approach to development (strict semantic versioning, etc.). Had I taken the time to read &lt;em&gt;both&lt;/em&gt; sets of docs more carefully and think through the consequences of their designs more thoroughly, I could have recognized this before starting. Next time, I will do just that.&lt;/p&gt;
&lt;p&gt;I will also look at the way the community behaves. The Ember community is &lt;em&gt;far&lt;/em&gt; friendlier for newcomers from what I’ve seen than the Angular community—no slam meant on the Angular crowd, but the Ember folks are just doing that really well. That matters, too. (I can’t speak for other communities, of course; these are just the groups I’ve watched the most.)&lt;/p&gt;
&lt;p&gt;All in all, Ember would have been the better fit between these two (even though, as noted above, it also wouldn’t have been the &lt;em&gt;best&lt;/em&gt; fit).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests really are the best.&lt;/em&gt; I did a vast majority of this project with unit tests—the first time I’ve ever been able to do that for a whole project. In other projects, I’ve been able to do it for parts, but never this much. It saved my bacon a &lt;em&gt;lot&lt;/em&gt;. Where I got in a hurry and felt like I didn’t have time to write the tests, I (inevitably and predictably!) ended up spending a lot of time chasing down hard-to-isolate bugs—time I could have avoided by writing well-tested (and therefore better-factored) code in the first place. Lesson learned &lt;em&gt;very&lt;/em&gt; thoroughly. Server- and client-side unit tests are &lt;em&gt;really&lt;/em&gt; good. They’re also sometimes &lt;em&gt;hard&lt;/em&gt;; getting mocks set up correctly for dealing with databases, etc. can take a while. That difficulty pays for itself, though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests &lt;strong&gt;really&lt;/strong&gt; don’t replace API documentation.&lt;/em&gt; I have seen people advocate test-driven-development as a way of obviating the need to do major documentation of an API. This is, in a word, ridiculous. Having to read unit tests if you want to remember how you structured an API call is a pain in the neck. Don’t believe it. Design your API and document it, &lt;em&gt;then&lt;/em&gt; do test-driven development against that contract.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Sometimes ‘good enough’ is enough.&lt;/em&gt; There is always more to be done, and inevitably you can see a thousand things that could be improved. But ‘good’ shipping code is far more valuable than ‘perfect’ code that never ships. You should never ship &lt;em&gt;bad&lt;/em&gt; code, but sometimes you do have to recognize ‘good enough’ and push it out the door.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Full-stack development is fun, but it’s also really hard.&lt;/em&gt; I wrote every scrap of code in HolyBible.com proper (though of course it relies on a lot of third-party code). It was very, very difficult to manage that all by myself; it’s a lot to hold in one’s head. (One of the reasons I chose Node was because keeping my implementation and testing all in one language helped reduce that load somewhat.) Would I do it again? Sure. But very much chastened about the difficulties involved. It has been enormously rewarding, and I &lt;em&gt;like&lt;/em&gt; being a full-stack developer. But it’s a lot of work, and now I know more clearly just how much.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I could say a great deal more about the technical side of things especially, but my biggest takeaway here is that a lot of the hardest and most important work in developing software has nothing to do with the code itself. Architecture and approach shape &lt;em&gt;far&lt;/em&gt; more than the implementation details (even if those details still matter an awful lot). And popularity is not at all the same as either &lt;em&gt;quality&lt;/em&gt; or (especially) &lt;em&gt;suitability for a given task&lt;/em&gt;. In the future, I will be better equipped for the necessary kinds of evaluation, and will hopefully make still better decisions accordingly.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 12 Apr 2015 13:49:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-12:2015/lessons-learned.html</guid><category>software development</category><category>javascript</category><category>angularjs</category></item><item><title>Unsurprisingly, In Flux</title><link>http://www.chriskrycho.com/2015/unsurprisingly-in-flux.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;This started as a &lt;a href="https://alpha.app.net/chriskrycho/post/57102562"&gt;series of posts&lt;/a&gt; on App.net. I &lt;a href="http://www.chriskrycho.com/2014/a-few-theses-on-blogging.html"&gt;resolved&lt;/a&gt; a while ago that if I was tempted to do that, I should just write a blog post instead. I failed at that resolution, but at a friend’s &lt;a href="https://alpha.app.net/jws/post/57108281"&gt;suggestion&lt;/a&gt;, am adapting it into a blog post anyway. You can see the posts that prompted it &lt;a href="https://alpha.app.net/keita/post/57096585"&gt;here&lt;/a&gt; and &lt;a href="https://alpha.app.net/jws/post/57096838"&gt;here&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The state of JavaScript frameworks today is a scale, really, from not-at-all-monolithic to totally-monolithic, in roughly this order: Backbone – React &amp;amp; Angular – Ember – Meteor.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Backbone and related library Underscore are really collections of common JS tools and patterns you can use to write apps, but they’re not &lt;em&gt;frameworks&lt;/em&gt;, per se. You’ll write all your own boilerplate there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React and Angular supply much &lt;em&gt;more&lt;/em&gt; of the functionality, but Angular is a “meta-framework” that aims to do &lt;em&gt;some&lt;/em&gt; boilerplate but let you construct your own custom app framework.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is very powerful, but it’s kind of like Git: wires are exposed; you have to understand a &lt;em&gt;lot&lt;/em&gt; about the internals to get it to do what you want. Its routing functionality is pretty limited out of the box, too—so much so that there’s a near-standard third-party router.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React, as I understand it, supplies a paradigm and associated tools oriented primarily at view state management, though with capabilities via extensions for routing, etc. These tools are &lt;em&gt;extremely&lt;/em&gt; powerful for performance in particular. It’s not a full framework, and the docs expressly note that you can &lt;em&gt;just&lt;/em&gt; use React for the view layer with other tools if you want.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, Angular and React do &lt;em&gt;different&lt;/em&gt; things from each other, but both do substantially more than Backbone.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember is a full framework, strongly emphasizing shared conventions (with a lot of common developers from Rails). It’s perhaps less adaptable than React or Angular, but is much more full-featured; you have very little boilerplate to do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Meteor is like Ember, but does server-side Node as well as client-side stuff, with the goal being to minimize code duplication, sharing assets as much as possible.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Of all of those, Ember has easily (easily!) the best-explained roadmap, most articulate leadership, and best development path. They are also aggressively adopting the best features of other frameworks wherever it makes sense.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is currently in flux, as Google has announced Angular 2.0 will be basically a completely different framework; there will be &lt;em&gt;no&lt;/em&gt; direct migration path for Angular 1.x apps to Angular 2.0+. Total rewrite required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember uses a steady 6-week release schedule with very careful regression testing and semantic versioning, with clear deprecation notices and upgrade paths, and is therefore both rapidly iterating &lt;em&gt;and&lt;/em&gt; relatively stable for use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you just need a set of tools for enhance functionality on otherwise relatively static pages, Backbone+Underscore is a great combo. If you already have a bunch of things in place but want a dedicated view layer, React is good.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re writing a new, full-on web &lt;em&gt;application&lt;/em&gt; (SPA, or organized in whatever other way), I think Ember is the very clear winner at this point. I have good confidence in their leadership and they’re firing on all cylinders.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regarding Angular, &lt;a href="https://alpha.app.net/mikehoss"&gt;@mikehoss&lt;/a&gt; &lt;a href="https://alpha.app.net/mikehoss/post/57105656"&gt;posted&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For the record they are doing that to make it more mobile-friendly. The Ang1 has abysmal performance on mobile. Besides a time machine, this maybe the best option. And Miško is a bit of a jerk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I can’t speak to his comment about Miško (Miško Hevery, one of the leads on AngularJS), but I agree about Angular itself: the rewrite needs to happen. Angular 1.x is a mess—as are its docs. It’s just not a good time to be using 1.x for any new projects.&lt;/p&gt;
&lt;p&gt;I’ll add to these points that I’ve used Angular for the last 9 months on HolyBible.com development. As I noted: the documentation is pretty rough, and in a lot of cases you really do have to understand what the framework is doing and how before you can get it to do the things you want. This is, in one sense, exactly the &lt;em&gt;opposite&lt;/em&gt; of what I’m looking for in a framework—but it makes sense given Angular’s goal of being a meta-framework.&lt;/p&gt;
&lt;p&gt;Rather like Git, though, which was originally going to be infrastructure for version control systems which would have their own interface, but eventually just had a “good enough” interface that we’re all now stuck with, Angular is being used &lt;em&gt;as&lt;/em&gt; a framework, not just as a &lt;em&gt;meta-framework&lt;/em&gt;, and it’s unsurprisingly not great for that.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class="editorial"&gt;Take this for what it’s worth: not the final word (by a long stretch) on JavaScript frameworks, but rather the perspective of one guy who notably &lt;em&gt;hasn’t used all of the frameworks&lt;/em&gt;, but has spent some time looking at them. Moreover, I haven’t particularly edited this; it’s more a summary in the kind of short-form posts that I originally created than a detailed analysis. The only things I’ve done are expand some of the notes on Angular and React, and add the footnote on React.&lt;/i&gt;&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I &lt;em&gt;really&lt;/em&gt; don’t know a ton about React, but I do think a lot of what I do know about it is cool from a programming perspective. From a designer perspective, however, it’s a bit of a pain: React’s “JSX” domain-specific language is &lt;em&gt;much&lt;/em&gt; less friendly to developers than standard HTML, and therefore than either Ember or Angular, both of which implement their templating via HTML templating languages. There’s a substantil tradeoff there: React’s model is interesting not only academically but in practice because of the performance results it produces. It’s worth note, though, that others have recognized this and are adopting it to varying degrees; notably, Ember is incorporating the idea of minimizing changes to the DOM by keeping track of state and updating only differences, rather than refreshing the whole tree, in the new rendering engine (HTMLBars) they’re rolling out over the past several and future several releases.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 08 Apr 2015 16:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-08:2015/unsurprisingly-in-flux.html</guid><category>software development</category><category>javascript</category><category>angularjs</category><category>emberjs</category><category>react</category></item></channel></rss>