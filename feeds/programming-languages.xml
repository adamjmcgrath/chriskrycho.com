<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Krycho</title><link>http://www.chriskrycho.com/</link><description></description><atom:link href="http://www.chriskrycho.com/feeds/programming-languages.xml" rel="self"></atom:link><lastBuildDate>Wed, 02 Mar 2016 12:30:00 -0500</lastBuildDate><item><title>The Future of JavaScript</title><link>http://www.chriskrycho.com/2016/the-future-of-javascript.html</link><description>&lt;p&gt;I gave a short tech talk at my new employer &lt;a href="http://www.olo.com"&gt;Olo&lt;/a&gt; today, covering a number of the changes current and forthcoming in ECMAScript 2015 and later. Alas, I ran out of time in preparation and didn’t get to cover everything I wanted—I would have liked very much to cover modules, and to cover fat-arrow-functions in more depth than I did. I’ll look forward to hopefully giving further tech talks at Olo in the future, and perhaps giving this one, expanded and finished out a bit, elsewhere. (If you’d like me to give a talk, including this one, just let me know!) In the meantime, you can take a look at the &lt;a href="//www.chriskrycho.com/talks/es-future-olo"&gt;slides&lt;/a&gt;, which I think will be helpful and interesting!&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 02 Mar 2016 12:30:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-03-02:2016/the-future-of-javascript.html</guid><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title>“I Don't Know When I'd Use That”</title><link>http://www.chriskrycho.com/2016/i-dont-know-when-id-use-that.html</link><description>&lt;p&gt;I was reading an interesting Stack Overflow &lt;a href="http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful"&gt;discussion&lt;/a&gt; of the value of &lt;a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala"&gt;higher-kinded types&lt;/a&gt; (hereafter &lt;abbr&gt;HKTs&lt;/abbr&gt;), and noted someone repeatedly commenting, “But when would you use this in a &lt;em&gt;real app&lt;/em&gt;?” To put it the way another &lt;a href="https://m4rw3r.github.io/rust-and-monad-trait/"&gt;blog post&lt;/a&gt; about &lt;abbr&gt;HKTs&lt;/abbr&gt; (in Rust), they are “a feature people do not really know what to do with.”&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: I’m sympathetic to that desire for concrete examples. I’m interested in these kinds of things not primarily for their intellectual value but for their pragmatic value (though I don’t think those two are as distinct as many people do). I’d &lt;em&gt;also&lt;/em&gt; love to see some more real-world examples in those discussions. All too often, the discussions of types in Haskell end up being quite abstract and academic—no surprise, given the language’s origin. But I’m also aware that quite often it’s difficult to see how a given kind of abstraction is useful without jumping into a language which has that abstraction available and &lt;em&gt;using&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;People often get turned off by Haskell (and other similarly high-abstraction languages like Scala) because of challenging terms like &lt;em&gt;monad&lt;/em&gt;, &lt;em&gt;applicative&lt;/em&gt;, &lt;em&gt;functor&lt;/em&gt;, and so on. And again: I get that. To grok Haskell, you need to wrap your head around a lot of &lt;em&gt;math&lt;/em&gt; ideas—mainly various properties of &lt;em&gt;sets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But I remember feeling the same way six years ago when I started playing with JavaScript and jQuery and every tutorial out there simply assumed existing familiarity and comfort with functions as arguments or return values. Coming from the world of Fortran and C, my head ached for weeks as I tried to make sense of what I was seeing. Even when I finally got it, &lt;em&gt;I didn’t like it&lt;/em&gt;. Over the last several years, though, I’ve become increasingly comfortable and even reliant on closures, composition of functions to transform data, and so on as I worked regularly in Python and JavaScript.&lt;/p&gt;
&lt;p&gt;That experience has taught me that my current inability to see the utility of a given abstraction means little about the abstraction. It’s primarily an indicator of my own inexperience.&lt;/p&gt;
&lt;p&gt;To the question of the utility &lt;abbr&gt;HKTs&lt;/abbr&gt; in general—in Haskell, Rust, or somewhere else—I don’t have the knowledge myself (yet) to supply a good answer. Heck, I can’t even &lt;em&gt;explain&lt;/em&gt; them very well. (&lt;a href="http://adriaanm.github.io/research/2010/10/06/new-in-scala-2.8-type-constructor-inference/"&gt;Other people can, though!&lt;/a&gt;) But I can say that reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt; showed me clearly that such things can be very useful. Even if I am not yet comfortable using that tool, I see how learning to use it would be profitable in the long-term. And like any good tool, even if you don’t need it every day… when you want it, you &lt;em&gt;really&lt;/em&gt; want it.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 17 Jan 2016 10:00:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-01-17:2016/i-dont-know-when-id-use-that.html</guid><category>software development</category><category>programming languages</category></item><item><title>Rust and Swift (xi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I’ve still been (slowly) working through the Swift book and comparing Swift and Rust; I have another draft started which I’ll hopefully finish this week. And I still find the comparison deeply profitable. The two languages continue to evolve in interesting ways, and the comparison is all the more interesting &lt;a href="https://github.com/apple/swift"&gt;now that Swift is open-source&lt;/a&gt; and its future &lt;a href="https://github.com/apple/swift-evolution"&gt;open for community input&lt;/a&gt; (just as &lt;a href="https://github.com/rust-lang/rfcs"&gt;Rust is&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Something I’ve been thinking about for several months, and which the &lt;a href="https://overcast.fm/+CdSzsTIY/1:16:42"&gt;brief discussion of Swift, Go, and Rust&lt;/a&gt; at the end of the latest &lt;a href="http://atp.fm/episodes/151"&gt;Accidental Tech Podcast&lt;/a&gt; brought back to my mind, is the question of what the next generation of systems-level programming language should be. And my answer is: there shouldn’t be &lt;em&gt;just one&lt;/em&gt;. The best possible thing for the space, in many ways, is for there to be a healthy diversity of options and lots of competition in the space. We don’t want to have &lt;em&gt;ten&lt;/em&gt; different systems programming languages to deal with, I think—but three or four or five would be &lt;em&gt;much&lt;/em&gt; preferable to having one or two (closely related) as we have in the decades of C and C++ dominance.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: both languages (and perhaps especially C) do many things exceptionally well. For all that they are (justly) maligned for some of their problems, the logevity of both C and C++ has a great deal to do with how well they fit the problem domain, and how much they’ve empowered developers to accomplish within that space (which is very, &lt;em&gt;very&lt;/em&gt; large).&lt;/p&gt;
&lt;p&gt;The problem, though, at least as I see it, is that the existence of only two really serious systems programming languages for the last several decades has led a lot of developers to think that C and C++‘s ways of solving problems are the &lt;em&gt;only&lt;/em&gt; way to solve problems. The languages we use shape the way we think about possible solutions, and when a given language doesn’t recognize entire classes of different approaches, that deeply limits developers’ ability to tackle certain issues. (See also the interesting CppCast &lt;a href="http://cppcast.com/2015/10/andrei-alexandrescu/"&gt;interview with D’s Andrei Alexandrescu&lt;/a&gt; in which he makes similar points.)&lt;/p&gt;
&lt;p&gt;The most obvious thing missing from both is the ability to do truly functional-style programming. C of course is also lacking classes and thus is much more difficult to use for any sort of object-oriented programming.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Neither has anything remotely like Rust’s traits or Swift’s extensions; C++ has only gotten lambdas recently.&lt;/p&gt;
&lt;p&gt;All of this comes out to mean that the set of &lt;em&gt;tools&lt;/em&gt; available to systems programmer has necessarily been missing any number of things available in languages outside that context. In some cases, this may be a necessary consequence of the kinds of programming being done: when you need totally deterministic memory and compiler behavior, dynamic typing and a non-trivial runtime are simply not options. But in many cases, they are simply a function of the history of the languages’ development and history. Being an ALGOL descendant, and especially a C descendant, means there are some fundamental choices about the language which will differ from those made in a language descended from ML.&lt;/p&gt;
&lt;p&gt;All of which is to say: C and C++ have been really useful tools in many ways, but having &lt;em&gt;only&lt;/em&gt; C and C++ available for serious systems programming work over the last decades has left many developers blind to or simply unaware of the real advantages other paradigms might offer them.&lt;/p&gt;
&lt;p&gt;So going forward, I don’t want there to be &lt;em&gt;a winner&lt;/em&gt; in the systems programming space. I’d rather see D, Rust, Swift, Go, and maybe even a few other contenders all stay strong—finding their own niches and continually pushing each other and learning from each other. That will give us a space in which different languages are free to try out different approaches to the same problems, without being tied to the specific constraints faced by other languages. Built-in greenthreading? Go! Hindley-Milner types, memory safety, and zero runtime? Rust! Something in beween, highly expressive and with different type systems and tradeoffs around memory management, etc.? Swift, or D!&lt;/p&gt;
&lt;p&gt;Having a robust, thriving set of competitors in the market will be good for the languages themselves. But it will also be good for developers. It will take off some of the blinders that come from a single language (or a pair of very closely related languages) dominating the ecosystem. It will make it likelier that people will be more familiar with different programming paradigms. And that can only be a good thing, as far as I’m concerned.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;[&lt;strong&gt;Previous:&lt;/strong&gt; Classes and structs (product types), and reference and value types.][10]&lt;/li&gt;
&lt;li&gt;[&lt;strong&gt;Next:&lt;/strong&gt; Properties: type and instance, stored and computed.][12]&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;It is of course entirely possible to do non-classical OOP; the point is that C entirely lacks &lt;em&gt;language-level&lt;/em&gt; facilities for OOP, inheritance, etc.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 10:00:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-01-10:2016/rust-and-swift-xi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming-languages</category></item><item><title>Rust and Swift (v)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-v.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. [(See all parts in the series.)][series]&lt;/i&gt;&lt;/p&gt;
&lt;section id="series-rust-and-swift.html" class="level2"&gt;
&lt;h2&gt;[series]: /rust-and-swift.html&lt;/h2&gt;
&lt;p&gt;I’ve been working on learning Swift over the past couple weeks, and had spent the month prior to that doing a deep first dive on Rust. This kind of approach, learning two languages basically at the same time, is entirely new to me, and for good reason. Programming languages are not trivial to learn, and to learn them meaningfully one must practice with them a great deal.&lt;/p&gt;
&lt;p&gt;I’m doing this largely of necessity. I’m hoping to build an application with a very capable, performant cross-platform core language (Rust), but planning to ship a native OS X app (first) when all is said and done. My desire to make the core libraries portable rules out Swift immediately. To be frank, so does the fact that it’s an Apple language: I am happy to use Apple’s tools on its platform, but I don’t want to shackle myself to their choices in the long run. Too, having good Rust experience is likely to be valuable in many other contexts.&lt;/p&gt;
&lt;p&gt;So I need to learn both.&lt;/p&gt;
&lt;p&gt;And, while I wouldn’t ordinarily recommend this course of action—indeed, unless you already have a fair bit of programming experience and already know several languages, I’d actively recommend against it—I’m finding it enormously profitable. The languages have been designed in roughly the same time frame, cite many of the same influences, and overlap substantially in terms of audience and goals. Yet they are, as this series has already highlighted, quite different languages in many ways.&lt;/p&gt;
&lt;p&gt;Learning them in parallel is helping me see the trade-offs each one has made, and force me to think about &lt;em&gt;why&lt;/em&gt; they differ in the ways they do. In particular, I think I have a much better idea what’s going on “under the covers” in each language and therefore know what to expect of them better. This, in turn, has dramatically deepened my grasp of the languages relative to the amount I’ve been looking at them, compared to previous language-learning efforts. (It also helps that I’ve already learned a number of languages, of course, and that I’ve been pushing my brain into the learning-programming-languages space via reading about Haskell, functional patterns in JavaScript, and so on this year.)&lt;/p&gt;
&lt;p&gt;I have a long way to go in both languages, of course. Reading on nights and weekends, and the little bit of playing I’ve been able to do with each of them, is no replacement for just sinking my teeth into a project and finding the pain points. Nonetheless, I’m really glad to be learning these two languages &lt;em&gt;together&lt;/em&gt;. If you’re up for a challenge, try it sometime! You’ll be surprised how much you learn.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;[&lt;strong&gt;Previous:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.][4]&lt;/li&gt;
&lt;li&gt;[&lt;strong&gt;Next:&lt;/strong&gt; Collection types and the difference between syntax and semantics.][6]&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 13:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-12:2015/rust-and-swift-v.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item></channel></rss>