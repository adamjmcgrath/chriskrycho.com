<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Krycho</title><link>http://www.chriskrycho.com/</link><description></description><atom:link href="http://www.chriskrycho.com/feeds/listicles.xml" rel="self"></atom:link><lastBuildDate>Thu, 10 Sep 2015 20:55:00 -0400</lastBuildDate><item><title>Rust and Swift (iv)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Both Swift and Rust directly address the issue of having to worry about memory allocation and safety. They do it in different ways, though: Swift by automatic reference counting, Rust by its concept of ownership. For a lot of day-to-day development, I can see the Swift approach being a win for the same reason a language like Python or Ruby is: having that all handled for you is &lt;em&gt;nice&lt;/em&gt;. Having the power Rust gives you comes at the price of increased cognitive load from having to reason about ownership.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To put it another way: all programming languages have to make trade offs. Although I like Rust’s better than Swift’s so far, I’ve no doubt I will find any number of things to appreciate about Swift over Rust. You can’t have everything.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This caught my attention in part because dealing with things like strings (or other pass-by-value types) in Swift is rather more straightforward than in Rust. The outcomes are much the same, but since &lt;em&gt;all&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s in Swift are passed by value (never by reference), you simply don’t have to think about modification—even safe modification!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust of course had the &lt;code&gt;Copy&lt;/code&gt; trait which lets you do this, but the point is that the “ergonomics” are slightly nicer in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Also, the string interpolation Swift does is &lt;em&gt;nice&lt;/em&gt;. That’s one thing I really wish Rust had. It’s Python-style string formatting macro is great, but being able to interpolate values (&lt;code&gt;&amp;quot;strings with \(variables)&amp;quot;&lt;/code&gt; or even &lt;code&gt;&amp;quot;embedded expressions like \(2 + 4)&amp;quot;&lt;/code&gt;) is very nice.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s approach to strings in general seems well-thought-through and gives appropriate levels of attention to the details which make handling complex or non-Western languages much more manageable. As a typography geek, I appreciate this a great deal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That said, since Swift’s strings &lt;em&gt;do&lt;/em&gt; handle all those edge cases for Unicode, you lose some standard string access patterns and lose much (maybe all?) insight into the internal structure of the string. That may be good, and may be bad, depending on the circumstance. Like I said: trade-offs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The way Swift handles Unicode strings is pretty nice. I particularly appreciate that it’s you deal with them as the standalone &lt;code&gt;String&lt;/code&gt; type as well as giving you direct access to the code points—and not just one Unicode code point set, but any of &lt;abbr&gt;UTF8&lt;/abbr&gt;, &lt;abbr&gt;UTF16&lt;/abbr&gt;, or &lt;abbr&gt;UTF32&lt;/abbr&gt; (Unicode scalars). Trust Apple to pay close attention to text.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust’s strings are &lt;em&gt;good&lt;/em&gt;, but not quite as sophisticated (presumably for simplicity around the memory mapping). All Rust &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;str&lt;/code&gt; instances are composed of &lt;abbr&gt;UTF32&lt;/abbr&gt; Unicode scalars, encoded as &lt;abbr&gt;UTF8&lt;/abbr&gt; sequences. It doesn’t have some of the convenience methods Swift does for getting any of the other representations. That said, I expect this should show up rarely if at all in my ordinary usage. Importantly, the fundamental storage is the same: both use scalars.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was the first section where it didn’t feel like Rust was just a clear overall “winner” over Swift. Some of the trade offs between the language designs are more apparent here, and I do appreciate e “ergonomics” of Swift in a number of these things.&lt;/p&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Sep 2015 20:55:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-10:2015/rust-and-swift-iv.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (iii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I just hit operators in the Swift book. First question: are operators special syntax, or are they sugar for &lt;code&gt;protocol&lt;/code&gt;s? (Every modern language I use or even have played with handles them as sugar for another language construct—Python, Ruby, Io, Elixir, and Rust, to name just a few ranging over a substantial variety of ages and styles.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Oh. I did the requisite digging, and operators are functions (which is okay) defined in the global namespace (&lt;em&gt;:sigh:&lt;/em&gt;). I say “okay” rather than good because the justification offered is that this is the only way to make the operators work as binary operators between existing instances of types. But that elides the fact that, if that’s the case, it is so because of other language design decisions. This seems like a perfect place to use a &lt;code&gt;protocol&lt;/code&gt;, but perhaps (unlike Rust’s &lt;code&gt;trait&lt;/code&gt;) they’re not sufficiently capable to handle this? That’s an open question; I have no idea about the answer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interestingly, Rust has several fewer operators than Swift, even apart from those mentioned in my &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;previous post&lt;/a&gt;. It drops the pre- and post-increment operators entirely (as does Python), since their results can always be accomplished in other ways with less potential for confusion. Swift keeps them, no doubt in part because most (Objective) C programs are deeply familiar with them and with idioms associated with them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I learned a few new things about Rust’s operators as well: the Boolean &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators and its bit wise &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operators differ not only in that the former are &lt;em&gt;short-circuit&lt;/em&gt; operators and the latter are not. Obviously you can also do things like bit-wise flag operations with the latter, but the reference emphasizes the short-circuiting behavior. This makes perfect sense, but it wasn’t something I’d ever considered explicitly before.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is no ternary operator in Rust, because of how it handles the relationship between expressions and statements. Swift keeps it. That’s an interesting reflection of differences in design: Rust dropped it because &lt;code&gt;if&lt;/code&gt; blocks are expressions, so it’s redundant, and they have had a goal of removing unnecessary features. (See the discussion on dropping the ternary operator—with an interesting aside from Brendan Eich on JavaScript—&lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;here&lt;/a&gt;). Note that this is not a criticism of Swift, just an observation, though I do really like Rust’s expression-driven approach.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; “nil coalescing operator”, on the other hand, I actively dislike. This seems like shorthand for the sake of shorthand, partly necessitated by the existing drive toward shorthand with optional types in Swift. Sometimes brevity can lead to decreased clarity. Eliding too much, or subsuming it into shorthand, makes the language harder to hold in your head and requires you to slow down more for parsing each line.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nothing surprising (or different) between the standard boolean operators in the two languages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I wonder how many times the word “concise” (or synonyms of it) appear in the Swift book? It’s increasingly clear to me reading that brevity is one of the primary design goals. Maybe it’s just me, but that actually seems a little weird. Brevity is good so far as it goes, but &lt;em&gt;legibility&lt;/em&gt; is much better.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 11:55:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-07:2015/rust-and-swift-iii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (ii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;At first blush, I find the extra syntax around optionals in Swift more confusing than helpful. I think this comes down to my preference for a more Python-like approach: “Explicit is better than implicit” and “There should be one– and preferably only one –obvious way to do it” both militate against the multiple different ways you can handle optional values in Swift. Optional types are created in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with the &lt;code&gt;?&lt;/code&gt; operator on a type definition, creating an explicitly wrapped type which must be checked in some way.&lt;/li&gt;
&lt;li&gt;with the &lt;code&gt;!&lt;/code&gt; operator on a type definition, creating an “implicitly unwrapped optional” by forcibly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After creating an optional, you can get at its contents by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;while let&lt;/code&gt; constructs to bind the optional value’s non-&lt;code&gt;nil&lt;/code&gt; value for a block&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;!&lt;/code&gt; operator on a variable name, explicitly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By contrast, in Rust you always have to explicitly unwrap the item, using the &lt;code&gt;unwrap&lt;/code&gt; method or pattern matching. There are no implicitly unwrapped types. Moreover, there is no special syntax around creating optional types in Rust: you just declare them with an &lt;code&gt;Option&lt;/code&gt; type or another type that &lt;code&gt;impl&lt;/code&gt;s the &lt;code&gt;Option&lt;/code&gt; behavior. The “shortcut” behavior around error handling, &lt;code&gt;try!&lt;/code&gt;, isn’t special syntax, but application of another standard language construct (in this case, a macro).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The discussion of &lt;code&gt;assert&lt;/code&gt; in the Swift book re-raises the question about the global namespace:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“You write an assertion by calling the global &lt;code&gt;assert(_:_:)&lt;/code&gt; function.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This continues to suggest strongly that Swift does in fact have a true global namespace, &lt;em&gt;not&lt;/em&gt; an automatically-imported prelude. That can make a big difference for applications in certain spaces (e.g. systems programming), when you might have good reason to want to replace the standard library’s approach with a different one. (See Rust’s &lt;a href="https://doc.rust-lang.org/book/no-stdlib.html"&gt;&lt;code&gt;#[no_std]&lt;/code&gt;&lt;/a&gt; docs and the &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md"&gt;related RFC&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In Rust, &lt;code&gt;assert!&lt;/code&gt; is a macro, not a function, which is an interesting but perhaps not &lt;em&gt;especially&lt;/em&gt; important distinction in this particular case. (It might be, though; I’d have to see the implementation of each to see how they play out differently.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, this also highlights another large difference between the two: testing is &lt;a href="https://doc.rust-lang.org/stable/book/testing.html"&gt;front and center&lt;/a&gt; in Rust, and barely receives a mention so far in the Swift book (and isn’t in the table of contents). Having language-level support for testing is a big deal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Language tour and first chapter of the language guide down, my sense is that Swift is a substantially better language than C or C++ (and presumably than Objective C, but since I don’t know that language I can’t speak to it) for app design, but that Rust is a better language yet. Both a far more modern than their predecessors, but they approach the same problems in surprisingly different ways, relatively similar syntax notwithstanding. So far, I like the Rust approach better.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In particular, more syntax is not my preferred way to tackle these things. Providing good language constructs and primitives on which to build seems better in &lt;em&gt;many&lt;/em&gt; ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It substantially reduces the cognitive load for the developer, by keeping the number of constructs small and simply varying how they are applied.&lt;/li&gt;
&lt;li&gt;It increases the quality of those primitives, because it forces the language deadness to make sure they actually address the full problem space.&lt;/li&gt;
&lt;li&gt;It lets developers approach the same problem in ways the language design team may not have anticipated, and over time the community may find shared conventions that improve on the &lt;code&gt;std&lt;/code&gt; approach, and nothing has to change in the language spec (or the compiler!) to adopt those changes.&lt;/li&gt;
&lt;li&gt;In general, then, it makes change much easier to manage, and change can be community-driven rather than requiring the language design team to manage it.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This may of course be intentional on Apple’s part with Swift. Maintaining tight control over its tooling is very typical of modern Apple.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Sep 2015 10:20:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-06:2015/rust-and-swift-ii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (i)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-i.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I started writing these responses in a Slack channel of developers I participate in as I worked through the &lt;a href="https://developer.apple.com/swift/"&gt;Swift&lt;/a&gt; &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/"&gt;book&lt;/a&gt;. I realized after a bit that it would make a better blog post than chat room content, so here we are. This is all entirely off-the-cuff: me just thinking out loud as I read; this is by no means expert opinion.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;..&amp;lt;&lt;/code&gt; – seriously?&lt;/p&gt;
&lt;p&gt;That has to be one of the most annoying operators I’ve ever seen. It ends up with cognitive noise because &lt;code&gt;&amp;lt;name&lt;/code&gt; initially processes as “starting a generic” and you have to re-parse it visually and mentally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the first chapter of the Swift book, my impression is “a poor man’s Rust”; my gut feel based on that first pass and everything I’ve seen and read about Swift over the past two years is that it’s roughly what you would get if you took Rust’s syntax and replaced Rust’s hard safety goals with the aim of mapping to ObjC semantics. (To be fair to Apple, that interoperability was probably necessary.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An example that jumps out at me as immediately illustrative of the difference in approach the languages take is the way you pass structures by reference vs. copy. In Swift, that’s done via two completely distinct language constructs, &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es respectively.&lt;/p&gt;
&lt;p&gt;In Rust, there is just the &lt;code&gt;struct&lt;/code&gt; type to handle both of those. They’re immutable unless you declare them with &lt;code&gt;mut&lt;/code&gt;, and you can pass them via copy simply by implementing the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt; (which seems roughly analogous to Swift’s &lt;code&gt;protocol&lt;/code&gt;, but I’ve not yet dig deeply enough to see how they differ). Those things aren’t baked into the language, but use simpler language building blocks to define behavior into he library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I saw someone do a write up a while back arguing that Go isn’t a &lt;em&gt;bad&lt;/em&gt; language, it just isn’t a &lt;em&gt;good&lt;/em&gt; language. My first impression of Swift, after having spent the last month with Rust, is very much along those lines.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Huh. Here’s something that I appreciate about Rust, Haskell, and others now that I didn’t before: there’s a difference between implicitly/automatically importing a prelude or a given set of standard library functions, and having actually global functions. Does Swift actually have functions like &lt;code&gt;print&lt;/code&gt; in a global namespace, as the book seems to imply, or they being imported automatically &lt;em&gt;a la&lt;/em&gt; Rust/Haskell/etc.?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; it appears Swift does likewise, but that you can’t access the relevant module directly. Which is halfway there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hmm. Why have &lt;code&gt;Double&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;Float&lt;/code&gt;—just for ObjC interop, I guess?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; follow-up from a conversation with a friend: it’s because you have 32- and 64-bit architectures out there; sometimes you don’t want 64 bits of floating point precision for that reason. Note that Rust &lt;em&gt;also&lt;/em&gt; has this distinction; you can declare things as &lt;code&gt;f32&lt;/code&gt; or &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending the above note on &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;protocol&lt;/code&gt;s vs. Rust’s approach: the same thing is true about &lt;code&gt;extension&lt;/code&gt;, which is a distinct concept from implementing a &lt;code&gt;protocol&lt;/code&gt;; again, in Rust these are both just handled with a single language construct, &lt;code&gt;impl&lt;/code&gt;. That’s not because &lt;code&gt;impl&lt;/code&gt; is overloaded, but rather because the underlying language machinery is the same for the two things. (edited)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(I’ve a feeling learning Swift is going to turn me into even more of a Rust fanboy.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reading the two books in close sequence like this is proving really productive mentally for thinking about how the two handle the same issues. I’ve never done anything quite like this before, and it’s fascinating.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have an increased appreciation for Rust’s use of semi-colons to turn expressions into statements, and thereby to distinguish clearly between the two (among other things, allowing for implicit return of anything that’s an expression).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another interesting comparison: Rust’s &lt;code&gt;match&lt;/code&gt; and Swift’s &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; fill the same role of pattern matching. I’m curious to see how they differ. Does Swift do matching on arbitrary expressions?&lt;/p&gt;
&lt;p&gt;Also, I see where the syntax choices came from in both, and while I slightly prefer Rust’s, I think both make reasonably good sense; Swift’s will understandably be more familiar to C and ObjC programmers, and that’s a perfectly defensible approach. Seen that way, it is expanding on the C-style construct (even if it’s actually doing something substantially more sophisticated than that under the hood by being a form of actual pattern matching).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 13:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-04:2015/rust-and-swift-i.html</guid><category>listicles</category><category>software development</category></item><item><title>Corporate and Government Surveillance</title><link>http://www.chriskrycho.com/2015/corporate-and-government-surveillance.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;&lt;a href="https://witheredgrass.wordpress.com/"&gt;Brian Auten&lt;/a&gt; shared &lt;a href="http://www.lawfareblog.com/2015/06/why-americans-hate-government-surveillance-but-tolerate-corporate-data-aggregators/"&gt;this speech&lt;/a&gt; by Sen. Sheldon Whitehouse on Facebook, and I wrote up what follows in response.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;I broadly agree with the critique of the libertarian/TP angle on government as essentially an appendage to business. I am &lt;em&gt;by no means&lt;/em&gt; hostile to the government in general or in principle, nor even to &lt;em&gt;spying&lt;/em&gt;, nor even to warranted (double entendre intended) use of data for law enforcement. The idea that all government is bad is woefully incorrect; it is better to speak of &lt;em&gt;abuses&lt;/em&gt;, either of government or of business or indeed of any sphere exceeding its right domain or acting inappropriately within its domain.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is a profound and important difference between corporate data collection and federal government data collection: one of them, people accede to directly (though see below); the other they accede to (at best!) indirectly through elected representatives, with whom they may profoundly disagree and against whom they have no recourse (unlike the case of, say, Google or Facebook—one &lt;em&gt;can&lt;/em&gt; simply stop dealing with them). Whatever information I have granted to a corporation, I have chosen to grant them, and I can stop doing so with future information at any time. I &lt;em&gt;cannot&lt;/em&gt; do so with the NSA, FBI, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That distinction may be relatively meaningless for most people in practice, given that the terms, means, and consequences of the data collection carried about by corporations are often obscure to the point of incomprehensibility.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As such, a serious reformation ought to occur in the realm of business and the way that people’s information is handled. Treating information about customers as the primary point of transactional value has significantly deleterious costs on any number of things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For this reason, I consistently advocate for and (where possible) choose to use services which are supported by direct payment, rather than by advertising, and so on. This is not always possible, but where it is, we should consider taking that path.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nonetheless, because of the government’s power of coercion—a power not held by corporations, though to be sure they can exercise significant force of a certain sort through legal machinery/chicanery—the collection of metadata by the government does pose a more potent and long-term threat to liberty than that by corporations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As such, people are &lt;em&gt;absolutely right&lt;/em&gt; to be more tolerant of corporate data collection than of federal data collection. That they ought to be less tolerant of corporate data collection by no means suggests that their hostility to unwarranted governmental data collection should be diminished: quite the contrary.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Therefore, while some of the criticism of the government’s data collection may well be driven by the sorts of corporate interests he suggests, and while much of the opposition from companies like Facebook and Google is indeed hypocritical, the criticism is still warranted. The NSA has clearly and repeatedly overstepped even the extremely wide bounds granted it by the Patriot Act, and the Patriot Act itself licensed behavior that should be horrifying to people concerned with the long-term effects of mass surveillance on governance.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 02 Jun 2015 22:43:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-06-02:2015/corporate-and-government-surveillance.html</guid><category>listicles</category></item><item><title>Public-ish Plans</title><link>http://www.chriskrycho.com/2015/public-ish-plans.html</link><description>&lt;p&gt;I have not (yet) made a formal list of goals for 2015, though I think I may do so on Sunday evening. While New Years’ resolutions can be silly and get us in trouble (when we set unrealistic goals, or unhelpful goals), the turning of the year can also be a helpful time to evaluate the way we spend our time and the things we want to accomplish.&lt;/p&gt;
&lt;p&gt;What follows is a list of public-ish things I am &lt;em&gt;hoping&lt;/em&gt; to manage in 2015, in no particular order. Come the end of the year, I will Lord willing look back and see which of these I was able to pull off!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Publish at least two seasons of &lt;a href="//www.winningslowly.org"&gt;Winning Slowly&lt;/a&gt; with &lt;a href="//stephencarradini.com"&gt;Stephen Carradini&lt;/a&gt; just as we did last year—but better.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Get the site for Winning Slowly updated so that it paginates between seasons! This means writing an extension for &lt;a href="//docs.getpelican.com/en/3.5.0/"&gt;Pelican&lt;/a&gt; that can paginate on something besides page count. An excuse to write Python? I call that winning.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Migrate Jaimie’s &lt;a href="//jaimiekrycho.com"&gt;Jaimie’s professional writing website&lt;/a&gt; from WordPress to &lt;a href="//ghost.org"&gt;Ghost&lt;/a&gt;. (Maybe do something similar with her current &lt;a href="//jaimiedawn.blogspot.com"&gt;personal site&lt;/a&gt;, which runs on Blogger. Yuck.) I’ve gotten a bit of a start on that already, and I hope to knock it out sooner rather than later.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Get to a point where I’m hosting all my own sites on my own DigitalOcean droplet (or similar). I’ve been moving that direction slowly but steadily anyway—whereas I started and ran for a long time on simple shared hosting, I’ve been using &lt;a href="https://www.webfaction.com/?aid=67929"&gt;Webfaction&lt;/a&gt; for a good chunk of the past year, and now am pretty well ready to take the plunge this year into just running my own server. No skin off their backs; Webfaction has been great, as was &lt;a href="https://billing.stablehost.com/aff.php?aff=319"&gt;StableHost&lt;/a&gt; before them. I’m just ready to be in control (even with the bit of extra maintenance that entails).&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write at least three minutes of music, and post it to my &lt;a href="//soundcloud.com/chriskrycho"&gt;SoundCloud&lt;/a&gt; account. Preferably five minutes, but at least three.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write some poetry.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a substantive essay and post it at least once a month.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Post at least a half dozen book reviews (which, among other things, means reading at least a half dozen books worth reviewing). These can be fiction or non-fiction. Personally, I’d like to get everything from Dostoevsky to Schreiner in there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add a picture to my &lt;a href="/about"&gt;About&lt;/a&gt; page!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Post a &lt;a href="/family"&gt;#family&lt;/a&gt; update at least once a month. It’ll be good for &lt;em&gt;me&lt;/em&gt;, just to have a better way of tracking what’s going on with our little gals, and I know my family would enjoy it, too.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In sum, I’d like to be doing &lt;em&gt;something&lt;/em&gt; in nearly every public-facing category in which I’m interested. Maybe it won’t be a lot, but keeping my musical skills doing matters to me. Keeping my brain engaged on a wide variety of topics matters to me. Keeping my writing skills sharp matters to me. I cannot &lt;em&gt;excel&lt;/em&gt; at all of those things, certainly—especially not if I wish to be a good husband and father! But keeping them active means keeping them from further atrophying, and that is something, at least. It will hopefully leave them more available to me for times in the future when I am able to dedicate more time to them.&lt;/p&gt;
&lt;p&gt;If 2014 and 2013 were both years in which I focused primarily on software—and all to the good!—then I hope 2015 will be a year in which I am able to broaden out again and focus on a wider variety of things!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You’ll note that there really aren’t any purely personal goals on this list. Not to worry: I have them, and I intend to formalize them in the next couple of days. But one of the things I have learned over the many years I have been blogging is that not everything needs to be public. Some things can be; indeed, some &lt;em&gt;should&lt;/em&gt; be. Some things &lt;em&gt;may&lt;/em&gt; be public but &lt;em&gt;need&lt;/em&gt; not, and yet others &lt;em&gt;should not&lt;/em&gt; be public. Right now, I am choosing to leave quite a few things in the “may be need not” category private. (This direction, I can always change my mind later. It’s essentially impossible to do the opposite in the internet era.)&lt;/p&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;em&gt;Slowly&lt;/em&gt;. Beat you to it.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Note: those are both affiliate links; they’ll give me a slight kickback. For StableHost, you should also use the code &lt;code&gt;krycho50percent&lt;/code&gt; to get 50% off! I’d love it if you used it if you decide to sign up for either of them.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 02 Jan 2015 20:15:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-01-02:2015/public-ish-plans.html</guid><category>listicles</category></item><item><title>A Few Theses on Blogging</title><link>http://www.chriskrycho.com/2014/a-few-theses-on-blogging.html</link><description>&lt;p&gt;I am a habitually—even chronically—long-winded blogger. I always have been. I sat down a few weeks ago to write up an explanation of my running approach, and I haven’t finished it yet… because it is over 2,500 words long and growing rapidly longer. But as I have considered my approach to blogging of late, and as I have also been posting fairly regularly on App.net (my social media locale of choice), it occurred to me:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Blog posts do not have to be the lengthy things I usually make of them.&lt;/li&gt;
&lt;li&gt;I often write up a series of thoughts—not necessarily an “argument” or indeed anything more than a series of connected thoughts—on App.net, connecting them via the ‘reply’ mechanism and enumerating them. Rather like I am here.&lt;/li&gt;
&lt;li&gt;Doing so inevitably clutters up the streams of anyone following me.&lt;/li&gt;
&lt;li&gt;That clutter may or may not be problematic: some folks may enjoy those connected thoughts. Others may not.&lt;/li&gt;
&lt;li&gt;For those that &lt;em&gt;do&lt;/em&gt; enjoy those connected thoughts, a blog post like this would probably serve just as well.&lt;/li&gt;
&lt;li&gt;For those who do &lt;em&gt;not&lt;/em&gt; enjoy them… well, this sort of thing would be a welcome way to clear their streams up without causing me any particular difficulty.&lt;/li&gt;
&lt;li&gt;Using lists does not automatically mean I have given in to the constant temptation to make my blogging about driving views.&lt;/li&gt;
&lt;li&gt;Seriously.&lt;/li&gt;
&lt;li&gt;This blog will &lt;em&gt;never&lt;/em&gt; drive substantial amounts of traffic. That is fine by me. Indeed, I would probably feel a bit odd if it did.&lt;/li&gt;
&lt;li&gt;Therefore, when I have those sorts of thoughts-in-a-line in the future, I will do as I have done here. I will write a ‘listicle’ (the shame!) and share it for others to partake of—or not!—as they please.&lt;/li&gt;
&lt;li&gt;Taking that approach will almost certainly free me up to blog more briefly when I feel like it, as well. That, too, can only be a good thing.&lt;/li&gt;
&lt;li&gt;After all: I am happier when I am writing.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;As I have so often &lt;a href="http://www.chriskrycho.com/2014/the-long-race.html"&gt;noted before&lt;/a&gt;…&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 09 Jul 2014 21:15:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2014-07-09:2014/a-few-theses-on-blogging.html</guid><category>listicles</category></item></channel></rss>