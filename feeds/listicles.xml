<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Krycho</title><link>http://www.chriskrycho.com/</link><description></description><atom:link href="http://www.chriskrycho.com/feeds/listicles.xml" rel="self"></atom:link><lastBuildDate>Sat, 02 Jan 2016 21:54:00 -0500</lastBuildDate><item><title>Rust and Swift (x)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-x.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Classes and structs (product types), and reference and value types.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift and Rust both have ‚Äúproduct types‚Äù as well as the &lt;code&gt;enum&lt;/code&gt; ‚Äúsum types.‚Äù In Rust, these are &lt;code&gt;struct&lt;/code&gt; types; Swift splits them into &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;‚ÄúProduct types‚Äù will be much more familiar to programmers coming from a C-like background, or indeed most object-oriented programming languages: these are the same basic kind of thing as classes, structs, and objects in other languages. These include &lt;em&gt;all&lt;/em&gt; the value types which compose them, unlike sum types‚Äî&lt;code&gt;enum&lt;/code&gt;‚Äîwhich have &lt;em&gt;only one&lt;/em&gt; of the value types which compose them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Right off the bat, I note the Swift book‚Äôs somewhat amusing reticence to call out C and C-descended languages:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because there‚Äôs such a long list of languages not directly descended from C which do that, right? üòâ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust differs not only from Swift but from every other modern language I have used in not having a constructor &lt;em&gt;syntax&lt;/em&gt; for its instantiations. Whereas C++ has &lt;code&gt;new NameOfType()&lt;/code&gt; and Python has &lt;code&gt;NameOfType()&lt;/code&gt; and Swift has &lt;code&gt;NameOfType()&lt;/code&gt;, ‚Äúconstructors‚Äù for Rust &lt;code&gt;struct&lt;/code&gt;s are just functions which return an instance constructed using literal syntax, by convention &lt;code&gt;NameOfType::new()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let‚Äôs make a &lt;code&gt;struct&lt;/code&gt; defining a location in a plane, you might do this in Swift (leaving aside initializer values; I‚Äôll come back to those later). These definitions look &lt;em&gt;very&lt;/em&gt; similar. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x: Double
    var y: Double
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Point {
    x: f64,
    y: f64,
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Creating the types looks a little different, though. Here‚Äôs a constructor in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let point = Point(x: 0, y: 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the two ways we could construct the type in Rust, a literal constructor (fairly similar to constructing &lt;code&gt;dict&lt;/code&gt; literals in Python or object literals in JavaScript):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let point = Point { x: 0.0, y: 0.0 };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or a constructor method, &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;Constructor&amp;quot;
impl Point {
    fn new(x: f64, y: f64) -&amp;gt; Point {
        Point { x: x, y: y }
    }
}

let another_point = Point::new(0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observe: these two things in Rust are the same under the covers (though if &lt;code&gt;Point&lt;/code&gt;s had non-public internals, they would be non-trivially different: you couldn‚Äôt construct it with its private members externally). As usual, Rust opts to keep the language relatively small in these core areas. Given the plethora of ways you can construct something in e.g.¬†C++, I count that a big win.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another difference: Swift has &lt;em&gt;syntax&lt;/em&gt; for default values; Rust uses a &lt;code&gt;trait&lt;/code&gt; instead. In Swift, you simply supply the default value in the definition of the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0
    var y = 0.0
}

let point = Point()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you use &lt;code&gt;std::default::Default&lt;/code&gt;, which provides a standard value for a given type, and for simple types can be supplied by the compiler even for custom types. Here is the equivalent Rust code:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

#[derive(Default)]
struct Point {
    x: f64,
    y: f64,
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is reasonable enough, but we can also supply our own custom implementation if we so desire:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

struct Point {
    x: f64,
    y: f64,
}

impl Default for Point {
    fn default() -&amp;gt; Point {
        Point { x: 0.0, y: 0.0 }
    }
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this is trivial for this type, but you can see how it could be useful for more complex types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The tradeoffs here are our usual suspects: Rust‚Äôs re-use of an existing concept/tool within the language (&lt;code&gt;trait&lt;/code&gt;) vs.¬†Swift‚Äôs use of syntax. Rust is slightly more explicit, making it obvious that a default value is being created‚Äîbut Swift is perfectly readable and the syntax is consistent with many other languages, and it &lt;em&gt;is&lt;/em&gt; shorter.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages use &lt;code&gt;.&lt;/code&gt; syntax for member access. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;println(&amp;quot;The point is: \(point.x), \(point.y)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;println!(&amp;quot;The point is {:}, {:}&amp;quot;, point.x, point.y);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift lets you define items &lt;em&gt;within&lt;/em&gt; a struct as mutable or constant. So you can create a variable struct instance, with some of its items immutable:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct PointOnZAxis {
    var x: Double
    var y: Double
    let z = 0.0
}

var point = PointOnZAxis(x: 4.0, 5.0)
point.x = 5.0
point.y = 6.0
// This wouldn&amp;#39;t compile, though:
// point.z = 1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty handy for a lot of object-oriented programming approaches.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And Rust doesn‚Äôt have it. There are ways to accomplish the same thing; this isn‚Äôt the end of the world. Still, it‚Äôs an interesting omission, and it‚Äôs very much by design. Rust &lt;em&gt;used&lt;/em&gt; to have this feature, and dropped it‚Äîand for good reason. Say you had a mutable field in a mutable struct, and then an immutable reference to it; should the mutable field be mutable, or immutable, with that reference?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Rusty way to do this is to differentiate between public and private data. The above examples don‚Äôt make the public/private distinction particularly clear, because they assume everything is within the same module. However, many times, this will not be the case.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod geometry {
    pub struct Point {
        x: f64,
        pub y: f64,
    }

    impl Point {
        pub fn new() -&amp;gt; Point {
            Point { x: 0.0, y: 0.0 }
        }

        pub fn set_x(&amp;amp;mut self, x: f64) {
            self.x = x;
        }
    }
}

fn main() {
    // Won&amp;#39;t compile: the `x` field is private.
    // let mut p = geometry::Point { x: 0.0, y: 0.0 };

    // Will compile: the `new` method is public.
    let mut p = geometry::Point::new();

    // Won&amp;#39;t compile: `x` isn&amp;#39;t public.
    // p.x = 4.0;
    // You can use the setter, though:
    p.set_x(4.0);

    // You *can* set `y` directly, though, because it&amp;#39;s public.
    p.y = 14.0;

    // You can&amp;#39;t set fields either way if the instance is immutable.
    let q = geometry::Point::new();

    // This fails because `set_x` requires a mutable reference, but `q` is
    // immutable.
    // q.set_x(4.0);

    // This fails because `q` is immutable, and so all its fields are, too.
    // q.y = 14.0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is an interesting way of handling this issue. Rust takes the fairly standard use of information hiding (one of the basic principles of most object-oriented programming techniques) and combines it with the language‚Äôs normal mutability rules to make it so that the mutability of any given instance data is quite clear: all public members are just as mutable as the struct. If a member isn‚Äôt potentially publicly mutable, it isn‚Äôt publicly accessible. I really like this, though it took some mental readjustment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There‚Äôs one other difference here, and it‚Äôs actually one of the areas Swift and Rust diverge substantially. Rust has &lt;code&gt;struct&lt;/code&gt; for all product types; Swift splits them into &lt;code&gt;struct&lt;/code&gt; types and &lt;code&gt;class&lt;/code&gt; types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift &lt;code&gt;class&lt;/code&gt;es have inheritance; there is presently &lt;em&gt;no&lt;/em&gt; inheritance in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additionally, whereas Rust determines whether to use pass-by-reference or -value depending on details of the type (whether it implements the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;) and expected arguments to a function, Swift makes that distinction between &lt;code&gt;class&lt;/code&gt; (pass-by-reference) and &lt;code&gt;struct&lt;/code&gt; (pass-by-value) types. Quirky.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Not bad, &lt;em&gt;per se&lt;/em&gt;. But quirky.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I recently bumped into some discussion of data types in C‚ôØ along with C, C++, and Java (&lt;a href="http://joeduffyblog.com/2015/12/19/safe-native-code/"&gt;here&lt;/a&gt;) and discovered that Swift is stealing this idea from C‚ôØ, which &lt;a href="https://msdn.microsoft.com/en-us/library/0taef578.aspx"&gt;makes the same copy/reference distinction&lt;/a&gt; between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One consequence of this: in Rust, you‚Äôre always rather explicit about whether you‚Äôre accessing things by value vs.¬†by reference. Not so in Swift; you have to remember whether the item you‚Äôre touching is a &lt;code&gt;struct&lt;/code&gt; type or a &lt;code&gt;class&lt;/code&gt; type, so that you can &lt;em&gt;remember&lt;/em&gt; whether a given assignment or function call results in a reference or a copy. This is necessary because Swift doesn‚Äôt let you make that explicit (trying to hide the memory management from you). And it‚Äôs not alone in that, of course; many other high-level languages obscure that for convenience but still require you to think about it in certain circumstances. I‚Äôve been bitten in the past by the value/reference distinction when thinking through the behavior of Python objects, for example, so that‚Äôs not a critique of Swift. Moreover, having the distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types does let you be &lt;em&gt;more&lt;/em&gt; explicit than you might in e.g.¬†Python about how given data will be handled.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I won‚Äôt lie, though: I like Rust‚Äôs approach better. (Shocking, I know.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All that nice initializer syntax for Swift &lt;code&gt;struct&lt;/code&gt; types is absent for its &lt;code&gt;class&lt;/code&gt; types, which seems strange to me.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift supplies some syntax for object identity, since it‚Äôs useful to know not only whether two &lt;code&gt;class&lt;/code&gt; instances have the same data, but are in fact the same instance. You can use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;. Handy enough. To get at this kind of equivalence in Rust, you have to use raw pointers (which are often but not always &lt;code&gt;unsafe&lt;/code&gt;; you can do this specific comparison &lt;em&gt;without&lt;/em&gt; being &lt;code&gt;unsafe&lt;/code&gt;, for example) to check whether the memory addresses are the same.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Previous: Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 22 Dec 2015 13:30:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-12-06:2015/rust-and-swift-x.html</guid><category>listicles</category><category>software development</category></item><item><title>Rust and Swift (ix)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ix.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Right off the bat when looking at the definitions for Swift‚Äôs and Rust‚Äôs &lt;code&gt;enum&lt;/code&gt; types, a difference pops out: the use of the keyword &lt;code&gt;case&lt;/code&gt; to introduce an enum member in Swift. In one sense, this overloads that keyword, but in another sense it‚Äôs fine: pattern matching and enums go hand in hand, so the use in both cases is fairly natural. Rust doesn‚Äôt have any special syntax to designate the elements of an enum; they‚Äôre just separated by commas.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am not at all shocked to find that Swift has a variant syntax for its unit type case declarations, where a single &lt;code&gt;case&lt;/code&gt; keyword precedes a list of comma-separated cases defined on a single line. (At this point, I would be more surprised &lt;em&gt;not&lt;/em&gt; to find a variant syntax for something in Swift!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Something truly wonderful about both a Rust and Swift: enumerated types aren‚Äôt just wrappers around integer values. They‚Äôre real types of their own. This is powerful.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift also share in having enumerated types that can hold values. The most prominent of these so far in the Swift book are optionals, the &lt;code&gt;Optional&lt;/code&gt; enum type, corresponding very closely to Rust‚Äôs &lt;code&gt;Option&lt;/code&gt; type. Having had these for a bit in playing with Rust, and having gotten familiar with the utility of types like these while reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;‚Äîa delightful book which introduces Haskell and functional programming using Haskell‚Äôs &lt;code&gt;Maybe&lt;/code&gt; type‚ÄîI now miss them profoundly in languages which don‚Äôt have them. (Which is to say: every language I use on a regular basis professionally: C, C++, Python, JavaScript, etc.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs enum types don‚Äôt have integer values &lt;em&gt;by default&lt;/em&gt;‚Äîbut they can have them if you define a type and assign a value to each enum case at the definition. These ‚Äúraw values‚Äù are distinct from the ‚Äúassociated values‚Äù noted just above. I expect these exist primarily for ease of interoperation with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;Rust doesn‚Äôt have anything like this, at least that I can think of. The main place it would be useful would be for foreign function interfaces (as in Swift), and this is one of several such gaps in Rust,&lt;/del&gt; along with the lack of a straightforward way to map to C‚Äôs &lt;code&gt;union&lt;/code&gt; types. &lt;del&gt;There are trade offs in terms of adding the functionality to the language, though, as it substantially increases the complexity of what an enum value can be, I think.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; This was incorrect. From the [Rust Reference] section on [Enumerations]:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enums have a discriminant. You can assign them explicitly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum Foo {
    Bar = 123,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a discriminant isn‚Äôt assigned, they start at zero, and add one for each variant, in order.&lt;/p&gt;
&lt;p&gt;You can cast an enum to get this value:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let x = Foo::Bar as u32; // x is now 123u32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This only works as long as none of the variants have data attached. If it were &lt;code&gt;Bar(i32)&lt;/code&gt;, this is disallowed.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Initialization of Swift‚Äôs raw-valued enum type is quite similar, and pleasantly so, to Python‚Äôs initialization of enums.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In a surprising change from the usual, Swift‚Äôs syntax for binding variable names when pattern matching against an enum is &lt;em&gt;more&lt;/em&gt; verbose than Rust‚Äôs, requiring the use of either a leading &lt;code&gt;let&lt;/code&gt; on the &lt;code&gt;case&lt;/code&gt; statement if all the elements are of the same type, or a &lt;code&gt;let&lt;/code&gt; in front of each element otherwise:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;var matchedValue: String
let matchee = 3.14159
switch matchee {
case 3.14159:
    matchedValue = &amp;quot;pi&amp;quot;
case _:
    matchedValue = &amp;quot;not pi&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, a matched pattern can simply bind its value directly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let matchee = 3.14159;
let matchedValue = match matchee {
    3.14159 =&amp;gt; &amp;quot;pi&amp;quot;.to_string(),
    _ =&amp;gt; &amp;quot;not pi&amp;quot;.to_string()
};&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the ability to do recursive enumerations with its &lt;code&gt;indirect&lt;/code&gt; type. This is conceptually interesting, but off the top of my head I can‚Äôt think of a time when this would have been useful at any point since I started programming seven and a half years ago. The book‚Äôs example of a recursive function a aliasing arithmetic expressions is fine, but not particularly illuminating to me. I suspect, though, that it might make more sense if I were more familiar with pure functional programming paradigms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/65990633"&gt;points out&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Indirect enums are useful for recursive types in general. There are a lot of these: Lists, trees, and streams are the big ones that come to mind.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All those same lines: Rust does &lt;em&gt;not&lt;/em&gt; have the ability to have recursive enumerations at present (or recursive &lt;code&gt;struct&lt;/code&gt; types, for that matter), at least without heap-allocating with &lt;code&gt;Box&lt;/code&gt; along the way. You &lt;em&gt;can&lt;/em&gt; construct such a type, in other words, but you have to be explicit about how you‚Äôre handling the memory, and it can‚Äôt be stack-allocated.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For an example of a recursive enumeration type (as well as an interesting/hilarious example of how you can easily confuse the compiler if you do this wrong), see &lt;a href="https://users.rust-lang.org/t/recursive-enum-types/2938"&gt;this Rust forum post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For some discussion on stack- and heap-allocated memory in Rust, I‚Äôll shamelessly promote my Rust podcast, &lt;a href="http://www.newrustacean.com"&gt;New Rustacean&lt;/a&gt;: take a listen to &lt;a href="http://www.newrustacean.com/show_notes/e005/index.html"&gt;e005: Allocate it where?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Previous: Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Next Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 02 Jan 2016 21:54:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-11-09:2015/rust-and-swift-ix.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (viii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-viii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift handle function definition fairly similarly, at least for basic function definitions. In fact, for most basic functions, the only difference between the two is the keyword used to indicate that you‚Äôre declaring a function: &lt;code&gt;fn&lt;/code&gt; in Rust and &lt;code&gt;func&lt;/code&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Likewise, both return an empty tuple, &lt;code&gt;()&lt;/code&gt;, called the &lt;em&gt;unit type&lt;/em&gt; in Rust or &lt;code&gt;Void&lt;/code&gt; in Swift. Note, however, that this unit/&lt;code&gt;Void&lt;/code&gt; type is &lt;em&gt;not&lt;/em&gt; like C(++)‚Äôs &lt;code&gt;void&lt;/code&gt; or Java‚Äôs &lt;code&gt;null&lt;/code&gt;: you cannot coerce other types to it; it really is an empty tuple.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type declarations on functions are basically identical for simple cases, though they vary into the details as you get into generics and constraints in generics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have no idea why the Swift team chooses to represent function names like this: &lt;code&gt;function_name(_:second_param:third_param:&amp;lt;etc.&amp;gt;)&lt;/code&gt;. Perhaps it‚Äôs a convention from other languages I‚Äôm simply unfamiliar with, but it seems both odd and unhelpful: eliding the first parameter name obscures important information. Also, why use colons for the delimiter?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I‚Äôm informed via Twitter and App.net that this reflects how function names work in Objective C, and derives ultimately from Smalltalk.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Being able to name the items in a returned type in Swift is quite handy; it‚Äôs something I have often wanted and had to work around with dictionaries or other similar types in Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We‚Äôll see how I feel once I‚Äôve been writing both for a while, but initially I &lt;em&gt;strongly&lt;/em&gt; prefer Rust‚Äôs more-obvious (if also somewhat longer) &lt;code&gt;-&amp;gt; Option&amp;lt;i32&amp;gt;&lt;/code&gt; to return an optional integer to Swift‚Äôs &lt;code&gt;-&amp;gt; Int?&lt;/code&gt;. I am quite confident that I‚Äôll miss that trailing &lt;code&gt;?&lt;/code&gt; somewhere along the way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I‚Äôm sure there‚Äôs a reason for Swift‚Äôs internal and external parameter names and the rules about using &lt;code&gt;_&lt;/code&gt; to elide the need to use keyword arguments (but automatically eliding the first one) and so on‚Ä¶ but I really can‚Äôt see the utility, overall. It seems like it would be better just to have Python-like args and keyword args.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That‚Äôs doubly so given that Swift‚Äôs rules for default-valued parameters map exactly to Python‚Äôs: they need to go at the end, after any parameters which don‚Äôt have default values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs variadic parameters are nice‚Äîthough of course limited, since if you have more than one, the compiler may not know how to resolve which destination parameter a given argument belongs with. (I imagine the compiler &lt;em&gt;could&lt;/em&gt; be extended to be able to handle multiple variadic parameters as long as hey we‚Äôre all of different types, but that‚Äôs probably not worth the work or the potential confusion it would introduce.) In any case, it‚Äôs a small nicety that I do wish Rust had.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs variable parameters are‚Ä¶ interesting. I can see the utility, sort of, but (probably from years of habit with C and Python and pass-by-reference types), it‚Äôs just not a pattern that makes a lot of sense to me right now. No doubt I‚Äôll get used to them in idiomatic Swift, but while Rust doesn‚Äôt have a similar feature, I suspect I won‚Äôt miss it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In/out parameters‚Äîthat is, mutable pass-by-reference types‚Äîare available in both languages. The syntax is &lt;em&gt;very&lt;/em&gt; different here, as are the semantics.&lt;/p&gt;
&lt;p&gt;Swift has the &lt;code&gt;inout&lt;/code&gt; keyword, supplied before a parameter definition:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func adds4ToInput(inout num: Int) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust has instead a variation on every other type definition, declaring the type in this case to be a mutable reference:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn adds_4_to_input(num: &amp;amp;mut i32) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, in other words, Swift opts to use new syntax (in this case, a dedicated keyword) while Rust opts to use the same syntax used everywhere else to denote a mutable reference. In fairness to Swift, though, this is something of a necessity there. From what I‚Äôve seen so far, Swift generally doesn‚Äôt (and perhaps can‚Äôt?) do pointers or references explicitly (though of course it‚Äôs handling lots of things that way under the covers); arguments to functions are a special case, presumably present primarily for interoperability with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs function type definitions, as used in e.g.¬†function parameter definitions, are quite nice, and reminiscent of Haskell in the best way. Rust‚Äôs are pretty similar, and add in its &lt;code&gt;trait&lt;/code&gt; usage‚Äîbecause functions types &lt;em&gt;are&lt;/em&gt; &lt;code&gt;trait&lt;/code&gt;s. Once again, I really appreciate how Rust builds more complicated pieces of functionality on lower-level constructs in the language. (Swift may be doing similar under the covers, but the Swift book doesn‚Äôt say.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Again, though, the downside to Rust‚Äôs sophistication is that it sometimes bundles in some complexity. Returning a function in Swift is incredibly straightforward:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func getDoubler() -&amp;gt; (Int) -&amp;gt; Int {
    func doubler(number: Int) -&amp;gt; Int {
        return number * 2
    }

    return doubler
}

func main() {
    let doubler = getDoubler()
    println(&amp;quot;\(doubler(14))&amp;quot;)  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doing the same in Rust is a bit harder, because‚Äîas of the 1.3 stable/1.5 nightly timeframe‚Äîit requires you to explicitly heap-allocate the function. Swift just takes care of this for you.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn get_doubler() -&amp;gt; Box&amp;lt;Fn(i32) -&amp;gt; i32&amp;gt; {
    fn doubler(number: i32) -&amp;gt; i32 {
        number * 2
    }

    Box::new(doubler)
}

fn main() {
    let doubler = get_doubler();
    println!(&amp;quot;{:}&amp;quot;, doubler(14));  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you understand what‚Äôs going on under the covers here, this makes sense: Rust normally stack-allocates a function in a scope, and therefore the &lt;code&gt;doubler&lt;/code&gt; function goes out of scope entirely when the &lt;code&gt;get_doubler&lt;/code&gt; function returns if you don‚Äôt heap-allocate it with &lt;code&gt;Box::new&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In both languages, closures and ‚Äúordinary‚Äù functions are variations on the same underlying functionality (as it should be). In Rust‚Äôs case, functions and closures both implement the &lt;code&gt;Fn&lt;/code&gt; trait. In Swift‚Äôs case, named functions are a special case of closures.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Swift syntax for a closure is, well, a bit odd to my eye. The basic form is like this (with the same ‚Äúdoubler‚Äù functionality as above):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ (n: Int) -&amp;gt; Int in
    return n * 2
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For brevity, this can collapse down to the shorter form with types inferred from context, parentheses dropped and the &lt;code&gt;return&lt;/code&gt; keyword inferred from the fact that the closure has only a single expression (note that this wouldn‚Äôt be valid unless in a context where the type of &lt;code&gt;n&lt;/code&gt; could be inferred):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ n in n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The simplicity here is nice, reminiscent in a good way of closures/lambdas in other languages.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; The fact that it‚Äôs a special case is less to my taste.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust‚Äôs closure syntax is fairly similar to Swift‚Äôs brief syntax. More importantly, there‚Äôs no special handling for closures‚Äô final expressions. Remember: the final expression of &lt;em&gt;any&lt;/em&gt; block is always returned in Rust.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n| n * 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to fully annotate the types, as in the first Swift example, it would be like so:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n: i32| -&amp;gt; i32 { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are even &lt;em&gt;more&lt;/em&gt; differences between the two, because of Rust‚Äôs ownership notion and the associated need to think about whether a given closure is being borrowed or moved (if the latter, explicitly using the &lt;code&gt;move&lt;/code&gt; keyword).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the notion of shorthand argument names for use with closures.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; The arguments to a closure get the default names &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, etc. This gets you even &lt;em&gt;more&lt;/em&gt; brevity, and is quite convenient in cases where closures get used a lot (&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ $0 * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If that weren‚Äôt enough, Swift will go so far as to simply reuse operators (which are special syntax for functions) as closures. So a closure call could simply be &lt;code&gt;+&lt;/code&gt; for a function expecting a closure operating on two numbers; Swift will infer that it needs to map back to the relevant method definition on the appropriate type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The upside to this is that the code can be incredibly brief, and‚Äîonce you‚Äôre used to it, at least‚Äîstill fairly clear. The downside to this is yet &lt;em&gt;more&lt;/em&gt; syntax for Swift, and the ever-growing list of things to remember and ways to write the same thing I expect will lead to quite a bit of instability as the community sorts out some expectations for what is idiomatic in any given instance.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And if that weren‚Äôt enough, there is more than one way to supply the body of a closure to a Swift function that expects it: you can supply a block (&lt;code&gt;{ /* closure body */ }&lt;/code&gt;) &lt;em&gt;after&lt;/em&gt; the function which expects it. Yes, this can end up looking nearly identical to the form for declaring a function:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure() { n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you can also drop the parentheses if that‚Äôs the only argument.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In terms of the &lt;em&gt;mechanics&lt;/em&gt; of closures, and not just the syntax, the one significant difference between Rust and Swift is the same one we‚Äôve seen in general between the two languages: Swift handles the memory issues automatically; Rust makes you be explicit about ownership. That is, as noted above about the closures themselves, in Rust you may have to &lt;code&gt;move&lt;/code&gt; ownership to get the expected behavior. Both behave basically like closures in any other language, though; nothing surprising here. Both also automatically copy values, rather than using references, whever it makes sense to do so.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift autoclosures allow for lazy evaluation, which is neat, but: &lt;em&gt;yet more syntax&lt;/em&gt;! Seriously. But I think all its other closure syntaxes &lt;em&gt;also&lt;/em&gt; allow for lazy evaluation. The only reason I can see to have the special attribute (&lt;code&gt;@autoclosure&lt;/code&gt;) here is because they added this syntax. And this syntax exists so that you can call functions which take closures as if they &lt;em&gt;don‚Äôt&lt;/em&gt; take closures, but rather the argument the closure itself takes. But of course, this leads the Swift book to include the following warning:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that the evaluation is being deferred.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes, care needed indeed. (Or, perhaps, you could just avoid adding more special syntax that leads to unexpected behaviors?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Good grief. I‚Äôm tired now. That‚Äôs a half-dozen variants on &lt;em&gt;closure syntax&lt;/em&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remember: there‚Äôs still just one way to write and use a closure in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This takes me back to something I noticed &lt;a href="/2015/rust-and-swift-ii.html"&gt;early on&lt;/a&gt; in my analysis of the two languages. In Swift, there‚Äôs nearly always more than one way to do things. In Rust, there‚Äôs usually one way to do things. Swift prefers brevity. Rust prefers to be explicit. In other words, Swift borrows more of its philosophy from Perl; Rust more from Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I‚Äôm a Python guy, through and through. Perl drives me crazy every time I try to learn it. You could guess (even if you hadn‚Äôt already seen) where this lands me between Rust and Swift.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is incredibly long, but I blame that on the (frankly incredible) number of variants Swift has on the same concept.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Previous: Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Compare the closure syntaxes especially in Ruby and ES6+.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;For a similar example in another up-and-coming language, see &lt;a href="http://elixir-lang.org/getting-started/modules.html#function-capturing"&gt;Elixir&lt;/a&gt;, which does almost exactly the same but with &lt;code&gt;&amp;amp;&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Oct 2015 20:15:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-10-18:2015/rust-and-swift-viii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (vii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pattern matching and the value of expression blocks.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Both Rust and Swift have &lt;em&gt;pattern-matching&lt;/em&gt;, and with what appears to be fairly similar basic behavior. (I touched on this briefly in my &lt;a href="/2015/rust-and-swift-i.html"&gt;first post in the series&lt;/a&gt;.) In Rust this goes under the &lt;code&gt;match&lt;/code&gt; construct, with matches specified like &lt;code&gt;&amp;lt;pattern&amp;gt; =&amp;gt; &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;if&lt;/code&gt; expressions. In Swift, patterns are matched using the &lt;code&gt;switch&lt;/code&gt; construct, with matches specified like &lt;code&gt;case &amp;lt;pattern&amp;gt;: &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;where&lt;/code&gt; expressions. (&lt;code&gt;where&lt;/code&gt; is also used in Rust, but for generic constraints, not pattern match guards.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow you to bind names to a matched pattern: Swift with &lt;code&gt;case let &amp;lt;name&amp;gt;&lt;/code&gt; and Rust simply by using the name in a normal destructuring expression as part of the match definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; that‚Äôs not &lt;em&gt;quite&lt;/em&gt; right. In Rust, you use the &lt;code&gt;@&lt;/code&gt; operator with the variable name you want to bind in the match.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit the second:&lt;/strong&gt; I was mixed up, because Rust actually has &lt;em&gt;both&lt;/em&gt; of those options. You can either match directly, e.g.¬†when getting the value of an &lt;code&gt;Option&lt;/code&gt; type: &lt;code&gt;Some(value)&lt;/code&gt; as the pattern will bind &lt;code&gt;value&lt;/code&gt;. But if you need to bind a specific part of more complicated data structure, the &lt;code&gt;@&lt;/code&gt; operator is present to let you do it in a fairly straightforward way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow for the use of &lt;code&gt;_&lt;/code&gt; as a ‚Äúwildcard‚Äù in match definitions. Since match definitions in Rust use the patterns directly, the equivalent of Swift‚Äôs C-like &lt;code&gt;default&lt;/code&gt; is simply a wildcard match pattern (&lt;code&gt;_ =&amp;gt; &amp;lt;-expression|statement&amp;gt;&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One significant difference: like its &lt;code&gt;if&lt;/code&gt; blocks, Rust‚Äôs &lt;code&gt;match&lt;/code&gt; blocks are expressions, so they can be assigned. I.e., you can write this:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let test = 5u32;
let description = match test {
    0..10 =&amp;gt; &amp;quot;less than ten&amp;quot;,
        _ =&amp;gt; &amp;quot;greater than ten&amp;quot;,
}
println!(&amp;quot;{?:}&amp;quot;);  // &amp;quot;less than ten&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift doesn‚Äôt let you do this; the same thing there would be written like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let test: UInt32 = 5
var description: String
switch test {
    case 0..&amp;lt;10:
        description = &amp;quot;less than ten&amp;quot;
    default:
        description = &amp;quot;greater than ten&amp;quot;
}
println(&amp;quot;\(description)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages have &lt;code&gt;break&lt;/code&gt; statements, but in Rust they‚Äôre only used in loop constructs, while Swift (like C) uses them to escape &lt;code&gt;case&lt;/code&gt;s as well. The Swift book gives an example of one place they‚Äôre necessary in a &lt;code&gt;switch&lt;/code&gt;: to match a case and do nothing there (e.g. &lt;code&gt;default: break&lt;/code&gt;). In Rust, you would simply supply an empty block for that scenario (e.g. &lt;code&gt;_ =&amp;gt; {}&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Correctly, both languages force you to match exhaustively on relevant patterns. If you‚Äôre matching an enumerated type, for example, you must handle every enumerated value. You can of course do this with wildcard patterns or with Swift‚Äôs &lt;code&gt;default&lt;/code&gt;, but the good thing is that both languages will refuse even to compile if a given pattern isn‚Äôt matched.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs default behavior around its &lt;code&gt;switch&lt;/code&gt; statements is sane: it does &lt;em&gt;not&lt;/em&gt; automatically fall through into the next statement. It does let you do this, without checking the condition on the next statement (as in C), using the &lt;code&gt;fallthrough&lt;/code&gt; keyword. Rust, by contrast, simply doesn‚Äôt allow this at all.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages supply named control statements (loops, etc.), with slightly different syntax for naming them. Rust‚Äôs, curiously, shares its syntax with lifetime definitions‚Äîmore on those in a future post.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I don‚Äôt believe Rust has anything quite like Swift‚Äôs &lt;code&gt;guard&lt;/code&gt;s, which allow you to leave normal or expected control flow in the main body of a block, with a secondary block for cases where the &lt;code&gt;guard&lt;/code&gt; isn‚Äôt matched. This isn‚Äôt a huge deal, but it does fit as a nice convenience into the typical &lt;code&gt;if let&lt;/code&gt; pattern in Swift. Basically, it just lets you elide an empty &lt;code&gt;if&lt;/code&gt; block and supply only the &lt;code&gt;else&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/64804111"&gt;points out&lt;/a&gt; that Swift &lt;code&gt;guard&lt;/code&gt;s also require you to exit the current scope, so it‚Äôs unambiguous what you‚Äôre doing if you use them.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Previous: Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Next: Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 20 Sep 2015 13:42:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-19:2015/rust-and-swift-vii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (vi)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Collection types and the difference between syntax and semantics.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It kind of feels like this summarizes a &lt;em&gt;lot&lt;/em&gt; of things about the overall design of Swift:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array. ‚Äî&lt;em&gt;The Swift Programming Language (Swift 2 Prerelease)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The documentation for the various types in Rust‚Äôs &lt;code&gt;std::collections&lt;/code&gt; module is hilarious and great. Highly recommended.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One thing that jumped out at me reading this chapter of the Swift book (though I don‚Äôt think it‚Äôs been explicitly discussed yet): Rust doesn‚Äôt have named parameters; Swift does. There are good reasons for that in both cases, but I suspect this is one of the small details I‚Äôll miss the most in Rust. I‚Äôve been spoiled by Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs &lt;code&gt;Array&lt;/code&gt; type is analogous to Rust‚Äôs &lt;code&gt;Vec&lt;/code&gt; type (usually created with the &lt;code&gt;vec!&lt;/code&gt; macro), &lt;em&gt;not&lt;/em&gt; its &lt;code&gt;Array&lt;/code&gt; type. Rust &lt;code&gt;Vec&lt;/code&gt;s and Swift &lt;code&gt;Array&lt;/code&gt;s are dynamically sized and created on the heap, whereas Rust‚Äôs &lt;code&gt;Array&lt;/code&gt;s are statically sized and created on the stack. Syntax for creating &lt;code&gt;Array&lt;/code&gt;s in both languages is quite similar (though the results are different):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array: [Int] = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array: [i32, 3] = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That‚Äôs the long form, of course; both languages have type inference, so you‚Äôd rarely write it like that. The usual form would be with the type in all of those cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust also adds the concept of ‚Äúslices,‚Äù which provide access to segments of arrays, and are heap-allocated as pointers to a given item in the array and a length (number of elements) included.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; operations in Swift are all pretty reasonable, and surprisingly descriptive. They remind me in a good way of Python‚Äôs &lt;code&gt;list&lt;/code&gt; methods.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are a &lt;em&gt;lot&lt;/em&gt; of &lt;a href="http://doc.rust-lang.org/stable/std/vec/struct.Vec.html"&gt;ways to interact with &lt;code&gt;Vec&lt;/code&gt;s in Rust&lt;/a&gt;. (That‚Äôs not a bad thing.) A bit surprising to me was the absence of an &lt;code&gt;enumerate&lt;/code&gt; method, on &lt;code&gt;Vec&lt;/code&gt; itself, but then I discovered that it exists in the &lt;code&gt;IntoIter&lt;/code&gt; struct in the same module, which fully implements the &lt;code&gt;Iterator&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;. As a result, it has an &lt;code&gt;enumerate&lt;/code&gt; function returning an &lt;code&gt;Enumerate&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; instance. (Under the covers, I suspect Swift &lt;code&gt;Array&lt;/code&gt;s just implement an &lt;code&gt;Iterable&lt;/code&gt; &lt;code&gt;protocol&lt;/code&gt;, which is similar to this approach in some ways.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This makes a point I‚Äôm coming back to fairly often: Rust doesn‚Äôt necessarily put everything on a single object definition, but rather into a set of related &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; types and &lt;code&gt;trait&lt;/code&gt;s. This is really powerful, but it‚Äôs going to take some mental adjustment. In this way, Swift‚Äôs structure and semantics are much more like the languages I‚Äôm used to than Rust‚Äôs are (but even there, the use of &lt;code&gt;protocols&lt;/code&gt; gives it considerable new flexibility).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Note that I said &lt;em&gt;semantics&lt;/em&gt;, not syntax. Swift and Rust are a great example of how very similar syntax can mask differences in semantics. (For another such example, compare JavaScript‚Äôs syntax and semantics to Java‚Äôs: they‚Äôre superficially similar syntactically, and light years apart semantically.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs &lt;code&gt;Set&lt;/code&gt; type and Rust‚Äôs roughly analogous &lt;code&gt;HashSet&lt;/code&gt; both have a &lt;code&gt;contains&lt;/code&gt; method which behaves much like Python‚Äôs &lt;code&gt;in&lt;/code&gt; keyword. Indeed, and perhaps unsurprisingly, the two types implement many of the same methods in general. This is perhaps to be expected given that the language around sets (as a mathematical concept being mapped down into a representation in a program) is quite standardized.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because of their stricter typing systems, both Rust and Swift require you to specify the types used in their mapping constructs (Rust has &lt;code&gt;HashMap&lt;/code&gt; and Swift has &lt;code&gt;Dictionary&lt;/code&gt;), though of course both can infer this as well in certain cases. At the most basic level, you can‚Äôt use arbitrary (hashable) types as keys in mixed fashion like you can in e.g.¬†Python‚Äôs &lt;code&gt;dict&lt;/code&gt; type, but in practice this shouldn‚Äôt matter, for two reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It‚Äôs generally inadvisable to use different types for keys in the same dictionary anyway. To me, at least, that usually indicates the need to step back and think more carefully about the types and data structures I‚Äôm using.&lt;/li&gt;
&lt;li&gt;For the occasional case where it &lt;em&gt;is&lt;/em&gt; appropriate, I wonder if you could declare the type as generic in either Rust or Swift. I‚Äôm putting this down as a TODO item for myself to find out!&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I really wish that Swift used the Python-style curly-brace delimited syntax (&lt;code&gt;{'key': 'value'}&lt;/code&gt;) for its dictionary literal initializers. I can see, from a syntax reason, why it doesn‚Äôt: that would overload the block syntax (which Python can avoid because it‚Äôs white-space delimited). But it‚Äôs &lt;em&gt;really&lt;/em&gt; convenient.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Along similar lines, I can see why the Swift designers chose to make all iterables have literal initializers using braces (&lt;code&gt;[...]&lt;/code&gt;); it makes parsing fairly straightforward. However, the result is that it‚Äôs pretty difficult to see at first glance what you‚Äôre dealing with. It could quite easily be an &lt;code&gt;Array&lt;/code&gt;, a &lt;code&gt;Set&lt;/code&gt;, or a &lt;code&gt;Dictionary&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This highlights a too-little-appreciated aspect of programming language design: &lt;em&gt;readability&lt;/em&gt;. However much we programmers enjoy writing code, the reality is that we will all spend a great deal of our time‚Äîprobably even a majority of it‚Äîreading it instead. Thus, while we should care about conveniences for writing code, and being overly verbose can be a pain, we should also concern ourselves with the ease of comprehending code when it is read, and the syntax and conventions a language embraces are a big part of this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;Dictionary&lt;/code&gt; type in Swift is a pretty close analog to Python‚Äôs &lt;code&gt;dict&lt;/code&gt;, right down to several of the method names. the same is true of Rust‚Äôs &lt;code&gt;HashMap&lt;/code&gt;. That‚Äôs not a bad thing by any stretch of the imagination.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;Previous: The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Next: Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 Sep 2015 09:00:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-19:2015/rust-and-swift-vi.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (iv)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Both Swift and Rust directly address the issue of having to worry about memory allocation and safety. They do it in different ways, though: Swift by automatic reference counting, Rust by its concept of ownership. For a lot of day-to-day development, I can see the Swift approach being a win for the same reason a language like Python or Ruby is: having that all handled for you is &lt;em&gt;nice&lt;/em&gt;. Having the power Rust gives you comes at the price of increased cognitive load from having to reason about ownership.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To put it another way: all programming languages have to make trade offs. Although I like Rust‚Äôs better than Swift‚Äôs so far, I‚Äôve no doubt I will find any number of things to appreciate about Swift over Rust. You can‚Äôt have everything.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This caught my attention in part because dealing with things like strings (or other pass-by-value types) in Swift is rather more straightforward than in Rust. The outcomes are much the same, but since &lt;em&gt;all&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s in Swift are passed by value (never by reference), you simply don‚Äôt have to think about modification‚Äîeven safe modification!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust of course had the &lt;code&gt;Copy&lt;/code&gt; trait which lets you do this, but the point is that the ‚Äúergonomics‚Äù are slightly nicer in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Also, the string interpolation Swift does is &lt;em&gt;nice&lt;/em&gt;. That‚Äôs one thing I really wish Rust had. It‚Äôs Python-style string formatting macro is great, but being able to interpolate values (&lt;code&gt;&amp;quot;strings with \(variables)&amp;quot;&lt;/code&gt; or even &lt;code&gt;&amp;quot;embedded expressions like \(2 + 4)&amp;quot;&lt;/code&gt;) is very nice.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs approach to strings in general seems well-thought-through and gives appropriate levels of attention to the details which make handling complex or non-Western languages much more manageable. As a typography geek, I appreciate this a great deal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That said, since Swift‚Äôs strings &lt;em&gt;do&lt;/em&gt; handle all those edge cases for Unicode, you lose some standard string access patterns and lose much (maybe all?) insight into the internal structure of the string. That may be good, and may be bad, depending on the circumstance. Like I said: trade-offs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Actually, on reading further, the way Swift handles Unicode strings is pretty nice. It &lt;em&gt;does&lt;/em&gt; give you insight into those, via specific methods for different representations. I particularly appreciate that it‚Äôs you deal with them as the standalone &lt;code&gt;String&lt;/code&gt; type as well as giving you direct access to the code points‚Äîand not just one Unicode code point set, but any of &lt;abbr&gt;UTF8&lt;/abbr&gt;, &lt;abbr&gt;UTF16&lt;/abbr&gt;, or &lt;abbr&gt;UTF32&lt;/abbr&gt; (Unicode scalars). Trust Apple to pay close attention to text.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust‚Äôs strings are &lt;em&gt;good&lt;/em&gt;, but not quite as sophisticated (presumably for simplicity around the memory mapping). All Rust &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;str&lt;/code&gt; instances are composed of &lt;abbr&gt;UTF32&lt;/abbr&gt; Unicode scalars, encoded as &lt;abbr&gt;UTF8&lt;/abbr&gt; sequences. It doesn‚Äôt have some of the convenience methods Swift does for getting any of the other representations. That said, I expect this should show up rarely if at all in my ordinary usage. Importantly, the fundamental storage is the same: both use scalars.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was the first section where it didn‚Äôt feel like Rust was just a clear overall ‚Äúwinner‚Äù over Swift. Some of the trade offs between the language designs are more apparent here, and I do appreciate the ‚Äúergonomics‚Äù of Swift in a number of these things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Previous: Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;Next: The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Sep 2015 21:05:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-10:2015/rust-and-swift-iv.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (iii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Operators, including overloading, and thoughts on brevity.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I just hit operators in the Swift book. First question: are operators special syntax, or are they sugar for &lt;code&gt;protocol&lt;/code&gt;s? (Every modern language I use or even have played with handles them as sugar for another language construct‚ÄîPython, Ruby, Io, Elixir, and Rust, to name just a few ranging over a substantial variety of ages and styles.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Oh. I did the requisite digging, and operators are functions (which is okay) defined in the global namespace (&lt;em&gt;:sigh:&lt;/em&gt;). I say ‚Äúokay‚Äù rather than good because the justification offered is that this is the only way to make the operators work as binary operators between existing instances of types. But that elides the fact that, if that‚Äôs the case, it is so because of other language design decisions. This seems like a perfect place to use a &lt;code&gt;protocol&lt;/code&gt;, but perhaps (unlike Rust‚Äôs &lt;code&gt;trait&lt;/code&gt;) they‚Äôre not sufficiently capable to handle this? That‚Äôs an open question; I have no idea about the answer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interestingly, Rust has several fewer operators than Swift, even apart from those mentioned in my &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;previous post&lt;/a&gt;. It drops the pre- and post-increment operators entirely (as does Python), since their results can always be accomplished in other ways with less potential for confusion. Swift keeps them, no doubt in part because most (Objective) C programs are deeply familiar with them and with idioms associated with them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I learned a few new things about Rust‚Äôs operators as well: the Boolean &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators and its bit wise &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operators differ not only in that the former are &lt;em&gt;short-circuit&lt;/em&gt; operators and the latter are not. Obviously you can also do things like bit-wise flag operations with the latter, but the reference emphasizes the short-circuiting behavior. This makes perfect sense, but it wasn‚Äôt something I‚Äôd ever considered explicitly before.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is no ternary operator in Rust, because of how it handles the relationship between expressions and statements. Swift keeps it. That‚Äôs an interesting reflection of differences in design: Rust dropped it because &lt;code&gt;if&lt;/code&gt; blocks are expressions, so it‚Äôs redundant, and they have had a goal of removing unnecessary features. (See the discussion on dropping the ternary operator‚Äîwith an interesting aside from Brendan Eich on JavaScript‚Äî&lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;here&lt;/a&gt;). Note that this is not a criticism of Swift, just an observation, though I do really like Rust‚Äôs expression-driven approach.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; ‚Äúnil coalescing operator‚Äù, on the other hand, I actively dislike. This seems like shorthand for the sake of shorthand, partly necessitated by the existing drive toward shorthand with optional types in Swift. Sometimes brevity can lead to decreased clarity. Eliding too much, or subsuming it into shorthand, makes the language harder to hold in your head and requires you to slow down more for parsing each line.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nothing surprising (or different) between the standard boolean operators in the two languages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I wonder how many times the word ‚Äúconcise‚Äù (or synonyms of it) appear in the Swift book? It‚Äôs increasingly clear to me reading that brevity is one of the primary design goals. Maybe it‚Äôs just me, but that actually seems a little weird. Brevity is good so far as it goes, but &lt;em&gt;legibility&lt;/em&gt; is much better.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Previous: Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Next: Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 11:55:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-07:2015/rust-and-swift-iii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (ii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Basic types and the syntax around them.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;At first blush, I find the extra syntax around optionals in Swift more confusing than helpful. I think this comes down to my preference for a more Python-like approach: ‚ÄúExplicit is better than implicit‚Äù and ‚ÄúThere should be one‚Äì and preferably only one ‚Äìobvious way to do it‚Äù both militate against the multiple different ways you can handle optional values in Swift. Optional types are created in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with the &lt;code&gt;?&lt;/code&gt; operator on a type definition, creating an explicitly wrapped type which must be checked in some way.&lt;/li&gt;
&lt;li&gt;with the &lt;code&gt;!&lt;/code&gt; operator on a type definition, creating an ‚Äúimplicitly unwrapped optional‚Äù by forcibly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After creating an optional, you can get at its contents by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;while let&lt;/code&gt; constructs to bind the optional value‚Äôs non-&lt;code&gt;nil&lt;/code&gt; value for a block&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;!&lt;/code&gt; operator on a variable name, explicitly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By contrast, in Rust you always have to explicitly unwrap the item, using the &lt;code&gt;unwrap&lt;/code&gt; method or pattern matching. There are no implicitly unwrapped types. Moreover, there is no special syntax around creating optional types in Rust: you just declare them with an &lt;code&gt;Option&lt;/code&gt; type or another type that &lt;code&gt;impl&lt;/code&gt;s the &lt;code&gt;Option&lt;/code&gt; behavior. The ‚Äúshortcut‚Äù behavior around error handling, &lt;code&gt;try!&lt;/code&gt;, isn‚Äôt special syntax, but application of another standard language construct (in this case, a macro).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The discussion of &lt;code&gt;assert&lt;/code&gt; in the Swift book re-raises the question about the global namespace:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ÄúYou write an assertion by calling the global &lt;code&gt;assert(_:_:)&lt;/code&gt; function.‚Äù&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This continues to suggest strongly that Swift does in fact have a true global namespace, &lt;em&gt;not&lt;/em&gt; an automatically-imported prelude. That can make a big difference for applications in certain spaces (e.g.¬†systems programming), when you might have good reason to want to replace the standard library‚Äôs approach with a different one. (See Rust‚Äôs &lt;a href="https://doc.rust-lang.org/book/no-stdlib.html"&gt;&lt;code&gt;#[no_std]&lt;/code&gt;&lt;/a&gt; docs and the &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md"&gt;related RFC&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In Rust, &lt;code&gt;assert!&lt;/code&gt; is a macro, not a function, which is an interesting but perhaps not &lt;em&gt;especially&lt;/em&gt; important distinction in this particular case. (It might be, though; I‚Äôd have to see the implementation of each to see how they play out differently.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, this also highlights another large difference between the two: testing is &lt;a href="https://doc.rust-lang.org/stable/book/testing.html"&gt;front and center&lt;/a&gt; in Rust, and barely receives a mention so far in the Swift book (and isn‚Äôt in the table of contents). Having language-level support for testing is a big deal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Language tour and first chapter of the language guide down, my sense is that Swift is a substantially better language than C or C++ (and presumably than Objective C, but since I don‚Äôt know that language I can‚Äôt speak to it) for app design, but that Rust is a better language yet. Both a far more modern than their predecessors, but they approach the same problems in surprisingly different ways, relatively similar syntax notwithstanding. So far, I like the Rust approach better.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In particular, more syntax is not my preferred way to tackle these things. Providing good language constructs and primitives on which to build seems better in &lt;em&gt;many&lt;/em&gt; ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It substantially reduces the cognitive load for the developer, by keeping the number of constructs small and simply varying how they are applied.&lt;/li&gt;
&lt;li&gt;It increases the quality of those primitives, because it forces the language deadness to make sure they actually address the full problem space.&lt;/li&gt;
&lt;li&gt;It lets developers approach the same problem in ways the language design team may not have anticipated, and over time the community may find shared conventions that improve on the &lt;code&gt;std&lt;/code&gt; approach, and nothing has to change in the language spec (or the compiler!) to adopt those changes.&lt;/li&gt;
&lt;li&gt;In general, then, it makes change much easier to manage, and change can be community-driven rather than requiring the language design team to manage it.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-i.html"&gt;Next: Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Previous: Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This may of course be intentional on Apple‚Äôs part with Swift. Maintaining tight control over its tooling is very typical of modern Apple.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Sep 2015 10:20:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-06:2015/rust-and-swift-ii.html</guid><category>software development</category><category>listicles</category></item><item><title>Rust and Swift (i)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-i.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I started writing these responses in a Slack channel of developers I participate in as I worked through the &lt;a href="https://developer.apple.com/swift/"&gt;Swift&lt;/a&gt; &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/"&gt;book&lt;/a&gt;. I realized after a bit that it would make a better blog post than chat room content, so here we are. This is all entirely off-the-cuff: me just thinking out loud as I read; this is by no means expert opinion.&lt;/i&gt;&lt;/p&gt;
&lt;section id="parts-in-the-series" class="level2"&gt;
&lt;h2&gt;Parts in the Series&lt;/h2&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Thoughts after reading the introduction to the Swift book.&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iii.html"&gt;Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-iv.html"&gt;Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-v.html"&gt;The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vi.html"&gt;Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-vii.html"&gt;Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-viii.html"&gt;Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ix.html"&gt;Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-x.html"&gt;Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;..&amp;lt;&lt;/code&gt; ‚Äì seriously?&lt;/p&gt;
&lt;p&gt;That has to be one of the most annoying operators I‚Äôve ever seen. It ends up with cognitive noise because &lt;code&gt;&amp;lt;name&lt;/code&gt; initially processes as ‚Äústarting a generic‚Äù and you have to re-parse it visually and mentally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the first chapter of the Swift book, my impression is ‚Äúa poor man‚Äôs Rust‚Äù; my gut feel based on that first pass and everything I‚Äôve seen and read about Swift over the past two years is that it‚Äôs roughly what you would get if you took Rust‚Äôs syntax and replaced Rust‚Äôs hard safety goals with the aim of mapping to ObjC semantics. (To be fair to Apple, that interoperability was probably necessary.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An example that jumps out at me as immediately illustrative of the difference in approach the languages take is the way you pass structures by reference vs.¬†copy. In Swift, that‚Äôs done via two completely distinct language constructs, &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es respectively.&lt;/p&gt;
&lt;p&gt;In Rust, there is just the &lt;code&gt;struct&lt;/code&gt; type to handle both of those. They‚Äôre immutable unless you declare them with &lt;code&gt;mut&lt;/code&gt;, and you can pass them via copy simply by implementing the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt; (which seems roughly analogous to Swift‚Äôs &lt;code&gt;protocol&lt;/code&gt;, but I‚Äôve not yet dig deeply enough to see how they differ). Those things aren‚Äôt baked into the language, but use simpler language building blocks to define behavior into he library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I saw someone do a write up a while back arguing that Go isn‚Äôt a &lt;em&gt;bad&lt;/em&gt; language, it just isn‚Äôt a &lt;em&gt;good&lt;/em&gt; language. My first impression of Swift, after having spent the last month with Rust, is very much along those lines.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Huh. Here‚Äôs something that I appreciate about Rust, Haskell, and others now that I didn‚Äôt before: there‚Äôs a difference between implicitly/automatically importing a prelude or a given set of standard library functions, and having actually global functions. Does Swift actually have functions like &lt;code&gt;print&lt;/code&gt; in a global namespace, as the book seems to imply, or they being imported automatically &lt;em&gt;a la&lt;/em&gt; Rust/Haskell/etc.?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; it appears Swift does likewise, but that you can‚Äôt access the relevant module directly. Which is halfway there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hmm. Why have &lt;code&gt;Double&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;Float&lt;/code&gt;‚Äîjust for ObjC interop, I guess?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; follow-up from a conversation with a friend: it‚Äôs because you have 32- and 64-bit architectures out there; sometimes you don‚Äôt want 64 bits of floating point precision for that reason. Note that Rust &lt;em&gt;also&lt;/em&gt; has this distinction; you can declare things as &lt;code&gt;f32&lt;/code&gt; or &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending the above note on &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;protocol&lt;/code&gt;s vs.¬†Rust‚Äôs approach: the same thing is true about &lt;code&gt;extension&lt;/code&gt;, which is a distinct concept from implementing a &lt;code&gt;protocol&lt;/code&gt;; again, in Rust these are both just handled with a single language construct, &lt;code&gt;impl&lt;/code&gt;. That‚Äôs not because &lt;code&gt;impl&lt;/code&gt; is overloaded, but rather because the underlying language machinery is the same for the two things. (edited)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(I‚Äôve a feeling learning Swift is going to turn me into even more of a Rust fanboy.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reading the two books in close sequence like this is proving really productive mentally for thinking about how the two handle the same issues. I‚Äôve never done anything quite like this before, and it‚Äôs fascinating.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have an increased appreciation for Rust‚Äôs use of semi-colons to turn expressions into statements, and thereby to distinguish clearly between the two (among other things, allowing for implicit return of anything that‚Äôs an expression).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another interesting comparison: Rust‚Äôs &lt;code&gt;match&lt;/code&gt; and Swift‚Äôs &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; fill the same role of pattern matching. I‚Äôm curious to see how they differ. Does Swift do matching on arbitrary expressions?&lt;/p&gt;
&lt;p&gt;Also, I see where the syntax choices came from in both, and while I slightly prefer Rust‚Äôs, I think both make reasonably good sense; Swift‚Äôs will understandably be more familiar to C and ObjC programmers, and that‚Äôs a perfectly defensible approach. Seen that way, it is expanding on the C-style construct (even if it‚Äôs actually doing something substantially more sophisticated than that under the hood by being a form of actual pattern matching).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2015/rust-and-swift-ii.html"&gt;Next: Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 13:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-04:2015/rust-and-swift-i.html</guid><category>listicles</category><category>software development</category></item><item><title>Corporate and Government Surveillance</title><link>http://www.chriskrycho.com/2015/corporate-and-government-surveillance.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;&lt;a href="https://witheredgrass.wordpress.com/"&gt;Brian Auten&lt;/a&gt; shared &lt;a href="http://www.lawfareblog.com/2015/06/why-americans-hate-government-surveillance-but-tolerate-corporate-data-aggregators/"&gt;this speech&lt;/a&gt; by Sen.¬†Sheldon Whitehouse on Facebook, and I wrote up what follows in response.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;I broadly agree with the critique of the libertarian/TP angle on government as essentially an appendage to business. I am &lt;em&gt;by no means&lt;/em&gt; hostile to the government in general or in principle, nor even to &lt;em&gt;spying&lt;/em&gt;, nor even to warranted (double entendre intended) use of data for law enforcement. The idea that all government is bad is woefully incorrect; it is better to speak of &lt;em&gt;abuses&lt;/em&gt;, either of government or of business or indeed of any sphere exceeding its right domain or acting inappropriately within its domain.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is a profound and important difference between corporate data collection and federal government data collection: one of them, people accede to directly (though see below); the other they accede to (at best!) indirectly through elected representatives, with whom they may profoundly disagree and against whom they have no recourse (unlike the case of, say, Google or Facebook‚Äîone &lt;em&gt;can&lt;/em&gt; simply stop dealing with them). Whatever information I have granted to a corporation, I have chosen to grant them, and I can stop doing so with future information at any time. I &lt;em&gt;cannot&lt;/em&gt; do so with the NSA, FBI, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That distinction may be relatively meaningless for most people in practice, given that the terms, means, and consequences of the data collection carried about by corporations are often obscure to the point of incomprehensibility.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As such, a serious reformation ought to occur in the realm of business and the way that people‚Äôs information is handled. Treating information about customers as the primary point of transactional value has significantly deleterious costs on any number of things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For this reason, I consistently advocate for and (where possible) choose to use services which are supported by direct payment, rather than by advertising, and so on. This is not always possible, but where it is, we should consider taking that path.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nonetheless, because of the government‚Äôs power of coercion‚Äîa power not held by corporations, though to be sure they can exercise significant force of a certain sort through legal machinery/chicanery‚Äîthe collection of metadata by the government does pose a more potent and long-term threat to liberty than that by corporations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As such, people are &lt;em&gt;absolutely right&lt;/em&gt; to be more tolerant of corporate data collection than of federal data collection. That they ought to be less tolerant of corporate data collection by no means suggests that their hostility to unwarranted governmental data collection should be diminished: quite the contrary.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Therefore, while some of the criticism of the government‚Äôs data collection may well be driven by the sorts of corporate interests he suggests, and while much of the opposition from companies like Facebook and Google is indeed hypocritical, the criticism is still warranted. The NSA has clearly and repeatedly overstepped even the extremely wide bounds granted it by the Patriot Act, and the Patriot Act itself licensed behavior that should be horrifying to people concerned with the long-term effects of mass surveillance on governance.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 02 Jun 2015 22:43:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-06-02:2015/corporate-and-government-surveillance.html</guid><category>listicles</category></item><item><title>Public-ish Plans</title><link>http://www.chriskrycho.com/2015/public-ish-plans.html</link><description>&lt;p&gt;I have not (yet) made a formal list of goals for 2015, though I think I may do so on Sunday evening. While New Years‚Äô resolutions can be silly and get us in trouble (when we set unrealistic goals, or unhelpful goals), the turning of the year can also be a helpful time to evaluate the way we spend our time and the things we want to accomplish.&lt;/p&gt;
&lt;p&gt;What follows is a list of public-ish things I am &lt;em&gt;hoping&lt;/em&gt; to manage in 2015, in no particular order. Come the end of the year, I will Lord willing look back and see which of these I was able to pull off!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Publish at least two seasons of &lt;a href="//www.winningslowly.org"&gt;Winning Slowly&lt;/a&gt; with &lt;a href="//stephencarradini.com"&gt;Stephen Carradini&lt;/a&gt; just as we did last year‚Äîbut better.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Get the site for Winning Slowly updated so that it paginates between seasons! This means writing an extension for &lt;a href="//docs.getpelican.com/en/3.5.0/"&gt;Pelican&lt;/a&gt; that can paginate on something besides page count. An excuse to write Python? I call that winning.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Migrate Jaimie‚Äôs &lt;a href="//jaimiekrycho.com"&gt;Jaimie‚Äôs professional writing website&lt;/a&gt; from WordPress to &lt;a href="//ghost.org"&gt;Ghost&lt;/a&gt;. (Maybe do something similar with her current &lt;a href="//jaimiedawn.blogspot.com"&gt;personal site&lt;/a&gt;, which runs on Blogger. Yuck.) I‚Äôve gotten a bit of a start on that already, and I hope to knock it out sooner rather than later.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Get to a point where I‚Äôm hosting all my own sites on my own DigitalOcean droplet (or similar). I‚Äôve been moving that direction slowly but steadily anyway‚Äîwhereas I started and ran for a long time on simple shared hosting, I‚Äôve been using &lt;a href="https://www.webfaction.com/?aid=67929"&gt;Webfaction&lt;/a&gt; for a good chunk of the past year, and now am pretty well ready to take the plunge this year into just running my own server. No skin off their backs; Webfaction has been great, as was &lt;a href="https://billing.stablehost.com/aff.php?aff=319"&gt;StableHost&lt;/a&gt; before them. I‚Äôm just ready to be in control (even with the bit of extra maintenance that entails).&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write at least three minutes of music, and post it to my &lt;a href="//soundcloud.com/chriskrycho"&gt;SoundCloud&lt;/a&gt; account. Preferably five minutes, but at least three.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write some poetry.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a substantive essay and post it at least once a month.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Post at least a half dozen book reviews (which, among other things, means reading at least a half dozen books worth reviewing). These can be fiction or non-fiction. Personally, I‚Äôd like to get everything from Dostoevsky to Schreiner in there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add a picture to my &lt;a href="/about"&gt;About&lt;/a&gt; page!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Post a &lt;a href="/family"&gt;#family&lt;/a&gt; update at least once a month. It‚Äôll be good for &lt;em&gt;me&lt;/em&gt;, just to have a better way of tracking what‚Äôs going on with our little gals, and I know my family would enjoy it, too.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In sum, I‚Äôd like to be doing &lt;em&gt;something&lt;/em&gt; in nearly every public-facing category in which I‚Äôm interested. Maybe it won‚Äôt be a lot, but keeping my musical skills doing matters to me. Keeping my brain engaged on a wide variety of topics matters to me. Keeping my writing skills sharp matters to me. I cannot &lt;em&gt;excel&lt;/em&gt; at all of those things, certainly‚Äîespecially not if I wish to be a good husband and father! But keeping them active means keeping them from further atrophying, and that is something, at least. It will hopefully leave them more available to me for times in the future when I am able to dedicate more time to them.&lt;/p&gt;
&lt;p&gt;If 2014 and 2013 were both years in which I focused primarily on software‚Äîand all to the good!‚Äîthen I hope 2015 will be a year in which I am able to broaden out again and focus on a wider variety of things!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You‚Äôll note that there really aren‚Äôt any purely personal goals on this list. Not to worry: I have them, and I intend to formalize them in the next couple of days. But one of the things I have learned over the many years I have been blogging is that not everything needs to be public. Some things can be; indeed, some &lt;em&gt;should&lt;/em&gt; be. Some things &lt;em&gt;may&lt;/em&gt; be public but &lt;em&gt;need&lt;/em&gt; not, and yet others &lt;em&gt;should not&lt;/em&gt; be public. Right now, I am choosing to leave quite a few things in the ‚Äúmay be need not‚Äù category private. (This direction, I can always change my mind later. It‚Äôs essentially impossible to do the opposite in the internet era.)&lt;/p&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;em&gt;Slowly&lt;/em&gt;. Beat you to it.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Note: those are both affiliate links; they‚Äôll give me a slight kickback. For StableHost, you should also use the code &lt;code&gt;krycho50percent&lt;/code&gt; to get 50% off! I‚Äôd love it if you used it if you decide to sign up for either of them.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 02 Jan 2015 20:15:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-01-02:2015/public-ish-plans.html</guid><category>listicles</category></item><item><title>A Few Theses on Blogging</title><link>http://www.chriskrycho.com/2014/a-few-theses-on-blogging.html</link><description>&lt;p&gt;I am a habitually‚Äîeven chronically‚Äîlong-winded blogger. I always have been. I sat down a few weeks ago to write up an explanation of my running approach, and I haven‚Äôt finished it yet‚Ä¶ because it is over 2,500 words long and growing rapidly longer. But as I have considered my approach to blogging of late, and as I have also been posting fairly regularly on App.net (my social media locale of choice), it occurred to me:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Blog posts do not have to be the lengthy things I usually make of them.&lt;/li&gt;
&lt;li&gt;I often write up a series of thoughts‚Äînot necessarily an ‚Äúargument‚Äù or indeed anything more than a series of connected thoughts‚Äîon App.net, connecting them via the ‚Äòreply‚Äô mechanism and enumerating them. Rather like I am here.&lt;/li&gt;
&lt;li&gt;Doing so inevitably clutters up the streams of anyone following me.&lt;/li&gt;
&lt;li&gt;That clutter may or may not be problematic: some folks may enjoy those connected thoughts. Others may not.&lt;/li&gt;
&lt;li&gt;For those that &lt;em&gt;do&lt;/em&gt; enjoy those connected thoughts, a blog post like this would probably serve just as well.&lt;/li&gt;
&lt;li&gt;For those who do &lt;em&gt;not&lt;/em&gt; enjoy them‚Ä¶ well, this sort of thing would be a welcome way to clear their streams up without causing me any particular difficulty.&lt;/li&gt;
&lt;li&gt;Using lists does not automatically mean I have given in to the constant temptation to make my blogging about driving views.&lt;/li&gt;
&lt;li&gt;Seriously.&lt;/li&gt;
&lt;li&gt;This blog will &lt;em&gt;never&lt;/em&gt; drive substantial amounts of traffic. That is fine by me. Indeed, I would probably feel a bit odd if it did.&lt;/li&gt;
&lt;li&gt;Therefore, when I have those sorts of thoughts-in-a-line in the future, I will do as I have done here. I will write a ‚Äòlisticle‚Äô (the shame!) and share it for others to partake of‚Äîor not!‚Äîas they please.&lt;/li&gt;
&lt;li&gt;Taking that approach will almost certainly free me up to blog more briefly when I feel like it, as well. That, too, can only be a good thing.&lt;/li&gt;
&lt;li&gt;After all: I am happier when I am writing.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;As I have so often &lt;a href="http://www.chriskrycho.com/2014/the-long-race.html"&gt;noted before&lt;/a&gt;‚Ä¶&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 09 Jul 2014 21:15:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2014-07-09:2014/a-few-theses-on-blogging.html</guid><category>listicles</category></item></channel></rss>