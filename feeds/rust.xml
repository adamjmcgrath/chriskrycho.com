<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Krycho</title><link>http://www.chriskrycho.com/</link><description></description><atom:link href="http://www.chriskrycho.com/feeds/rust.xml" rel="self"></atom:link><lastBuildDate>Thu, 28 Apr 2016 08:24:00 -0400</lastBuildDate><item><title>2016-04-28 08:24</title><link>http://www.chriskrycho.com/2016/2016-04-28-0824.html</link><description>&lt;p&gt;&lt;a href="http://www.chriskrycho.com/2016/2016-04-28-0755.html"&gt;Also&lt;/a&gt;, I keep forgetting how incredible &lt;a href="https://play.rust-lang.org" class="uri"&gt;https://play.rust-lang.org&lt;/a&gt; is. Built-in ability to view not only the result of the code, but also the new mid-level intermediate representation (MIR), the LLVM IR, and the assembly? Amazing.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 28 Apr 2016 08:24:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-04-28:2016/2016-04-28-0824.html</guid><category>programming languages</category><category>rust</category></item><item><title>2016-04-28 07:55</title><link>http://www.chriskrycho.com/2016/2016-04-28-0755.html</link><description>&lt;p&gt;&lt;a href="http://blog.rust-lang.org/2016/04/19/MIR.html"&gt;This blog post&lt;/a&gt; on recent compiler work in Rust is incredible: great work, and great technical writing. üíô Rust.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 28 Apr 2016 07:55:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-04-28:2016/2016-04-28-0755.html</guid><category>programming languages</category><category>rust</category><category>links</category></item><item><title>2016-04-23 17:07</title><link>http://www.chriskrycho.com/2016/2016-04-23-1707.html</link><description>&lt;p&gt;I‚Äôm totally working a reference to &lt;a href="http://blog.steinberg.net"&gt;Daniel Spreadbury&lt;/a&gt;‚Äôs &lt;a href="http://www.smufl.org"&gt;SMuFL&lt;/a&gt; work into a discussion of Rust‚Äôs Unicode support in &lt;a href="//www.newrustacean.com"&gt;New Rustacean&lt;/a&gt; e014.&lt;/p&gt;
&lt;p&gt;(This has to be the nerdiest thing I‚Äôve ever done. Even in context, this is over the top.)&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 23 Apr 2016 17:07:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-04-23:2016/2016-04-23-1707.html</guid><category>podcasting</category><category>typography</category><category>music</category><category>Rust</category></item><item><title>2016-04-07 08:45</title><link>http://www.chriskrycho.com/2016/2016-04-07-0845.html</link><description>&lt;p&gt;I üíô the Rust team. So much.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rust-lang/rust/pull/32756" title="Overhaul borrowck error messages and compiler error formatting generally"&gt;This is just fantastic.&lt;/a&gt;&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 07 Apr 2016 08:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-04-07:2016/2016-04-07-0845.html</guid><category>programming languages</category><category>rust</category></item><item><title>2016-03-19 16:15</title><link>http://www.chriskrycho.com/2016/2016-03-19-1615.html</link><description>&lt;p&gt;Well, paper-writing today may have pushed me to the breaking point. An app idea that‚Äôs been bubbling for months‚Ä¶ I think I‚Äôm going to start actually building pieces of it and learning for other bits this week.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 Mar 2016 16:15:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-03-19:2016/2016-03-19-1615.html</guid><category>software development</category><category>swift</category><category>rust</category></item><item><title>2016-03-15 08:05</title><link>http://www.chriskrycho.com/2016/2016-03-15-0805.html</link><description>&lt;p&gt;I was reading some C++ yesterday, and I can‚Äôt put my finger on what it is about the language, but I just find it unbearably &lt;em&gt;ugly&lt;/em&gt;. Rust‚Äôs syntax isn‚Äôt that different, but I don‚Äôt have the same visceral reaction. I wonder why that is?&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 15 Mar 2016 08:05:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2016-03-15:2016/2016-03-15-0805.html</guid><category>programming languages</category><category>cplusplus</category><category>rust</category></item><item><title>Rust and Swift (xv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The next chapter in the Swift book focuses on &lt;em&gt;inheritance&lt;/em&gt;, a concept which does not yet exist in Rust.&lt;/p&gt;
&lt;p&gt;Swift embraces classical inheritance for &lt;code&gt;class&lt;/code&gt; data types. As noted &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;previously&lt;/a&gt;, Rust‚Äôs &lt;code&gt;struct&lt;/code&gt; covers much of the ground covered by Swift‚Äôs &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types together (value and reference types, etc.). However, what Swift‚Äôs &lt;code&gt;class&lt;/code&gt; types bring to the table is inheritance-based (and not just composition-based) extension of types.&lt;/p&gt;
&lt;p&gt;This is a bit of an interesting point: it is an area where, &lt;em&gt;as of today&lt;/em&gt;, Swift can do something that is flat impossible in Rust‚Äîa rarity.&lt;/p&gt;
&lt;p&gt;However, the &lt;em&gt;status quo&lt;/em&gt; will be changing sometime in the next year or so, as there is a &lt;a href="https://github.com/rust-lang/rfcs/pull/1210"&gt;Rust RFC&lt;/a&gt; which has been accepted and is in the process of being implemented which paves the way for inheritance. (Discussions are &lt;a href="https://aturon.github.io/blog/2015/09/18/reuse/"&gt;ongoing&lt;/a&gt; as to the best way to implement it for Rust. Classical inheritance with vtables as in Swift is probably &lt;em&gt;not&lt;/em&gt; going to be the approach.)&lt;/p&gt;
&lt;p&gt;The reason Rust‚Äôs core team chose to proceed without inheritance for the 1.0 release of the language last May is simple: at a philosophical level, they prefer (as in general most developers increasingly acknowledge that we should all prefer) composition over inheritance. &lt;em&gt;Prefer&lt;/em&gt;, not &lt;em&gt;universally choose&lt;/em&gt;, because there are situations in which inheritance is the correct choice. But there is a reason that programming with interfaces rather than via sub-classing is a ‚Äúbest practice‚Äù for many scenarios in languages like Java or C#.&lt;/p&gt;
&lt;p&gt;Rust‚Äôs &lt;code&gt;trait&lt;/code&gt; system gives you &lt;em&gt;composition&lt;/em&gt; in some remarkably powerful ways, allowing you to do things that in C++, for example, have to be accomplished via a combination of inheritance and overloading. Swift, likewise, supplies a &lt;code&gt;protocol&lt;/code&gt; system and allows extensions to define further behavior on top of existing data structures. From what I‚Äôve gathered, those approaches are preferred over inheritance in Swift for the same reason Rust shipped 1.0 without it!&lt;/p&gt;
&lt;p&gt;But Swift does have inheritance, so it‚Äôs worth seeing how it works.&lt;/p&gt;
&lt;p&gt;First, any &lt;code&gt;class&lt;/code&gt; which doesn‚Äôt declare a parent from which to inherit is a base class. This is an important difference from, say, Python, where all classes inherit from &lt;code&gt;Object&lt;/code&gt; (leaving aside custom metaclasses).&lt;/p&gt;
&lt;p&gt;The syntax choices Swift has made around sub-class declarations are sensible and readable: &lt;code&gt;class SubClass: ParentClass&lt;/code&gt; is eminently readable and doesn‚Äôt have any obvious points of overlap with other elements in the language.&lt;/p&gt;
&lt;p&gt;Indeed, &lt;em&gt;many&lt;/em&gt; of the choices made around classes are quite sensible. Overrides, for example, are made explicit via the &lt;code&gt;override&lt;/code&gt; keyword. While I‚Äôve sometimes poked fun at Swift‚Äôs tendency to add keywords everywhere, this seems like a reasonable place to have one, and it‚Äôs nice that overrides are explicit rather than implicit. The same is true of the use of &lt;code&gt;super&lt;/code&gt; to refer to the superclass. I‚Äôm not sure of the implementation details, but &lt;code&gt;super&lt;/code&gt; &lt;em&gt;appears&lt;/em&gt; to act as just a special/reserved name for an object: all the syntax around it is normal object instance syntax, which is as it should be.&lt;/p&gt;
&lt;p&gt;The limitations around overriding properties all make sense. You can override a read- or write-only parent property as both readable and writable, but you can‚Äôt override a readable or writable property &lt;em&gt;not&lt;/em&gt; to be readable or writable respectively. Presumably this is because the method lookup for properties always checks up the inheritance chain for getters or setters, so if one is present, you can‚Äôt just get rid of it. (You could of course override with a no-op function that spews a warning or some such, but that would pretty clearly be an abuse of the parent API. There might be times you would do that with a third-party library parent class, but in your own code it should be avoided: it indicates a problem in your API design that you need to address instead.)&lt;/p&gt;
&lt;p&gt;Finally, we have Swift‚Äôs &lt;code&gt;final&lt;/code&gt; keyword‚Äîand yes, pun intended. It marks whatever block-level item it is attached to‚Äîwhether class, method, or property‚Äîas non-overridable. Attempts to override an item marked final are compile-time failures. (The same kind of thing exists in Java and C#.) In and of itself, this isn‚Äôt especially interesting. It is interesting to ponder whether you should make classes subclass-able or not in your API design. There has been &lt;a href="http://mjtsai.com/blog/2015/12/21/swift-proposal-for-default-final/"&gt;an active debate&lt;/a&gt;, in fact, whether classes in Swift should become final &lt;em&gt;by default&lt;/em&gt; in Swift 3.0, rather than open by default. The debate centers on the danger of unintended consequences of overriding, which ultimately takes us back around to the preference for composition, of course.&lt;/p&gt;
&lt;p&gt;All of this, among other things, raises the very interesting question of what this will look like in Rust when, eventually, we get inheritance there. After all, we know it will be quite different in some ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It presumably won‚Äôt involve a distinct data type constructor, &lt;em&gt;a la&lt;/em&gt; Swift‚Äôs distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;: there may be syntactic sugar involved, and there will definitely be new functionality present, but it will certainly be built on the existing language features as well. There‚Äôs a good chance it will basically &lt;em&gt;look&lt;/em&gt; like just a special case of &lt;code&gt;impl SomeTrait for SomeStruct&lt;/code&gt;, which would fit very well with the ways Rust solves so many other problems.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn‚Äôt have many of the things which Swift takes care to special-case for overriding with &lt;code&gt;final&lt;/code&gt;, but it will need to address that case for inherited methods and data in some way. (The proposal linked above uses a distinction between &lt;code&gt;default&lt;/code&gt; and blanket implementations for trait specialization to pull this off; if those words don‚Äôt mean anything to you, don‚Äôt worry: I‚Äôve read that post and RFC half a dozen times before I got a really solid handle on all the pieces involved.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It will be a relative latecomer to the language, rather than baked in from the start, and therefore will likely seem a secondary way of solving problems, especially at first. (This is, I think, both intentional and good.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Indexing and subscripts, or: traits vs.¬†keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Mar 2016 14:45:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-03-12:2016/rust-and-swift-xv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (xiv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both support defining subscript access to a given data type, like &lt;code&gt;SomeType[accessedByIndex]&lt;/code&gt;. Unsurprisingly, given &lt;a href="/rust-and-swift.html"&gt;everything we‚Äôve seen so far&lt;/a&gt;, Rust does this with traits, and Swift with a keyword.&lt;/p&gt;
&lt;p&gt;In Rust, you can define subscript-style access to a type by implementing the &lt;code&gt;Index&lt;/code&gt; and/or &lt;code&gt;IndexMut&lt;/code&gt; traits, which allow &lt;em&gt;indexing&lt;/em&gt; into a given location in a kind of type. The implementation simply requires one function, which is called when you use the &lt;code&gt;[]&lt;/code&gt; operator. That function, &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;index_mut&lt;/code&gt;, implements how to do the lookup for the specific type. The &lt;code&gt;impl&lt;/code&gt; block indicates not only that &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;IndexMut&lt;/code&gt; is being implemented, but also the type of the &lt;em&gt;key&lt;/em&gt; used: &lt;code&gt;impl Index&amp;lt;Bar&amp;gt; for Foo { ... }&lt;/code&gt;, where access would look like &lt;code&gt;a_foo[some_bar]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The two kinds of traits and corresponding methods define the behavior for immutable and mutable data type, as their name suggest.&lt;/p&gt;
&lt;p&gt;Since the trait is defined generically, you can implement whatever kinds of accessors you like to the same underlying data structure, including generics accessors with trait bounds.&lt;/p&gt;
&lt;p&gt;It is perhaps telling that in Rust you just find these traits in the general &lt;code&gt;std::ops&lt;/code&gt; module, where all the core language operations and associated operators are defined. Rust doesn‚Äôt do ‚Äúoperator overloading‚Äù so much as it simply provides operators as one more class of trait potentially applicable to your type. (The family resemblance to Haskell‚Äôs type classes and similar in other languages is obvious.)&lt;/p&gt;
&lt;p&gt;In Swift, you define indexing behavior with the &lt;code&gt;subscript&lt;/code&gt; keyword. Subscripts act very similarly to Swift‚Äôs &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;computed properties&lt;/a&gt;. They can be made read- or write-only by including or excluding &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; function definitions, just like computed properties.&lt;/p&gt;
&lt;p&gt;The behavior is in fact so closely aligned with the computed property syntax and behavior that I initially wondered if it wasn‚Äôt just a special case. It is not (though I‚Äôm sure much of the parsing machinery can be shared). As the designation of &lt;code&gt;subscript&lt;/code&gt; as a keyword strongly implies, and unlike in Rust, this is a separate language construct, not building on existing language machinery.&lt;/p&gt;
&lt;p&gt;Swift, like Rust, allows you to define arbitrary accessors. However, since the behavior relies on the &lt;code&gt;subscript&lt;/code&gt; construct rather than generics and protocols (Swift‚Äôs equivalent to Rust‚Äôs traits), you define different kinds of accessors via multiple &lt;code&gt;subscript&lt;/code&gt; blocks. (Presumably these could take generic arguments, but I haven‚Äôt tested that to be sure.)&lt;/p&gt;
&lt;p&gt;Both languages proceed to use these as ways of accessing types as makes sense‚Äîe.g.¬†for not only arrays or vectors, but also dictionaries in Swift and &lt;code&gt;HashMap&lt;/code&gt; types in Rust.&lt;/p&gt;
&lt;p&gt;Since you can define the behavior yourself, you can also use complex types as keys. The languages approach this a bit differently, though. In Rust, if you wanted a compound key, you would need to define either a simple container &lt;code&gt;struct&lt;/code&gt; or use a tuple as the argument. In Swift, because it uses the same basic syntax as computed properties, you can just define as many method arguments, of whatever type, as you want.&lt;/p&gt;
&lt;p&gt;Takeaway: Rust uses traits; Swift uses a keyword. We probably could have guessed that when we started, at this point!&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Methods, instance and otherwise.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Inheritance: a Swiftian specialty (for now).&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Mar 2016 21:25:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-03-10:2016/rust-and-swift-xiv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Static Site Generators and Podcasting</title><link>http://www.chriskrycho.com/2016/static-site-generators-and-podcasting.html</link><description>&lt;p&gt;Presently, I publish both &lt;a href="http://www.winningslowly.org/"&gt;Winning Slowly&lt;/a&gt; and &lt;a href="http://www.newrustacean.com/"&gt;New Rustacean&lt;/a&gt;&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; using what is admittedly a bit of a quirky approach. It works well for me, and I think it‚Äôs worth documenting for other nerdy types out there, but if you‚Äôre just getting going with podcasting and you‚Äôre looking for the easy way to do it, let me warn you: &lt;em&gt;this isn‚Äôt it&lt;/em&gt;. Something like &lt;a href="https://soundcloud.com/for/podcasting"&gt;SoundCloud&lt;/a&gt; and a blog for show notes, or &lt;a href="https://wordpress.org"&gt;WordPress&lt;/a&gt; with &lt;a href="https://wordpress.org/plugins/powerpress/"&gt;Blubrry PowerPress&lt;/a&gt; is what you want instead. This approach works &lt;em&gt;extremely&lt;/em&gt; well for statically-generated sites, however, and I imagine a few people out there might find it useful.&lt;/p&gt;
&lt;section id="the-short-version" class="level2"&gt;
&lt;h2&gt;The short version&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generate the feeds with &lt;a href="http://reinventedsoftware.com/feeder/"&gt;Feeder&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Generate the site statically with something else (and it &lt;em&gt;really&lt;/em&gt; doesn‚Äôt matter what).&lt;/li&gt;
&lt;li&gt;Copy the feed into the generated site.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="the-long-version" class="level2"&gt;
&lt;h2&gt;The long version&lt;/h2&gt;
&lt;p&gt;I generate the sites themselves with &lt;a href="http://docs.getpelican.com/en/3.6.3/"&gt;Pelican&lt;/a&gt; and &lt;a href="http://www.newrustacean.com/show_notes/e001/index.html"&gt;&lt;code&gt;cargo doc&lt;/code&gt;&lt;/a&gt;, respectively. I was already comfortable with Pelican because it‚Äôs what I use to generate &lt;em&gt;this&lt;/em&gt; site (with a few &lt;a href="https://github.com/chriskrycho/chriskrycho.com/blob/master/pelicanconf.py"&gt;tweaks&lt;/a&gt; to the standard configuration, especially using &lt;a href="http://pandoc.org/"&gt;Pandoc&lt;/a&gt; rather than the Python Markdown implementation), so I ran with it for building the Winning Slowly site, and it has worked quite well for building the site itself. It just gets built locally and deployed via &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, it does not have built-in support for generating &lt;a href="https://en.wikipedia.org/wiki/RSS_enclosure"&gt;podcast feeds&lt;/a&gt;, even just the general case with enclosures. &lt;a href="https://itunespartner.apple.com/en/podcasts/overview"&gt;iTunes podcast support&lt;/a&gt; would have taken a lot of work to add.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Instead, I chose to build the RSS feed semi-manually. &lt;em&gt;Semi&lt;/em&gt;-manually, because doing it totally manually is a recipe for making mistakes. XML is many things, but ‚Äúeasy to write correctly by hand‚Äù is not one of them. I use &lt;a href="http://reinventedsoftware.com/feeder/"&gt;Feeder&lt;/a&gt; to manage the feeds, and &lt;em&gt;it&lt;/em&gt; makes sure that the enclosure and iTunes elements are set correctly.&lt;/p&gt;
&lt;p&gt;The biggest upside to this is that I can use Pelican without modification to how it generates feeds (apart from optionally turning them off entirely). It just &lt;a href="https://github.com/WinningSlowly/winningslowly.org/blob/master/pelicanconf.py#L99"&gt;copies&lt;/a&gt; the feed I generate to the output file during its normal build process. As suggested above, I also &lt;em&gt;don‚Äôt&lt;/em&gt; generate the other feeds which Pelican supports, as we have no need for them; we only care about the podcast feed.&lt;/p&gt;
&lt;p&gt;This process works equally well, with very little modification, for New Rustacean. In that case, I‚Äôm generating the content by running Rust‚Äôs documentation tool, &lt;code&gt;cargo doc&lt;/code&gt;&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; to render the ‚ÄúAPI docs‚Äù which serve as show notes. Notice the family resemblance between &lt;a href="http://www.newrustacean.com/show_notes/"&gt;my ‚Äúshow notes‚Äù&lt;/a&gt; and, say, the &lt;a href="http://sgrif.github.io/diesel/diesel/index.html"&gt;Diesel docs&lt;/a&gt;, which are both generated the same way. This is &lt;em&gt;not&lt;/em&gt; a normal way of building a podcast website; you can hear me explain why I did it this way in &lt;a href="http://www.newrustacean.com/show_notes/e001/index.html"&gt;New Rustacean e001: Document all the things!&lt;/a&gt; In any case, I just take the show note-relevant parts of the documentation and put it in Feeder, generate the feed, and &lt;a href="https://github.com/chriskrycho/newrustacean.com/blob/master/Makefile#L32"&gt;copy that as part of the build process&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That‚Äôs it!&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;And, incidentally, &lt;a href="http://www.sap-py.com"&gt;Sap.py&lt;/a&gt; and my &lt;a href="http://www.chriskrycho.com/sermons.xml"&gt;sermons&lt;/a&gt; feed.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;If I stick with Pelican long-term, I might look into adding it anyway, but honestly, I don‚Äôt love Pelican. The reasons have little to do with Pelican for itself, and a lot more to do with my particular and somewhat peculiar needs. That‚Äôs a post for another day. In any case, I‚Äôm likelier to use another generator‚Äîeven one I write myself!‚Äîthan to do the work to make Pelican do what I want.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Technically, Rust‚Äôs documentation tool is &lt;code&gt;rustdoc&lt;/code&gt;, which &lt;code&gt;cargo doc&lt;/code&gt; wraps around. I never actually use &lt;code&gt;rustdoc&lt;/code&gt; directly, though.&lt;a href="#fnref3"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 28 Feb 2016 12:50:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-28:2016/static-site-generators-and-podcasting.html</guid><category>software development</category><category>podcasting</category><category>python</category><category>rust</category></item><item><title>Rust and Swift (xiii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both have methods which are attached to given data types. However, whereas Rust takes its notion of separation of data and functions rather strictly, Swift implements them on the relevant data structures (classes, structs, or enums) directly. In other words, the implementation of a given type‚Äôs methods is within the body of the type definition itself in swift, whereas in Rust it is in an &lt;code&gt;impl&lt;/code&gt; block, usually but not always immediately adjacent in the code.&lt;/p&gt;
&lt;p&gt;This goes to one of the philosophical differences between the two languages. As we‚Äôve discussed often in the series, Rust reuses a smaller set of concepts‚Äîlanguage-level primitives‚Äîto build up its functionality. So methods on a type and methods for a trait on a type are basically the same thing in Rust; they‚Äôre defined in almost exactly the same way (the latter includes &lt;code&gt;for SomeTrait&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; expression). In Swift, a method is defined differently from a protocol definition, which we‚Äôll get to in the future. The point is simply this: the two take distinct approaches to the relationship between a given type definition and the implementations of any functions which may be attached to it.&lt;/p&gt;
&lt;p&gt;Another important difference: access to other members of a given data type from within a method is &lt;em&gt;explicit&lt;/em&gt; in Rust and &lt;em&gt;implicit&lt;/em&gt; in Swift. In Rust, the first parameter to an instance method is always &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;&amp;amp;self&lt;/code&gt; (or a mutable version of either of course), much as in Python. This explicitness distinction is by now exactly what we expect from the two languages.&lt;/p&gt;
&lt;p&gt;Both use dot notation, in line with most other languages with a C-like syntax, for method calls, e.g. &lt;code&gt;instance.method()&lt;/code&gt; in Swift and &lt;code&gt;instance.method()&lt;/code&gt; in Rust. The latter is just syntactical sugar for &lt;code&gt;T::method(&amp;amp;instance)&lt;/code&gt; or &lt;code&gt;T::method(instance)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the instance (depending on whether the item is being borrowed or moved). Given its implicit knowledge of/access to instance-local data, and the distinctive behavior of Swift methods (see below), I don‚Äôt &lt;em&gt;think&lt;/em&gt; the same is, or even could be, true of Swift.&lt;/p&gt;
&lt;p&gt;All of Swift‚Äôs &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;other behaviors around functions&lt;/a&gt;‚Äîinternal and external names, and all the distinctions that go with those‚Äîare equally applicable to methods. Similarly, with the sole change that the first parameter is always the instance being acted on, a Rust methods follow all the same rules as ordinary Rust functions (which is why you can call the struct or enum method with an instance parameter as in the example above).&lt;/p&gt;
&lt;p&gt;Swift does &lt;em&gt;have&lt;/em&gt; a &lt;code&gt;self&lt;/code&gt;‚Äîit is, of course, implicit. It‚Äôs useful at times for disambiguation‚Äîbasically, when a parameter name shadows an instance name. This will look familiar to people coming from Ruby.&lt;/p&gt;
&lt;p&gt;The strong distinction Swift makes &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;between reference and value types&lt;/a&gt; comes into play on methods, as you might expect, as does its approach to mutability. Methods which change the values in value types (&lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; instances) have to be declared &lt;code&gt;mutating func&lt;/code&gt;. This kind of explicit-ness is good. As we discussed in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;Part 10&lt;/a&gt;, Rust approaches this entire problem differently: types are not value or reference types; they are either mutable and passed mutably (including as &lt;code&gt;mut self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or they are not. If an instance is mutable and passed mutably, a method is free to act on instance data. And in fact both languages require that the instance in question not be immutable. In fact, everything we said in Part 10 about both languages applies here, just with the addendum that private properties are available to methods.&lt;/p&gt;
&lt;p&gt;The distinction, you‚Äôll note, is in where the indication that there‚Äôs a mutation happens. Swift has a special keyword combination (&lt;code&gt;mutating func&lt;/code&gt;) for this. With Rust, it‚Äôs the same as every other function which mutates an argument. This makes Rust slightly more verbose, but it also means that in cases like this, the existing language tooling is perfectly capable of handling what has to be a special syntactical case in Swift.&lt;/p&gt;
&lt;p&gt;Both Swift and Rust let you out-and-out change the instance by assigning to &lt;code&gt;self&lt;/code&gt;, albeit in fairly different ways. In Swift, you‚Äôd write a mutating method which updates the instance proper like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0, y = 0.0
    mutating func changeSelf(x: Double, y: Double) {
        self = Point(x: x, y: y)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you‚Äôd need to explicitly pass a mutable reference and dereference it. (If you tried to pass &lt;code&gt;mut self&lt;/code&gt; instead of &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, it would fail unless you returned the newly created object and assigned it outside.) Note that while the full implementation here is a couple lines longer, because of the data-vs.-method separation discussed earlier, the implementation of the method itself is roughly the same length.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    pub fn change_self(&amp;amp;mut self, x: i32, y: i32) {
        *self = Point { x: x, y: y };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that though you &lt;em&gt;can&lt;/em&gt; do this, I‚Äôm not sure it‚Äôs particularly Rustic. My own instinct would be to get a &lt;em&gt;new&lt;/em&gt; &lt;code&gt;Point&lt;/code&gt; rather than mutate an existing one, in either language, and let the other be cleaned up ‚Äúbehind the scenes‚Äù as it were (with automatic memory management in Swift or the compiler‚Äôs automatic destruction of the type in Rust)‚Äîpurer functions being my preference these days.&lt;/p&gt;
&lt;p&gt;You can do this with &lt;code&gt;enum&lt;/code&gt; types as well, which the Swift book illustrates with a three-state switch which updates the value type passed to a new value when calling its &lt;code&gt;next()&lt;/code&gt; method. You can do the same in Rust, with the same reference/dereference approach as above.&lt;/p&gt;
&lt;p&gt;Here‚Äôs a three-state switch in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum ThreeState {
    case First, Second, Third
    mutating func next() {
        switch self {
        case First:
            self = Second
        case Second:
            self = Third
        case Third
            self = First
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the same in Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum ThreeState { First, Second, Third }
impl ThreeState {
    pub fn next(&amp;amp;mut self) {
        match *self {
            ThreeState::First =&amp;gt; *self = ThreeState::Second,
            ThreeState::Second =&amp;gt; *self = ThreeState::Third,
            ThreeState::Third =&amp;gt; *self = ThreeState::First,
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both languages also have what Swift calls ‚Äútype methods‚Äù, and which you might think of as ‚Äústatic class methods‚Äù coming from a language like Java or C‚ôØ. In Swift, you define them by adding the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; keywords to the &lt;code&gt;func&lt;/code&gt; definition. The &lt;code&gt;class func&lt;/code&gt; keyword combo is only applicable in &lt;code&gt;class&lt;/code&gt; bodies, and indicates that sub-classes may override the method definition.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Bar {
    static func quux() { print(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;) }
}

func main() {
    Bar.quux()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you simply drop &lt;code&gt;self&lt;/code&gt; as a first parameter and call it with &lt;code&gt;::&lt;/code&gt; syntax instead of &lt;code&gt;.&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Bar;
impl Bar {
    pub fn quux() { println!(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;); }
}

fn main() {
    Bar::quux();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, Rust chooses to use existing language machinery; Swift uses new (combinations of) keywords.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Indexing and subscripts, or: traits vs.¬†keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Mar 2016 13:20:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-28:2016/rust-and-swift-xiii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (xii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class="editorial"&gt;A note on publication: I had this drafted in early January and simply forgot to publish it. Whoops!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;As noted in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;my discussion of the product types in Rust and Swift&lt;/a&gt;, Swift distinguishes between classes and structs, with the former being reference types and the latter being value types. All structs are value types in Rust. (That you can wrap them in a pointer for heap-allocation with one of the smart pointer types, e.g. &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;, doesn‚Äôt change this fundamental reality.) This underlying difference gives rise to one the big difference between Swift classes and Rust structs: a constant &lt;code&gt;class&lt;/code&gt; instance in Swift can still have its fields mutated; not so with a Rust &lt;code&gt;struct&lt;/code&gt; instance. But also not so with a &lt;em&gt;Swift&lt;/em&gt; &lt;code&gt;struct&lt;/code&gt; instance, as it turns out! There isn‚Äôt a straightforward way to do this with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in Rust; you &lt;em&gt;could&lt;/em&gt; do it with something like an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs &lt;code&gt;lazy&lt;/code&gt; keyword, and associated delayed initialization of properties has, as far as I know, no equivalent whatsoever in Rust. And while I can see the utility in principle, I‚Äôm hard-pressed to think of any time in my working experience where the behavior would actually be useful. Rather than having &lt;code&gt;lazy&lt;/code&gt; properties, I would be far more inclined to separate the behavior which should be initialized at a later time into its own data structure, and supplying it via &lt;em&gt;inversion of control&lt;/em&gt; if it is necessary for an actions taken by other data structures. (This seems‚Äîat first blush at least‚Äîto be a way of supporting the un- or partially-initialized data types possible in Objective C?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has computed properties, a concept familiar to Python developers (and relatively recently introduced in JavaScript). These can e quite handy, as they let you define a property to be accessed like any other (&lt;code&gt;someInstance.theProperty&lt;/code&gt;) while being defined with functions which compute the value dynamically. A common, trivial example: if you defined a &lt;code&gt;Person&lt;/code&gt; with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; members, you could define a computed property, &lt;code&gt;fullName&lt;/code&gt;, which was built using the existing values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn‚Äôt have computed properties at all. This is because of its design decision to deeply separate &lt;em&gt;data&lt;/em&gt; from &lt;em&gt;behavior&lt;/em&gt;, essentially stealing a page from more pure-functional languages (Haskell etc.). This is (one reason) why you don‚Äôt define the implementation of a &lt;code&gt;struct&lt;/code&gt; method in the same block as the members of the struct. See an excellent explanation &lt;a href="https://www.reddit.com/r/rust/comments/2uvfic/why_doesnt_rust_have_properti%20es/cocmunq"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs also closely related the way Rust favors composition over inheritance (by making the latter impossible, at least for now!). By separating &lt;code&gt;impl&lt;/code&gt; from &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;enum&lt;/code&gt;, Rust makes it not only straightforward but &lt;em&gt;normal&lt;/em&gt; to define new behavior for a given item separately from the data description. This, combined with the use of traits (like Swift‚Äôs protocols) as the primary way of sharing behavior between objects, means that you don‚Äôt have to worry about conforming to some interface when you define a given type; it can always&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; be defined later, even by entirely other modules or even other crates (packages).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, the result is that it‚Äôs not at all Rustic&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; to have something like getters or setters or computed properties. It makes sense to have them in Swift, though, which has a more traditionally object-oriented type system (though with some neat additions in the form of its &lt;code&gt;protocol&lt;/code&gt; type classes, which are analogous to Rust‚Äôs &lt;code&gt;trait&lt;/code&gt;s‚Äîbut we‚Äôll come to those in a future post). This is a wash: it‚Äôs just a function of the slightly different approaches taken in object design in the two systems. If you have a Swift-style type system, you should have computed properties. If you have a Rust-like type system, you shouldn‚Äôt.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I‚Äôm shocked‚Äîutterly shocked!‚Äîto find that Swift provides a default &lt;code&gt;newValue&lt;/code&gt; argument for setters for computed properties, and shorthand for defining read-only properties. By which I mean: I find this kind of thing entirely unsurprising at this point in Swift, but I don‚Äôt like it any better. Making so much implicit just rubs me the wrong way. Once you know the language, it‚Äôs fine of course: you‚Äôll recognize all the patterns. It just seems, in an interesting way, to add cognitive load rather than reducing it. That may just be me, though!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interestingly, Swift also allows you to set watchers on given properties‚Äîfunctions called with the new or the removed value whenever the value of the computed property is updated or touched for any reason. It has two of these built in: &lt;code&gt;willSet&lt;/code&gt; and &lt;code&gt;didSet&lt;/code&gt;. You can override these to get custom behavior when a normal property is about to change. (You can of course just implement the desired behavior yourself in the &lt;code&gt;set&lt;/code&gt; method for a computed property.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Since Rust doesn‚Äôt have properties, it doesn‚Äôt have anything analogous. I can‚Äôt think of a particularly straightforward way to implement it, either, though you might be able do some chicanery with a trait. Of course you can always define a setter method which takes a value and optional callbacks for actions to take before and after setting the value; the thing that‚Äôs nice in Swift is that it gives you these as built-in capabilities within the language itself. (Now I‚Äôm wondering if or how you could implement an &lt;code&gt;Observable&lt;/code&gt; trait, though! Might have to play with that idea more later.) It‚Äôs worth remembering , in any case, that Rust doesn‚Äôt have these &lt;em&gt;because it doesn‚Äôt have properties&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Curiously, Swift provides the same functionality for ‚Äúglobal‚Äù and ‚Äúlocal‚Äù variables in a given context. In both cases, this is suggestive of the underlying object model for both modules and functions in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now I‚Äôm curious what the representation of a module is in Swift; is it part of the general object system in some way?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This likewise gets me asking: what &lt;em&gt;is&lt;/em&gt; a module in Rust? It‚Äôs a block item, clearly, and accordingly defines a scope (as do functions, if and match expressions, and so on). It‚Äôs &lt;em&gt;not&lt;/em&gt; a compilation unit (as it is in C or C++). What other machinery is attached to it?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both of these questions can be answered by reading the source code for the languages (&lt;a href="https://github.com/rust-lang/rust"&gt;Rust&lt;/a&gt;, &lt;a href="https://github.com/apple/swift"&gt;Swift&lt;/a&gt;), of course. Putting that on my to-do list.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift also has &lt;em&gt;type properties&lt;/em&gt;: values common to all instances of a given type. These are directly analogous to &lt;em&gt;class properties&lt;/em&gt; (or &lt;em&gt;class attributes&lt;/em&gt;) in Python or prototype properties in JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn‚Äôt have anything like this to my knowledge. You could accomplish something similar using a module-level variable with a &lt;code&gt;'static&lt;/code&gt; lifetime,&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; much as you could in C‚Äîbut that wouldn‚Äôt be an item on the type itself, of course.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;static&lt;/code&gt; declaration of item in Swift suggests what a possible implementation might look like in Rust: defining a member like &lt;code&gt;a_static_long: 'static i64&lt;/code&gt;. There might be some interesting challenges around that, though; I don‚Äôt know enough to comment meaningfully. At the least, it seems like it would be an odd fit with the rest of the memory management approach Rust takes, and it would make it a bit harder to reason correctly about the behavior of data in a given type. (There are certainly issues there around mutability guarantees and lifetime checking!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because of the differences in underlying approach to data types and implementation, this is one of the areas where the superficially (and sometimes actually) similar languages diverge &lt;em&gt;a lot&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Hopes for the next generation of systems programming.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Methods, instance and otherwise.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;leaving aside details about &lt;code&gt;trait&lt;/code&gt; specialization &lt;a href="https://github.com/aturon/rfcs/blob/impl-specialization/text/0000-impl-specialization.md"&gt;still being hashed out&lt;/a&gt; in Rust&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;This is now my preferred term for ‚Äúidiomatic Rust‚Äù‚Äîdirectly analogous to ‚ÄúPythonic,‚Äù but with the upside of being an actual word, and one with pleasantly evocative connotations to boot.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;There‚Äôs nothing analogous to Rust‚Äôs concept of explicit lifetimes in Swift, as far as I can tell. The &lt;code&gt;static&lt;/code&gt; keyword in Swift, like that in C, Objective-C, and C++, is &lt;em&gt;sort of&lt;/em&gt; like Rust‚Äôs &lt;code&gt;'static&lt;/code&gt; lifetime specifically, for variables at least‚Äîbut Rust‚Äôs lifetime is substantially more sophisticated and complex than that analogy might suggest.&lt;a href="#fnref3"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 27 Feb 2016 22:30:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-27:2016/rust-and-swift-xii.html</guid><category>listicles</category><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>2016-02-27 20:05</title><link>http://www.chriskrycho.com/2016/2016-02-27-2005.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I posted these as a series of tweets.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Fired up and played the demo for &lt;a href="https://www.elitedangerous.com"&gt;Elite Dangerous&lt;/a&gt; on my Parallels VM. Made me want to buy it. But of course, I‚Äôd prefer to play it natively.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Of course, it‚Äôs available for Mac. But my (more than a decade old) joystick doesn‚Äôt have any support on OS X. No drivers, full stop.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You can find software out there which recognizes it, of course‚Äîbut it‚Äôs quirky and doesn‚Äôt behave well.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Looks like opportunity calling.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I might‚Äîmight, I say, not &lt;em&gt;will&lt;/em&gt;‚Äîend up seeing if I can write the requisite pieces in Rust. Because that seems like a good plan.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 27 Feb 2016 20:05:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-27:2016/2016-02-27-2005.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>gaming</category></item><item><title>2016-02-25 07:58</title><link>http://www.chriskrycho.com/2016/2016-02-25-0758.html</link><description>&lt;p&gt;I have an irrational-but-ridiculously-strong desire to build an Atom package that is a tiny JavaScript wrapper around a Rust implementation. Just because.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 25 Feb 2016 07:58:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-25:2016/2016-02-25-0758.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>javascript</category></item><item><title>2016-02-07 16:00</title><link>http://www.chriskrycho.com/2016/2016-02-07-1600.html</link><description>&lt;p&gt;Spent the last little bit reading about Rust‚Äôs type system for the next episode of &lt;a href="http://www.newrustacean.com/"&gt;New Rustacean&lt;/a&gt;. Heady stuff.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 07 Feb 2016 16:00:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-02-07:2016/2016-02-07-1600.html</guid><category>podcasting</category><category>programming languages</category><category>rust</category></item><item><title>‚ÄúI Don't Know When I'd Use That‚Äù</title><link>http://www.chriskrycho.com/2016/i-dont-know-when-id-use-that.html</link><description>&lt;p&gt;I was reading an interesting Stack Overflow &lt;a href="http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful"&gt;discussion&lt;/a&gt; of the value of &lt;a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala"&gt;higher-kinded types&lt;/a&gt; (hereafter &lt;abbr&gt;HKTs&lt;/abbr&gt;), and noted someone repeatedly commenting, ‚ÄúBut when would you use this in a &lt;em&gt;real app&lt;/em&gt;?‚Äù To put it the way another &lt;a href="https://m4rw3r.github.io/rust-and-monad-trait/"&gt;blog post&lt;/a&gt; about &lt;abbr&gt;HKTs&lt;/abbr&gt; (in Rust), they are ‚Äúa feature people do not really know what to do with.‚Äù&lt;/p&gt;
&lt;p&gt;Don‚Äôt get me wrong: I‚Äôm sympathetic to that desire for concrete examples. I‚Äôm interested in these kinds of things not primarily for their intellectual value but for their pragmatic value (though I don‚Äôt think those two are as distinct as many people do). I‚Äôd &lt;em&gt;also&lt;/em&gt; love to see some more real-world examples in those discussions. All too often, the discussions of types in Haskell end up being quite abstract and academic‚Äîno surprise, given the language‚Äôs origin. But I‚Äôm also aware that quite often it‚Äôs difficult to see how a given kind of abstraction is useful without jumping into a language which has that abstraction available and &lt;em&gt;using&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;People often get turned off by Haskell (and other similarly high-abstraction languages like Scala) because of challenging terms like &lt;em&gt;monad&lt;/em&gt;, &lt;em&gt;applicative&lt;/em&gt;, &lt;em&gt;functor&lt;/em&gt;, and so on. And again: I get that. To grok Haskell, you need to wrap your head around a lot of &lt;em&gt;math&lt;/em&gt; ideas‚Äîmainly various properties of &lt;em&gt;sets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But I remember feeling the same way six years ago when I started playing with JavaScript and jQuery and every tutorial out there simply assumed existing familiarity and comfort with functions as arguments or return values. Coming from the world of Fortran and C, my head ached for weeks as I tried to make sense of what I was seeing. Even when I finally got it, &lt;em&gt;I didn‚Äôt like it&lt;/em&gt;. Over the last several years, though, I‚Äôve become increasingly comfortable and even reliant on closures, composition of functions to transform data, and so on as I worked regularly in Python and JavaScript.&lt;/p&gt;
&lt;p&gt;That experience has taught me that my current inability to see the utility of a given abstraction means little about the abstraction. It‚Äôs primarily an indicator of my own inexperience.&lt;/p&gt;
&lt;p&gt;To the question of the utility &lt;abbr&gt;HKTs&lt;/abbr&gt; in general‚Äîin Haskell, Rust, or somewhere else‚ÄîI don‚Äôt have the knowledge myself (yet) to supply a good answer. Heck, I can‚Äôt even &lt;em&gt;explain&lt;/em&gt; them very well. (&lt;a href="http://adriaanm.github.io/research/2010/10/06/new-in-scala-2.8-type-constructor-inference/"&gt;Other people can, though!&lt;/a&gt;) But I can say that reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt; showed me clearly that such things can be very useful. Even if I am not yet comfortable using that tool, I see how learning to use it would be profitable in the long-term. And like any good tool, even if you don‚Äôt need it every day‚Ä¶ when you want it, you &lt;em&gt;really&lt;/em&gt; want it.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 17 Jan 2016 10:00:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-01-17:2016/i-dont-know-when-id-use-that.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>haskell</category></item><item><title>Women in Rust</title><link>http://www.chriskrycho.com/2016/women-in-rust.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I posted these bullet points last night as a series of tweets on my &lt;a href="https://www.twitter.com/chriskrycho"&gt;main account&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686007510147309568"&gt;‚àû January 9, 2016 21:11&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A thing I‚Äôd really, really like to see change‚Äîthis is from the &lt;a href="http://www.newrustacean.com/"&gt;New Rustacean&lt;/a&gt; Twitter data. Unsurprising, but awful:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="//cdn.chriskrycho.com/images/new-rustacean-followers.png" alt="@newrustacean Twitter follower gender data" /&gt;&lt;figcaption&gt;&lt;a href="https://www.twitter.com/newrustacean"&gt;@newrustacean&lt;/a&gt; Twitter follower gender data&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686007729371148289"&gt;‚àû January 9, 2016 21:12&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Takeaway: the &lt;a href="https://www.twitter.com/rustlang"&gt;@rustlang&lt;/a&gt; community has many strengths, but like every tech community, we need to improve here‚Äîa lot.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686008145752272896"&gt;‚àû January 9, 2016 21:14&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Standing offer: if you‚Äôre a female &lt;a href="https://www.twitter.com/rustlang"&gt;@rustlang&lt;/a&gt; dev, I‚Äôd &lt;em&gt;love&lt;/em&gt; to feature your experience learning Rust on the show.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686008527937245185"&gt;‚àû January 9, 2016, 21:15&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I‚Äôll be doing some interview &lt;a href="https://www.twitter.com/newrustacean"&gt;@newrustacean&lt;/a&gt; episodes soon-ish‚ÄîI want as many female voices in the mix as possible.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 15:25:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-01-10:2016/women-in-rust.html</guid><category>podcasting</category><category>tweetstorm</category><category>rust</category></item><item><title>Rust and Swift (xi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I‚Äôve still been (slowly) working through the Swift book and comparing Swift and Rust; I have another draft started which I‚Äôll hopefully finish this week. And I still find the comparison deeply profitable. The two languages continue to evolve in interesting ways, and the comparison is all the more interesting &lt;a href="https://github.com/apple/swift"&gt;now that Swift is open-source&lt;/a&gt; and its future &lt;a href="https://github.com/apple/swift-evolution"&gt;open for community input&lt;/a&gt; (just as &lt;a href="https://github.com/rust-lang/rfcs"&gt;Rust is&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Something I‚Äôve been thinking about for several months, and which the &lt;a href="https://overcast.fm/+CdSzsTIY/1:16:42"&gt;brief discussion of Swift, Go, and Rust&lt;/a&gt; at the end of the latest &lt;a href="http://atp.fm/episodes/151"&gt;Accidental Tech Podcast&lt;/a&gt; brought back to my mind, is the question of what the next generation of systems-level programming language should be. And my answer is: there shouldn‚Äôt be &lt;em&gt;just one&lt;/em&gt;. The best possible thing for the space, in many ways, is for there to be a healthy diversity of options and lots of competition in the space. We don‚Äôt want to have &lt;em&gt;ten&lt;/em&gt; different systems programming languages to deal with, I think‚Äîbut three or four or five would be &lt;em&gt;much&lt;/em&gt; preferable to having one or two (closely related) as we have in the decades of C and C++ dominance.&lt;/p&gt;
&lt;p&gt;Don‚Äôt get me wrong: both languages (and perhaps especially C) do many things exceptionally well. For all that they are (justly) maligned for some of their problems, the longevity of both C and C++ has a great deal to do with how well they fit the problem domain, and how much they‚Äôve empowered developers to accomplish within that space (which is very, &lt;em&gt;very&lt;/em&gt; large).&lt;/p&gt;
&lt;p&gt;The problem, though, at least as I see it, is that the existence of only two really serious systems programming languages for the last several decades has led a lot of developers to think that C and C++‚Äòs ways of solving problems are the &lt;em&gt;only&lt;/em&gt; way to solve problems. The languages we use shape the way we think about possible solutions, and when a given language doesn‚Äôt recognize entire classes of different approaches, that deeply limits developers‚Äô ability to tackle certain issues. (See also the interesting CppCast &lt;a href="http://cppcast.com/2015/10/andrei-alexandrescu/"&gt;interview with D‚Äôs Andrei Alexandrescu&lt;/a&gt; in which he makes similar points.)&lt;/p&gt;
&lt;p&gt;The most obvious thing missing from both is the ability to do truly functional-style programming. C of course is also lacking classes and thus is much more difficult to use for any sort of object-oriented programming.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Neither has anything remotely like Rust‚Äôs traits or Swift‚Äôs extensions; C++ has only gotten lambdas recently.&lt;/p&gt;
&lt;p&gt;All of this comes out to mean that the set of &lt;em&gt;tools&lt;/em&gt; available to systems programmer has necessarily been missing any number of things available in languages outside that context. In some cases, this may be a necessary consequence of the kinds of programming being done: when you need totally deterministic memory and compiler behavior, dynamic typing and a non-trivial runtime are simply not options. But in many cases, they are simply a function of the history of the languages‚Äô development and history. Being an ALGOL descendant, and especially a C descendant, means there are some fundamental choices about the language which will differ from those made in a language descended from ML.&lt;/p&gt;
&lt;p&gt;All of which is to say: C and C++ have been really useful tools in many ways, but having &lt;em&gt;only&lt;/em&gt; C and C++ available for serious systems programming work over the last decades has left many developers blind to or simply unaware of the real advantages other paradigms might offer them.&lt;/p&gt;
&lt;p&gt;So going forward, I don‚Äôt want there to be &lt;em&gt;a winner&lt;/em&gt; in the systems programming space. I‚Äôd rather see D, Rust, Swift, Go, and maybe even a few other contenders all stay strong‚Äîfinding their own niches and continually pushing each other and learning from each other. That will give us a space in which different languages are free to try out different approaches to the same problems, without being tied to the specific constraints faced by other languages. Built-in greenthreading? Go! Hindley-Milner types, memory safety, and zero runtime? Rust! Something in beween, highly expressive and with different type systems and tradeoffs around memory management, etc.? Swift, or D!&lt;/p&gt;
&lt;p&gt;Having a robust, thriving set of competitors in the market will be good for the languages themselves. But it will also be good for developers. It will take off some of the blinders that come from a single language (or a pair of very closely related languages) dominating the ecosystem. It will make it likelier that people will be more familiar with different programming paradigms. And that can only be a good thing, as far as I‚Äôm concerned.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;It is of course entirely possible to do non-classical OOP; the point is that C entirely lacks &lt;em&gt;language-level&lt;/em&gt; facilities for OOP, inheritance, etc.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 10:00:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2016-01-10:2016/rust-and-swift-xi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming-languages</category></item><item><title>Thoughts on 2015 (and 2016)</title><link>http://www.chriskrycho.com/2015/thoughts-on-2015-and-2016.html</link><description>&lt;p&gt;As we come to the end of the year, I have been reflecting on the things I set out to do this year, and on my hopes for the coming year. At the start of the year, I posted a number of goals for my ‚Äúpublic‚Äù life this year, and I also wrote up a number of personal goals for myself. Goals are well and good, but if I do not evaluate how I did on them, and think about areas I succeeded and areas I failed, and on how I might do better in the future, those goals will not make much difference. (&lt;em&gt;Much&lt;/em&gt; difference, I say, because I have long found that even just having goals makes a difference in how I approach the year.)&lt;/p&gt;
&lt;p&gt;At the start of the year, I posted a list of &lt;a href="http://www.chriskrycho.com/2015/public-ish-plans.html"&gt;‚ÄúPublic-ish Plans‚Äù&lt;/a&gt;. My self-evaluation on those counts isn‚Äôt amazing. The Winning Slowly goals, I managed: we have separate pages for each season, and we recorded two more seasons‚Äîeach one better than those before. Hosting things on Digital Ocean and migrating my wife‚Äôs blogs off of Blogger and WordPress, not so much (read: not at all, though I did &lt;em&gt;start&lt;/em&gt; writing a Ghost theme for her current WordPress site‚Ä¶ and haven‚Äôt touched it in at least six months.) I wrote some music this year, but not three minutes worth‚Äîyou &lt;em&gt;can&lt;/em&gt; hear all 37 seconds of it &lt;a href="https://soundcloud.com/chriskrycho"&gt;on SoundCloud&lt;/a&gt;. I wrote &lt;a href="http://www.chriskrycho.com/poetry/"&gt;poetry&lt;/a&gt;; I managed to average about one poem a month starting in March. I wrote a few essays, but nothing close to one per month. I posted a whopping two book reviews (out of the six I hoped for), and both of those were written for school. I managed to add a picture to the About page, but I didn‚Äôt even come close to blogging about the family on a monthly basis.&lt;/p&gt;
&lt;p&gt;In sum: about 50/50 on those goals.&lt;/p&gt;
&lt;p&gt;That said, I managed quite a few other things &lt;em&gt;not&lt;/em&gt; on that list this year. I started learning Rust, and started &lt;a href="http://newrustacean.com/"&gt;a podcast about it&lt;/a&gt; which is easily the most successful online endeavor I‚Äôve ever undertaken, with a good 500 regular listeners. (That‚Äôs a small crowd on the internet, but massively more than any writing I‚Äôve done, and actually larger than Winning Slowly‚Äôs current audience.) I have basically carried home a major transition effort for my main software development client, and helped them bring a new developer up to speed. I landed a new software development job, doing things I‚Äôm much more passionate about, which I‚Äôll be starting in mid-January. I ran a triathlon (and placed third in my age group), and I set another personal record in the half-marathon I ran this fall.&lt;/p&gt;
&lt;p&gt;One of the lessons I take away from this last year, then, is that it‚Äôs important to set goals, but it‚Äôs also important to let those goals change over time. Some of those goals are still things I‚Äôd like to accomplish‚Äîlike migrating us to DigitalOcean, and getting Jaimie‚Äôs sites off of Blogger especially. Another (fairly obvious one) is prioritizing. I had a lot of major goals for last year, and in retrospect, I think I had &lt;em&gt;too many&lt;/em&gt;. It‚Äôs hard to keep all of those in sight of the course of the year, especially with other professional and scholastic demands to meet (themselves often good in their own right).&lt;/p&gt;
&lt;p&gt;With all of these things in mind, I‚Äôm planning to approach 2016 a little differently. I haven‚Äôt made formal goals yet, but I have come up with the basic outline I want to use going forward.&lt;/p&gt;
&lt;p&gt;First, I am going to set a single goal in each of five major categories in my life:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spiritual:&lt;/strong&gt; everything in my walk with God, including my own personal devotions, my involvement in the life of the church, and my ‚Äúministry‚Äù actions in general&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;family:&lt;/strong&gt; both quantity and quality time spent with my wife and my quickly-growing-up little girls&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;personal:&lt;/strong&gt; podcasting, blogging, and writing for &lt;a href="http://mereorthodoxy.com/author/chris-krycho/"&gt;other outlets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;professional:&lt;/strong&gt; working in my new job and as a consultant, and carrying on toward the conclusion of my M. Div.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;health/fitness:&lt;/strong&gt; continuing to stay healthy, including eating well and continuing to stay fit by running and doing triathlon work&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that this list is intentionally &lt;em&gt;unordered&lt;/em&gt;.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; My spiritual life remains the highest priority, because if my walk with God falters, everything else will go amok. Beyond that, however, the amount of time and effort I invest in each category not only can but should vary over time. Family will broadly remain in the second of those slots, though there may be days or the occasional week where one of the other concerns &lt;em&gt;very temporarily&lt;/em&gt; takes a higher priority. The others will adjust relative to each other as need be: there will be times when school requires more, and so my own writing gets less time, and there will be times when I have more flexibility and so am able to devote more to those personal interests, and so on. The goal here is not the mythical notion of ‚Äúbalance‚Äù but rather faithfulness, which has some superficial similarities but ultimately &lt;a href="http://www.chriskrycho.com/2015/faithfulness.html"&gt;plays out rather differently&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I‚Äôm hoping, in light of those goals, to set annual, monthly, and daily goals in each of those categories. The daily goals should help me move toward the monthly goals, and the monthly goals toward the yearly goals. I only get to set one goal in each of those categories for each tier: at five goals, that‚Äôs already plenty! I hope that evaluating each day will help me be more focused and faithful, and that situating daily and monthly goals each in light of larger goals will help me actually accomplish those larger goals. We‚Äôll see how it goes, of course. I‚Äôll be back in a week or so with whatever goals I decide to make public in those categories, and again in a year with an evaluation rather like this one.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Under the covers, it‚Äôs literally an HTML unordered list.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 26 Dec 2015 13:30:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-12-26:2015/thoughts-on-2015-and-2016.html</guid><category>family</category><category>rust</category><category>podcasting</category></item><item><title>Rust and Swift (x)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-x.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift and Rust both have ‚Äúproduct types‚Äù as well as the &lt;code&gt;enum&lt;/code&gt; ‚Äúsum types.‚Äù In Rust, these are &lt;code&gt;struct&lt;/code&gt; types; Swift splits them into &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;‚ÄúProduct types‚Äù will be much more familiar to programmers coming from a C-like background, or indeed most object-oriented programming languages: these are the same basic kind of thing as classes, structs, and objects in other languages. These include &lt;em&gt;all&lt;/em&gt; the value types which compose them, unlike sum types‚Äî&lt;code&gt;enum&lt;/code&gt;‚Äîwhich have &lt;em&gt;only one&lt;/em&gt; of the value types which compose them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Right off the bat, I note the Swift book‚Äôs somewhat amusing reticence to call out C and C-descended languages:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because there‚Äôs such a long list of languages not directly descended from C which do that, right? üòâ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust differs not only from Swift but from every other modern language I have used in not having a constructor &lt;em&gt;syntax&lt;/em&gt; for its instantiations. Whereas C++ has &lt;code&gt;new NameOfType()&lt;/code&gt; and Python and Swift both have &lt;code&gt;NameOfType()&lt;/code&gt;, ‚Äúconstructors‚Äù for Rust &lt;code&gt;struct&lt;/code&gt;s are just functions which return an instance constructed using literal syntax, by convention &lt;code&gt;NameOfType::new()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let‚Äôs make a &lt;code&gt;struct&lt;/code&gt; defining a location in a plane, you might do this in Swift (leaving aside initializer values; I‚Äôll come back to those later). These definitions look &lt;em&gt;very&lt;/em&gt; similar. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x: Double var y: Double
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Point {
    x: f64,
    y: f64,
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Creating the types looks a little different, though. Here‚Äôs a constructor in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let point = Point(x: 0, y: 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the two ways we could construct the type in Rust, a literal constructor (fairly similar to constructing &lt;code&gt;dict&lt;/code&gt; literals in Python or object literals in JavaScript):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let point = Point { x: 0.0, y: 0.0 };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or a constructor method, &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;Constructor&amp;quot;
impl Point {
    fn new(x: f64, y: f64) -&amp;gt; Point {
        Point { x: x, y: y }
    }
}

let another_point = Point::new(0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observe: these two things in Rust are the same under the covers (though if &lt;code&gt;Point&lt;/code&gt;s had non-public internals, they would be non-trivially different: you couldn‚Äôt construct it with its private members externally). As usual, Rust opts to keep the language relatively small in these core areas. Given the plethora of ways you can construct something in e.g.¬†C++, I count that a big win.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another difference: Swift has &lt;em&gt;syntax&lt;/em&gt; for default values; Rust uses a &lt;code&gt;trait&lt;/code&gt; instead. In Swift, you simply supply the default value in the definition of the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0 var y = 0.0
}

let point = Point()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you use &lt;code&gt;std::default::Default&lt;/code&gt;, which provides a standard value for a given type, and for simple types can be supplied by the compiler even for custom types. Here is the equivalent Rust code:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

#[derive(Default)]
struct Point {
    x: f64,
    y: f64,
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is reasonable enough, but we can also supply our own custom implementation if we so desire:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

struct Point {
    x: f64,
    y: f64,
}

impl Default for Point {
    fn default() -&amp;gt; Point {
        Point { x: 0.0, y: 0.0 }
    }
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this is trivial for this type, but you can see how it could be useful for more complex types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The tradeoffs here are our usual suspects: Rust‚Äôs re-use of an existing concept/tool within the language (&lt;code&gt;trait&lt;/code&gt;) vs.¬†Swift‚Äôs use of syntax. Rust is slightly more explicit, making it obvious that a default value is being created‚Äîbut Swift is perfectly readable and the syntax is consistent with many other languages, and it &lt;em&gt;is&lt;/em&gt; shorter.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages use &lt;code&gt;.&lt;/code&gt; syntax for member access. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;println(&amp;quot;The point is: \(point.x), \(point.y)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;println!(&amp;quot;The point is {:}, {:}&amp;quot;, point.x, point.y);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift lets you define items &lt;em&gt;within&lt;/em&gt; a struct as mutable or constant. So you can create a variable struct instance, with some of its items immutable:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct PointOnZAxis {
    var x: Double var y: Double let z = 0.0
}

var point = PointOnZAxis(x: 4.0, 5.0)
point.x = 5.0 point.y = 6.0
// This wouldn&amp;#39;t compile, though:
// point.z = 1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty handy for a lot of object-oriented programming approaches.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And Rust doesn‚Äôt have it. There are ways to accomplish the same thing; this isn‚Äôt the end of the world. Still, it‚Äôs an interesting omission, and it‚Äôs very much by design. Rust &lt;em&gt;used&lt;/em&gt; to have this feature, and dropped it‚Äîand for good reason. Say you had a mutable field in a mutable struct, and then an immutable reference to it; should the mutable field be mutable, or immutable, with that reference?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Rusty way to do this is to differentiate between public and private data. The above examples don‚Äôt make the public/private distinction particularly clear, because they assume everything is within the same module. However, many times, this will not be the case.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod geometry {
    pub struct Point {
        x: f64,
        pub y: f64,
    }

    impl Point {
        pub fn new() -&amp;gt; Point {
            Point { x: 0.0, y: 0.0 }
        }

        pub fn set_x(&amp;amp;mut self, x: f64) {
            self.x = x;
        }
    }
}

fn main() {
    // Won&amp;#39;t compile: the `x` field is private.
    // let mut p = geometry::Point { x: 0.0, y: 0.0 };

    // Will compile: the `new` method is public.
    let mut p = geometry::Point::new();

    // Won&amp;#39;t compile: `x` isn&amp;#39;t public.
    // p.x = 4.0;
    // You can use the setter, though:
    p.set_x(4.0);

    // You *can* set `y` directly, though, because it&amp;#39;s public.
    p.y = 14.0;

    // You can&amp;#39;t set fields either way if the instance is immutable.
    let q = geometry::Point::new();

    // This fails because `set_x` requires a mutable reference, but `q` is
    // immutable.
    // q.set_x(4.0);

    // This fails because `q` is immutable, and so all its fields are, too.
    // q.y = 14.0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is an interesting way of handling this issue. Rust takes the fairly standard use of information hiding (one of the basic principles of most object-oriented programming techniques) and combines it with the language‚Äôs normal mutability rules to make it so that the mutability of any given instance data is quite clear: all public members are just as mutable as the struct. If a member isn‚Äôt potentially publicly mutable, it isn‚Äôt publicly accessible. I really like this, though it took some mental readjustment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There‚Äôs one other difference here, and it‚Äôs actually one of the areas Swift and Rust diverge substantially. Rust has &lt;code&gt;struct&lt;/code&gt; for all product types; Swift splits them into &lt;code&gt;struct&lt;/code&gt; types and &lt;code&gt;class&lt;/code&gt; types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift &lt;code&gt;class&lt;/code&gt;es have inheritance; there is presently &lt;em&gt;no&lt;/em&gt; inheritance in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additionally, whereas Rust determines whether to use pass-by-reference or-value depending on details of the type (whether it implements the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;) and expected arguments to a function, Swift makes that distinction between &lt;code&gt;class&lt;/code&gt; (pass-by-reference) and &lt;code&gt;struct&lt;/code&gt; (pass-by-value) types. Quirky.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Not bad, &lt;em&gt;per se&lt;/em&gt;. But quirky.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I recently bumped into some discussion of data types in C‚ôØ along with C, C++, and Java (&lt;a href="http://joeduffyblog.com/2015/12/19/safe-native-code/"&gt;here&lt;/a&gt;) and discovered that Swift is stealing this idea from C‚ôØ, which &lt;a href="https://msdn.microsoft.com/en-us/library/0taef578.aspx"&gt;makes the same copy/reference distinction&lt;/a&gt; between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One consequence of this: in Rust, you‚Äôre always rather explicit about whether you‚Äôre accessing things by value vs.¬†by reference. Not so in Swift; you have to remember whether the item you‚Äôre touching is a &lt;code&gt;struct&lt;/code&gt; type or a &lt;code&gt;class&lt;/code&gt; type, so that you can &lt;em&gt;remember&lt;/em&gt; whether a given assignment or function call results in a reference or a copy. This is necessary because Swift doesn‚Äôt let you make that explicit (trying to hide the memory management from you). And it‚Äôs not alone in that, of course; many other high-level languages obscure that for convenience but still require you to think about it in certain circumstances. I‚Äôve been bitten in the past by the value/reference distinction when thinking through the behavior of Python objects, for example, so that‚Äôs not a critique of Swift. Moreover, having the distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types does let you be &lt;em&gt;more&lt;/em&gt; explicit than you might in e.g.¬†Python about how given data will be handled.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I won‚Äôt lie, though: I like Rust‚Äôs approach better. (Shocking, I know.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All that nice initializer syntax for Swift &lt;code&gt;struct&lt;/code&gt; types is absent for its &lt;code&gt;class&lt;/code&gt; types, which seems strange to me.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift supplies some syntax for object identity, since it‚Äôs useful to know not only whether two &lt;code&gt;class&lt;/code&gt; instances have the same data, but are in fact the same instance. You can use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;. Handy enough. To get at this kind of equivalence in Rust, you have to use raw pointers (which are often but not always &lt;code&gt;unsafe&lt;/code&gt;; you can do this specific comparison &lt;em&gt;without&lt;/em&gt; being &lt;code&gt;unsafe&lt;/code&gt;, for example) to check whether the memory addresses are the same.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ix.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Hopes for the next generation of systems programming.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 22 Dec 2015 13:30:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-12-06:2015/rust-and-swift-x.html</guid><category>listicles</category><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (ix)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ix.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Right off the bat when looking at the definitions for Swift‚Äôs and Rust‚Äôs &lt;code&gt;enum&lt;/code&gt; types, a difference pops out: the use of the keyword &lt;code&gt;case&lt;/code&gt; to introduce an enum member in Swift. In one sense, this overloads that keyword, but in another sense it‚Äôs fine: pattern matching and enums go hand in hand, so the use in both cases is fairly natural. Rust doesn‚Äôt have any special syntax to designate the elements of an enum; they‚Äôre just separated by commas.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am not at all shocked to find that Swift has a variant syntax for its unit type case declarations, where a single &lt;code&gt;case&lt;/code&gt; keyword precedes a list of comma-separated cases defined on a single line. (At this point, I would be more surprised &lt;em&gt;not&lt;/em&gt; to find a variant syntax for something in Swift!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Something truly wonderful about both a Rust and Swift: enumerated types aren‚Äôt just wrappers around integer values. They‚Äôre real types of their own. This is powerful.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift also share in having enumerated types that can hold values. The most prominent of these so far in the Swift book are optionals, the &lt;code&gt;Optional&lt;/code&gt; enum type, corresponding very closely to Rust‚Äôs &lt;code&gt;Option&lt;/code&gt; type. Having had these for a bit in playing with Rust, and having gotten familiar with the utility of types like these while reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;‚Äîa delightful book which introduces Haskell and functional programming using Haskell‚Äôs &lt;code&gt;Maybe&lt;/code&gt; type‚ÄîI now miss them profoundly in languages which don‚Äôt have them. (Which is to say: every language I use on a regular basis professionally: C, C++, Python, JavaScript, etc.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs enum types don‚Äôt have integer values &lt;em&gt;by default&lt;/em&gt;‚Äîbut they can have them if you define a type and assign a value to each enum case at the definition. These ‚Äúraw values‚Äù are distinct from the ‚Äúassociated values‚Äù noted just above. I expect these exist primarily for ease of interoperation with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;Rust doesn‚Äôt have anything like this, at least that I can think of. The main place it would be useful would be for foreign function interfaces (as in Swift), and this is one of several such gaps in Rust,&lt;/del&gt; along with the lack of a straightforward way to map to C‚Äôs &lt;code&gt;union&lt;/code&gt; types. &lt;del&gt;There are trade offs in terms of adding the functionality to the language, though, as it substantially increases the complexity of what an enum value can be, I think.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; This was incorrect. From the &lt;a href="https://doc.rust-lang.org/reference.html"&gt;Rust Reference&lt;/a&gt; section on &lt;a href="https://doc.rust-lang.org/reference.html#enumerations"&gt;Enumerations&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enums have a discriminant. You can assign them explicitly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum Foo {
    Bar = 123,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a discriminant isn‚Äôt assigned, they start at zero, and add one for each variant, in order.&lt;/p&gt;
&lt;p&gt;You can cast an enum to get this value:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let x = Foo::Bar as u32; // x is now 123u32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This only works as long as none of the variants have data attached. If it were &lt;code&gt;Bar(i32)&lt;/code&gt;, this is disallowed.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Initialization of Swift‚Äôs raw-valued enum type is quite similar, and pleasantly so, to Python‚Äôs initialization of enums.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In a surprising change from the usual, Swift‚Äôs syntax for binding variable names when pattern matching against an enum is &lt;em&gt;more&lt;/em&gt; verbose than Rust‚Äôs, requiring the use of either a leading &lt;code&gt;let&lt;/code&gt; on the &lt;code&gt;case&lt;/code&gt; statement if all the elements are of the same type, or a &lt;code&gt;let&lt;/code&gt; in front of each element otherwise:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;var matchedValue: String
let matchee = 3.14159
switch matchee {
case 3.14159:
    matchedValue = &amp;quot;pi&amp;quot;
case _:
    matchedValue = &amp;quot;not pi&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, a matched pattern can simply bind its value directly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let matchee = 3.14159;
let matchedValue = match matchee {
    3.14159 =&amp;gt; &amp;quot;pi&amp;quot;.to_string(),
    _ =&amp;gt; &amp;quot;not pi&amp;quot;.to_string()
};&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the ability to do recursive enumerations with its &lt;code&gt;indirect&lt;/code&gt; type. This is conceptually interesting, but off the top of my head I can‚Äôt think of a time when this would have been useful at any point since I started programming seven and a half years ago. The book‚Äôs example of a recursive function a aliasing arithmetic expressions is fine, but not particularly illuminating to me. I suspect, though, that it might make more sense if I were more familiar with pure functional programming paradigms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/65990633"&gt;points out&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Indirect enums are useful for recursive types in general. There are a lot of these: Lists, trees, and streams are the big ones that come to mind.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All those same lines: Rust does &lt;em&gt;not&lt;/em&gt; have the ability to have recursive enumerations at present (or recursive &lt;code&gt;struct&lt;/code&gt; types, for that matter), at least without heap-allocating with &lt;code&gt;Box&lt;/code&gt; along the way. You &lt;em&gt;can&lt;/em&gt; construct such a type, in other words, but you have to be explicit about how you‚Äôre handling the memory, and it can‚Äôt be stack-allocated.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For an example of a recursive enumeration type (as well as an interesting/hilarious example of how you can easily confuse the compiler if you do this wrong), see &lt;a href="https://users.rust-lang.org/t/recursive-enum-types/2938"&gt;this Rust forum post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For some discussion on stack- and heap-allocated memory in Rust, I‚Äôll shamelessly promote my Rust podcast, &lt;a href="http://www.newrustacean.com"&gt;New Rustacean&lt;/a&gt;: take a listen to &lt;a href="http://www.newrustacean.com/show_notes/e005/index.html"&gt;e005: Allocate it where?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 02 Jan 2016 21:54:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-11-09:2015/rust-and-swift-ix.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (viii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-viii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift handle function definition fairly similarly, at least for basic function definitions. In fact, for most basic functions, the only difference between the two is the keyword used to indicate that you‚Äôre declaring a function: &lt;code&gt;fn&lt;/code&gt; in Rust and &lt;code&gt;func&lt;/code&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Likewise, both return an empty tuple, &lt;code&gt;()&lt;/code&gt;, called the &lt;em&gt;unit type&lt;/em&gt; in Rust or &lt;code&gt;Void&lt;/code&gt; in Swift. Note, however, that this unit/&lt;code&gt;Void&lt;/code&gt; type is &lt;em&gt;not&lt;/em&gt; like C(++)‚Äôs &lt;code&gt;void&lt;/code&gt; or Java‚Äôs &lt;code&gt;null&lt;/code&gt;: you cannot coerce other types to it; it really is an empty tuple.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type declarations on functions are basically identical for simple cases, though they vary into the details as you get into generics and constraints in generics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have no idea why the Swift team chooses to represent function names like this: &lt;code&gt;function_name(_:second_param:third_param:&amp;lt;etc.&amp;gt;)&lt;/code&gt;. Perhaps it‚Äôs a convention from other languages I‚Äôm simply unfamiliar with, but it seems both odd and unhelpful: eliding the first parameter name obscures important information. Also, why use colons for the delimiter?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I‚Äôm informed via Twitter and App.net that this reflects how function names work in Objective C, and derives ultimately from Smalltalk.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Being able to name the items in a returned type in Swift is quite handy; it‚Äôs something I have often wanted and had to work around with dictionaries or other similar types in Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We‚Äôll see how I feel once I‚Äôve been writing both for a while, but initially I &lt;em&gt;strongly&lt;/em&gt; prefer Rust‚Äôs more-obvious (if also somewhat longer) &lt;code&gt;-&amp;gt; Option&amp;lt;i32&amp;gt;&lt;/code&gt; to return an optional integer to Swift‚Äôs &lt;code&gt;-&amp;gt; Int?&lt;/code&gt;. I am quite confident that I‚Äôll miss that trailing &lt;code&gt;?&lt;/code&gt; somewhere along the way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I‚Äôm sure there‚Äôs a reason for Swift‚Äôs internal and external parameter names and the rules about using &lt;code&gt;_&lt;/code&gt; to elide the need to use keyword arguments (but automatically eliding the first one) and so on‚Ä¶ but I really can‚Äôt see the utility, overall. It seems like it would be better just to have Python-like args and keyword args.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That‚Äôs doubly so given that Swift‚Äôs rules for default-valued parameters map exactly to Python‚Äôs: they need to go at the end, after any parameters which don‚Äôt have default values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs variadic parameters are nice‚Äîthough of course limited, since if you have more than one, the compiler may not know how to resolve which destination parameter a given argument belongs with. (I imagine the compiler &lt;em&gt;could&lt;/em&gt; be extended to be able to handle multiple variadic parameters as long as they were all of different types, but that‚Äôs probably not worth the work or the potential confusion it would introduce.) In any case, it‚Äôs a small nicety that I do wish Rust had.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs variable parameters are‚Ä¶ interesting. I can see the utility, sort of, but (probably from years of habit with C and Python and pass-by-reference types), it‚Äôs just not a pattern that makes a lot of sense to me right now. No doubt I‚Äôll get used to them in idiomatic Swift, but while Rust doesn‚Äôt have a similar feature, I suspect I won‚Äôt miss it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In/out parameters‚Äîthat is, mutable pass-by-reference types‚Äîare available in both languages. The syntax is &lt;em&gt;very&lt;/em&gt; different here, as are the semantics.&lt;/p&gt;
&lt;p&gt;Swift has the &lt;code&gt;inout&lt;/code&gt; keyword, supplied before a parameter definition:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func adds4ToInput(inout num: Int) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust has instead a variation on every other type definition, declaring the type in this case to be a mutable reference:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn adds_4_to_input(num: &amp;amp;mut i32) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, in other words, Swift opts to use new syntax (in this case, a dedicated keyword) while Rust opts to use the same syntax used everywhere else to denote a mutable reference. In fairness to Swift, though, this is something of a necessity there. From what I‚Äôve seen so far, Swift generally doesn‚Äôt (and perhaps can‚Äôt?) do pointers or references explicitly (though of course it‚Äôs handling lots of things that way under the covers); arguments to functions are a special case, presumably present primarily for interoperability with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs function type definitions, as used in e.g.¬†function parameter definitions, are quite nice, and reminiscent of Haskell in the best way. Rust‚Äôs are pretty similar, and add in its &lt;code&gt;trait&lt;/code&gt; usage‚Äîbecause functions types &lt;em&gt;are&lt;/em&gt; &lt;code&gt;trait&lt;/code&gt;s. Once again, I really appreciate how Rust builds more complicated pieces of functionality on lower-level constructs in the language. (Swift may be doing similar under the covers, but the Swift book doesn‚Äôt say.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Again, though, the downside to Rust‚Äôs sophistication is that it sometimes bundles in some complexity. Returning a function in Swift is incredibly straightforward:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func getDoubler() -&amp;gt; (Int) -&amp;gt; Int {
    func doubler(number: Int) -&amp;gt; Int {
        return number * 2
    }

    return doubler
}

func main() {
    let doubler = getDoubler()
    println(&amp;quot;\(doubler(14))&amp;quot;)  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doing the same in Rust is a bit harder, because‚Äîas of the 1.3 stable/1.5 nightly timeframe‚Äîit requires you to explicitly heap-allocate the function. Swift just takes care of this for you.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn get_doubler() -&amp;gt; Box&amp;lt;Fn(i32) -&amp;gt; i32&amp;gt; {
    fn doubler(number: i32) -&amp;gt; i32 {
        number * 2
    }

    Box::new(doubler)
}

fn main() {
    let doubler = get_doubler();
    println!(&amp;quot;{:}&amp;quot;, doubler(14));  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you understand what‚Äôs going on under the covers here, this makes sense: Rust normally stack-allocates a function in a scope, and therefore the &lt;code&gt;doubler&lt;/code&gt; function goes out of scope entirely when the &lt;code&gt;get_doubler&lt;/code&gt; function returns if you don‚Äôt heap-allocate it with &lt;code&gt;Box::new&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In both languages, closures and ‚Äúordinary‚Äù functions are variations on the same underlying functionality (as it should be). In Rust‚Äôs case, functions and closures both implement the &lt;code&gt;Fn&lt;/code&gt; trait. In Swift‚Äôs case, named functions are a special case of closures.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Swift syntax for a closure is, well, a bit odd to my eye. The basic form is like this (with the same ‚Äúdoubler‚Äù functionality as above):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ (n: Int) -&amp;gt; Int in return n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For brevity, this can collapse down to the shorter form with types inferred from context, parentheses dropped and the &lt;code&gt;return&lt;/code&gt; keyword inferred from the fact that the closure has only a single expression (note that this wouldn‚Äôt be valid unless in a context where the type of &lt;code&gt;n&lt;/code&gt; could be inferred):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ n in n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The simplicity here is nice, reminiscent in a good way of closures/lambdas in other languages.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; The fact that it‚Äôs a special case is less to my taste.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust‚Äôs closure syntax is fairly similar to Swift‚Äôs brief syntax. More importantly, there‚Äôs no special handling for closures‚Äô final expressions. Remember: the final expression of &lt;em&gt;any&lt;/em&gt; block is always returned in Rust.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n| n * 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to fully annotate the types, as in the first Swift example, it would be like so:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n: i32| -&amp;gt; i32 { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are even &lt;em&gt;more&lt;/em&gt; differences between the two, because of Rust‚Äôs ownership notion and the associated need to think about whether a given closure is being borrowed or moved (if the latter, explicitly using the &lt;code&gt;move&lt;/code&gt; keyword).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the notion of shorthand argument names for use with closures.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; The arguments to a closure get the default names &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, etc. This gets you even &lt;em&gt;more&lt;/em&gt; brevity, and is quite convenient in cases where closures get used a lot (&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ $0 * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If that weren‚Äôt enough, Swift will go so far as to simply reuse operators (which are special syntax for functions) as closures. So a closure call could simply be &lt;code&gt;+&lt;/code&gt; for a function expecting a closure operating on two numbers; Swift will infer that it needs to map back to the relevant method definition on the appropriate type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The upside to this is that the code can be incredibly brief, and‚Äîonce you‚Äôre used to it, at least‚Äîstill fairly clear. The downside to this is yet &lt;em&gt;more&lt;/em&gt; syntax for Swift, and the ever-growing list of things to remember and ways to write the same thing I expect will lead to quite a bit of instability as the community sorts out some expectations for what is idiomatic in any given instance.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And if that weren‚Äôt enough, there is more than one way to supply the body of a closure to a Swift function that expects it: you can supply a block (&lt;code&gt;{ /* closure body */ }&lt;/code&gt;) &lt;em&gt;after&lt;/em&gt; the function which expects it. Yes, this can end up looking nearly identical to the form for declaring a function:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure() { n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you can also drop the parentheses if that‚Äôs the only argument.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In terms of the &lt;em&gt;mechanics&lt;/em&gt; of closures, and not just the syntax, the one significant difference between Rust and Swift is the same one we‚Äôve seen in general between the two languages: Swift handles the memory issues automatically; Rust makes you be explicit about ownership. That is, as noted above about the closures themselves, in Rust you may have to &lt;code&gt;move&lt;/code&gt; ownership to get the expected behavior. Both behave basically like closures in any other language, though; nothing surprising here. Both also automatically copy values, rather than using references, whever it makes sense to do so.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift autoclosures allow for lazy evaluation, which is neat, but: &lt;em&gt;yet more syntax&lt;/em&gt;! Seriously. But I think all its other closure syntaxes &lt;em&gt;also&lt;/em&gt; allow for lazy evaluation. The only reason I can see to have the special attribute (&lt;code&gt;@autoclosure&lt;/code&gt;) here is because they added this syntax. And this syntax exists so that you can call functions which take closures as if they &lt;em&gt;don‚Äôt&lt;/em&gt; take closures, but rather the argument the closure itself takes. But of course, this leads the Swift book to include the following warning:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that the evaluation is being deferred.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes, care needed indeed. (Or, perhaps, you could just avoid adding more special syntax that leads to unexpected behaviors?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Good grief. I‚Äôm tired now. That‚Äôs a half-dozen variants on &lt;em&gt;closure syntax&lt;/em&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remember: there‚Äôs still just one way to write and use a closure in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This takes me back to something I noticed &lt;a href="/2015/rust-and-swift-ii.html"&gt;early on&lt;/a&gt; in my analysis of the two languages. In Swift, there‚Äôs nearly always more than one way to do things. In Rust, there‚Äôs usually one way to do things. Swift prefers brevity. Rust prefers to be explicit. In other words, Swift borrows more of its philosophy from Perl; Rust more from Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I‚Äôm a Python guy, through and through. Perl drives me crazy every time I try to learn it. You could guess (even if you hadn‚Äôt already seen) where this lands me between Rust and Swift.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is incredibly long, but I blame that on the (frankly incredible) number of variants Swift has on the same concept.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ix.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Compare the closure syntaxes especially in Ruby and ES6+.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;For a similar example in another up-and-coming language, see &lt;a href="http://elixir-lang.org/getting-started/modules.html#function-capturing"&gt;Elixir&lt;/a&gt;, which does almost exactly the same but with &lt;code&gt;&amp;amp;&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Oct 2015 20:15:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-10-18:2015/rust-and-swift-viii.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>2015-10-17 15:21</title><link>http://www.chriskrycho.com/2015/2015-10-17-1521.html</link><description>&lt;p&gt;This is interesting: I‚Äôve read some F‚ôØ before, but it reads a &lt;em&gt;lot&lt;/em&gt; more obviously to me now that I‚Äôve read a lot of Rust recently. Why? Because for all that they‚Äôre very different languages, both are ML descendants. It shows.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Oct 2015 15:21:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-10-17:2015/2015-10-17-1521.html</guid><category>programming languages</category><category>rust</category><category>fsharp</category></item><item><title>Rust and Swift (vii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Both Rust and Swift have &lt;em&gt;pattern-matching&lt;/em&gt;, and with what appears to be fairly similar basic behavior. (I touched on this briefly in my &lt;a href="/2015/rust-and-swift-i.html"&gt;first post in the series&lt;/a&gt;.) In Rust this goes under the &lt;code&gt;match&lt;/code&gt; construct, with matches specified like &lt;code&gt;&amp;lt;pattern&amp;gt; =&amp;gt; &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;if&lt;/code&gt; expressions. In Swift, patterns are matched using the &lt;code&gt;switch&lt;/code&gt; construct, with matches specified like &lt;code&gt;case &amp;lt;pattern&amp;gt;: &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;where&lt;/code&gt; expressions. (&lt;code&gt;where&lt;/code&gt; is also used in Rust, but for generic constraints, not pattern match guards.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow you to bind names to a matched pattern: Swift with &lt;code&gt;case let &amp;lt;name&amp;gt;&lt;/code&gt; and Rust simply by using the name in a normal destructuring expression as part of the match definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; that‚Äôs not &lt;em&gt;quite&lt;/em&gt; right. In Rust, you use the &lt;code&gt;@&lt;/code&gt; operator with the variable name you want to bind in the match.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit the second:&lt;/strong&gt; I was mixed up, because Rust actually has &lt;em&gt;both&lt;/em&gt; of those options. You can either match directly, e.g.¬†when getting the value of an &lt;code&gt;Option&lt;/code&gt; type: &lt;code&gt;Some(value)&lt;/code&gt; as the pattern will bind &lt;code&gt;value&lt;/code&gt;. But if you need to bind a specific part of more complicated data structure, the &lt;code&gt;@&lt;/code&gt; operator is present to let you do it in a fairly straightforward way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow for the use of &lt;code&gt;_&lt;/code&gt; as a ‚Äúwildcard‚Äù in match definitions. Since match definitions in Rust use the patterns directly, the equivalent of Swift‚Äôs C-like &lt;code&gt;default&lt;/code&gt; is simply a wildcard match pattern (&lt;code&gt;_ =&amp;gt; &amp;lt;-expression|statement&amp;gt;&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One significant difference: like its &lt;code&gt;if&lt;/code&gt; blocks, Rust‚Äôs &lt;code&gt;match&lt;/code&gt; blocks are expressions, so they can be assigned. I.e., you can write this:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let test = 5u32;
let description = match test {
    0..10 =&amp;gt; &amp;quot;less than ten&amp;quot;,
        _ =&amp;gt; &amp;quot;greater than ten&amp;quot;,
}
println!(&amp;quot;{?:}&amp;quot;);  // &amp;quot;less than ten&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift doesn‚Äôt let you do this; the same thing there would be written like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let test: UInt32 = 5
var description: String
switch test {
    case 0..&amp;lt;10:
        description = &amp;quot;less than ten&amp;quot;
    default:
        description = &amp;quot;greater than ten&amp;quot;
}
println(&amp;quot;\(description)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages have &lt;code&gt;break&lt;/code&gt; statements, but in Rust they‚Äôre only used in loop constructs, while Swift (like C) uses them to escape &lt;code&gt;case&lt;/code&gt;s as well. The Swift book gives an example of one place they‚Äôre necessary in a &lt;code&gt;switch&lt;/code&gt;: to match a case and do nothing there (e.g. &lt;code&gt;default: break&lt;/code&gt;). In Rust, you would simply supply an empty block for that scenario (e.g. &lt;code&gt;_ =&amp;gt; {}&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Correctly, both languages force you to match exhaustively on relevant patterns. If you‚Äôre matching an enumerated type, for example, you must handle every enumerated value. You can of course do this with wildcard patterns or with Swift‚Äôs &lt;code&gt;default&lt;/code&gt;, but the good thing is that both languages will refuse even to compile if a given pattern isn‚Äôt matched.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift‚Äôs default behavior around its &lt;code&gt;switch&lt;/code&gt; statements is sane: it does &lt;em&gt;not&lt;/em&gt; automatically fall through into the next statement. It does let you do this, without checking the condition on the next statement (as in C), using the &lt;code&gt;fallthrough&lt;/code&gt; keyword. Rust, by contrast, simply doesn‚Äôt allow this at all.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages supply named control statements (loops, etc.), with slightly different syntax for naming them. Rust‚Äôs, curiously, shares its syntax with lifetime definitions‚Äîmore on those in a future post.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I don‚Äôt believe Rust has anything quite like Swift‚Äôs &lt;code&gt;guard&lt;/code&gt;s, which allow you to leave normal or expected control flow in the main body of a block, with a secondary block for cases where the &lt;code&gt;guard&lt;/code&gt; isn‚Äôt matched. This isn‚Äôt a huge deal, but it does fit as a nice convenience into the typical &lt;code&gt;if let&lt;/code&gt; pattern in Swift. Basically, it just lets you elide an empty &lt;code&gt;if&lt;/code&gt; block and supply only the &lt;code&gt;else&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/64804111"&gt;points out&lt;/a&gt; that Swift &lt;code&gt;guard&lt;/code&gt;s also require you to exit the current scope, so it‚Äôs unambiguous what you‚Äôre doing if you use them.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 20 Sep 2015 13:42:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-19:2015/rust-and-swift-vii.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (vi)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;It kind of feels like this summarizes a &lt;em&gt;lot&lt;/em&gt; of things about the overall design of Swift:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array. ‚Äî&lt;em&gt;The Swift Programming Language (Swift 2 Prerelease)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The documentation for the various types in Rust‚Äôs &lt;code&gt;std::collections&lt;/code&gt; module is hilarious and great. Highly recommended.&lt;/p&gt;
&lt;p&gt;One thing that jumped out at me reading this chapter of the Swift book (though I don‚Äôt think it‚Äôs been explicitly discussed yet): Rust doesn‚Äôt have named parameters; Swift does. There are good reasons for that in both cases, but I suspect this is one of the small details I‚Äôll miss the most in Rust. I‚Äôve been spoiled by Python.&lt;/p&gt;
&lt;p&gt;Swift‚Äôs &lt;code&gt;Array&lt;/code&gt; type is analogous to Rust‚Äôs &lt;code&gt;Vec&lt;/code&gt; type (usually created with the &lt;code&gt;vec!&lt;/code&gt; macro), &lt;em&gt;not&lt;/em&gt; its &lt;code&gt;Array&lt;/code&gt; type. Rust &lt;code&gt;Vec&lt;/code&gt;s and Swift &lt;code&gt;Array&lt;/code&gt;s are dynamically sized and created on the heap, whereas Rust‚Äôs &lt;code&gt;Array&lt;/code&gt;s are statically sized and created on the stack. Syntax for creating &lt;code&gt;Array&lt;/code&gt;s in both languages is quite similar (though the results are different):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array: [Int] = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array: [i32, 3] = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That‚Äôs the long form, of course; both languages have type inference, so you‚Äôd rarely write it like that. The usual form would be with the type in all of those cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rust also adds the concept of ‚Äúslices,‚Äù which provide access to segments of arrays, and are heap-allocated as pointers to a given item in the array and a length (number of elements) included.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; operations in Swift are all pretty reasonable, and surprisingly descriptive. They remind me in a good way of Python‚Äôs &lt;code&gt;list&lt;/code&gt; methods.&lt;/p&gt;
&lt;p&gt;There are a &lt;em&gt;lot&lt;/em&gt; of &lt;a href="http://doc.rust-lang.org/stable/std/vec/struct.Vec.html"&gt;ways to interact with &lt;code&gt;Vec&lt;/code&gt;s in Rust&lt;/a&gt;. (That‚Äôs not a bad thing.) A bit surprising to me was the absence of an &lt;code&gt;enumerate&lt;/code&gt; method, on &lt;code&gt;Vec&lt;/code&gt; itself, but then I discovered that it exists in the &lt;code&gt;IntoIter&lt;/code&gt; struct in the same module, which fully implements the &lt;code&gt;Iterator&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;. As a result, it has an &lt;code&gt;enumerate&lt;/code&gt; function returning an &lt;code&gt;Enumerate&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; instance. (Under the covers, I suspect Swift &lt;code&gt;Array&lt;/code&gt;s just implement an &lt;code&gt;Iterable&lt;/code&gt; &lt;code&gt;protocol&lt;/code&gt;, which is similar to this approach in some ways.)&lt;/p&gt;
&lt;p&gt;This makes a point I‚Äôm coming back to fairly often: Rust doesn‚Äôt necessarily put everything on a single object definition, but rather into a set of related &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; types and &lt;code&gt;trait&lt;/code&gt;s. This is really powerful, but it‚Äôs going to take some mental adjustment. In this way, Swift‚Äôs structure and semantics are much more like the languages I‚Äôm used to than Rust‚Äôs are (but even there, the use of &lt;code&gt;protocols&lt;/code&gt; gives it considerable new flexibility).&lt;/p&gt;
&lt;p&gt;Note that I said &lt;em&gt;semantics&lt;/em&gt;, not syntax. Swift and Rust are a great example of how very similar syntax can mask differences in semantics. (For another such example, compare JavaScript‚Äôs syntax and semantics to Java‚Äôs: they‚Äôre superficially similar syntactically, and light years apart semantically.)&lt;/p&gt;
&lt;p&gt;Swift‚Äôs &lt;code&gt;Set&lt;/code&gt; type and Rust‚Äôs roughly analogous &lt;code&gt;HashSet&lt;/code&gt; both have a &lt;code&gt;contains&lt;/code&gt; method which behaves much like Python‚Äôs &lt;code&gt;in&lt;/code&gt; keyword. Indeed, and perhaps unsurprisingly, the two types implement many of the same methods in general. This is perhaps to be expected given that the language around sets (as a mathematical concept being mapped down into a representation in a program) is quite standardized.&lt;/p&gt;
&lt;p&gt;Because of their stricter typing systems, both Rust and Swift require you to specify the types used in their mapping constructs (Rust has &lt;code&gt;HashMap&lt;/code&gt; and Swift has &lt;code&gt;Dictionary&lt;/code&gt;), though of course both can infer this as well in certain cases. At the most basic level, you can‚Äôt use arbitrary (hashable) types as keys in mixed fashion like you can in e.g.¬†Python‚Äôs &lt;code&gt;dict&lt;/code&gt; type, but in practice this shouldn‚Äôt matter, for two reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It‚Äôs generally inadvisable to use different types for keys in the same dictionary anyway. To me, at least, that usually indicates the need to step back and think more carefully about the types and data structures I‚Äôm using.&lt;/li&gt;
&lt;li&gt;For the occasional case where it &lt;em&gt;is&lt;/em&gt; appropriate, I wonder if you could declare the type as generic in either Rust or Swift. I‚Äôm putting this down as a TODO item for myself to find out!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I really wish that Swift used the Python-style curly-brace delimited syntax (&lt;code&gt;{'key': 'value'}&lt;/code&gt;) for its dictionary literal initializers. I can see, from a syntax reason, why it doesn‚Äôt: that would overload the block syntax (which Python can avoid because it‚Äôs white-space delimited). But it‚Äôs &lt;em&gt;really&lt;/em&gt; convenient.&lt;/p&gt;
&lt;p&gt;Along similar lines, I can see why the Swift designers chose to make all iterables have literal initializers using braces (&lt;code&gt;[...]&lt;/code&gt;); it makes parsing fairly straightforward. However, the result is that it‚Äôs pretty difficult to see at first glance what you‚Äôre dealing with. It could quite easily be an &lt;code&gt;Array&lt;/code&gt;, a &lt;code&gt;Set&lt;/code&gt;, or a &lt;code&gt;Dictionary&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This highlights a too-little-appreciated aspect of programming language design: &lt;em&gt;readability&lt;/em&gt;. However much we programmers enjoy writing code, the reality is that we will all spend a great deal of our time‚Äîprobably even a majority of it‚Äîreading it instead. Thus, while we should care about conveniences for writing code, and being overly verbose can be a pain, we should also concern ourselves with the ease of comprehending code when it is read, and the syntax and conventions a language embraces are a big part of this.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Dictionary&lt;/code&gt; type in Swift is a pretty close analog to Python‚Äôs &lt;code&gt;dict&lt;/code&gt;, right down to several of the method names. the same is true of Rust‚Äôs &lt;code&gt;HashMap&lt;/code&gt;. That‚Äôs not a bad thing by any stretch of the imagination.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 Sep 2015 09:00:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-19:2015/rust-and-swift-vi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (v)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-v.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I‚Äôve been working on learning Swift over the past couple weeks, and had spent the month prior to that doing a deep first dive on Rust. This kind of approach, learning two languages basically at the same time, is entirely new to me, and for good reason. Programming languages are not trivial to learn, and to learn them meaningfully one must practice with them a great deal.&lt;/p&gt;
&lt;p&gt;I‚Äôm doing this largely of necessity. I‚Äôm hoping to build an application with a very capable, performant cross-platform core language (Rust), but planning to ship a native OS X app (first) when all is said and done. My desire to make the core libraries portable rules out Swift immediately. To be frank, so does the fact that it‚Äôs an Apple language: I am happy to use Apple‚Äôs tools on its platform, but I don‚Äôt want to shackle myself to their choices in the long run. Too, having good Rust experience is likely to be valuable in many other contexts.&lt;/p&gt;
&lt;p&gt;So I need to learn both.&lt;/p&gt;
&lt;p&gt;And, while I wouldn‚Äôt ordinarily recommend this course of action‚Äîindeed, unless you already have a fair bit of programming experience and already know several languages, I‚Äôd actively recommend against it‚ÄîI‚Äôm finding it enormously profitable. The languages have been designed in roughly the same time frame, cite many of the same influences, and overlap substantially in terms of audience and goals. Yet they are, as this series has already highlighted, quite different languages in many ways.&lt;/p&gt;
&lt;p&gt;Learning them in parallel is helping me see the trade-offs each one has made, and force me to think about &lt;em&gt;why&lt;/em&gt; they differ in the ways they do. In particular, I think I have a much better idea what‚Äôs going on ‚Äúunder the covers‚Äù in each language and therefore know what to expect of them better. This, in turn, has dramatically deepened my grasp of the languages relative to the amount I‚Äôve been looking at them, compared to previous language-learning efforts. (It also helps that I‚Äôve already learned a number of languages, of course, and that I‚Äôve been pushing my brain into the learning-programming-languages space via reading about Haskell, functional patterns in JavaScript, and so on this year.)&lt;/p&gt;
&lt;p&gt;I have a long way to go in both languages, of course. Reading on nights and weekends, and the little bit of playing I‚Äôve been able to do with each of them, is no replacement for just sinking my teeth into a project and finding the pain points. Nonetheless, I‚Äôm really glad to be learning these two languages &lt;em&gt;together&lt;/em&gt;. If you‚Äôre up for a challenge, try it sometime! You‚Äôll be surprised how much you learn.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 13:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-12:2015/rust-and-swift-v.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>If-expressions in Rust</title><link>http://www.chriskrycho.com/2015/if-expressions-in-rust.html</link><description>&lt;p&gt;I love the fact that all &lt;code&gt;if&lt;/code&gt; statements in Rust are expressions. It gives you a great deal of expressitivity in the language.&lt;/p&gt;
&lt;p&gt;Let‚Äôs contrast with Python (which I love, for the record). In Python, you can do something like this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
if some_condition:
    a_value = &amp;quot;Yeah!&amp;quot;
else:
    a_value = &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those are &lt;em&gt;statements&lt;/em&gt; in the body of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; block; you can‚Äôt assign the block itself to &lt;code&gt;a_value&lt;/code&gt;. However, like C, C++, Java, etc., Python does provide an &lt;em&gt;expression&lt;/em&gt;-type conditional, a ternary expression.&lt;/p&gt;
&lt;p&gt;So you can also do this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
a_value = &amp;quot;Yeah&amp;quot; if some_condition else &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This expression form of the &lt;code&gt;if&lt;/code&gt; block is what all Rust &lt;code&gt;if&lt;/code&gt; blocks are. So in Rust, the normal long form is:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    &amp;quot;Yeah!&amp;quot;
}
else {
    &amp;quot;Oh, sads.&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You could also write this with a &lt;code&gt;let mut a_value&lt;/code&gt; and then set its value inside the conditional blocks, but that‚Äôs not at all good form in Rust.)&lt;/p&gt;
&lt;p&gt;And of course, you can shorten that rather nicely where the expressions are brief enough:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition { &amp;quot;Yeah!&amp;quot; } else { &amp;quot;Oh, sads.&amp;quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this gets really nice when you have more complicated work to do in a Rust conditional. It doesn‚Äôt matter how many things going on inside an &lt;code&gt;if&lt;/code&gt; expression; it‚Äôs still an expression. As such, you can also write this:&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    let the_answer = 42;
    let theme = &amp;quot;Take my love, take my land...&amp;quot;;
    &amp;quot;Yeah!&amp;quot;  // An expression!
}
else {
    let the_question = &amp;quot;What do you get when you multiply six by nine?&amp;quot;;
    let song = &amp;quot;You can&amp;#39;t take the sky from me!&amp;quot;;
    &amp;quot;Oh, sads.&amp;quot;  // An expression!
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously this is totally contrived and silly; the point is that no matter what the internals are, &lt;code&gt;if&lt;/code&gt; blocks are expressions, and their final expressions can be assigned like any other.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;As a note: I got here because I was originally thinking you couldn‚Äôt do a one-liner like you can in Python. As shown above, that‚Äôs totally false, and in fact the Rust version is much more capable than Python‚Äôs, because you don‚Äôt need a dedicated ternary when all &lt;code&gt;if&lt;/code&gt; blocks are expressions. Rust used to have a C-style ternary (&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;value if true&amp;gt; : &amp;lt;value if false&amp;gt;&lt;/code&gt;) but it was &lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;removed&lt;/a&gt; during the lead-up to the 1.0 release‚Äîa decision I wholeheartedly affirm.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that under normal conditions the compiler won‚Äôt actually accept this because of the unused names.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 11:10:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-12:2015/if-expressions-in-rust.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>python</category></item><item><title>2015-09-11 12:50</title><link>http://www.chriskrycho.com/2015/2015-09-11-1250.html</link><description>&lt;p&gt;Since Rust allows &lt;a href="https://doc.rust-lang.org/book/unsafe.html"&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; code, it‚Äôs easy to wonder how necessary it is. The answer: in general, &lt;a href="https://github.com/iron/iron#overview" title="&amp;#39;Iron&amp;#39; Rust web framework"&gt;not at all&lt;/a&gt;.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 Sep 2015 13:30:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-11:2015/2015-09-11-1250.html</guid><category>programming languages</category><category>rust</category></item><item><title>Rust and Swift (iv)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Both Swift and Rust directly address the issue of having to worry about memory allocation and safety. They do it in different ways, though: Swift by automatic reference counting, Rust by its concept of ownership. For a lot of day-to-day development, I can see the Swift approach being a win for the same reason a language like Python or Ruby is: having that all handled for you is &lt;em&gt;nice&lt;/em&gt;. Having the power Rust gives you comes at the price of increased cognitive load from having to reason about ownership.&lt;/p&gt;
&lt;p&gt;To put it another way: all programming languages have to make trade offs. Although I like Rust‚Äôs better than Swift‚Äôs so far, I‚Äôve no doubt I will find any number of things to appreciate about Swift over Rust. You can‚Äôt have everything.&lt;/p&gt;
&lt;p&gt;This caught my attention in part because dealing with things like strings (or other pass-by-value types) in Swift is rather more straightforward than in Rust. The outcomes are much the same, but since &lt;em&gt;all&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s in Swift are passed by value (never by reference), you simply don‚Äôt have to think about modification‚Äîeven safe modification!&lt;/p&gt;
&lt;p&gt;Rust of course had the &lt;code&gt;Copy&lt;/code&gt; trait which lets you do this, but the point is that the ‚Äúergonomics‚Äù are slightly nicer in Swift.&lt;/p&gt;
&lt;p&gt;Also, the string interpolation Swift does is &lt;em&gt;nice&lt;/em&gt;. That‚Äôs one thing I really wish Rust had. It‚Äôs Python-style string formatting macro is great, but being able to interpolate values (&lt;code&gt;&amp;quot;strings with \(variables)&amp;quot;&lt;/code&gt; or even &lt;code&gt;&amp;quot;embedded expressions like \(2 + 4)&amp;quot;&lt;/code&gt;) is very nice.&lt;/p&gt;
&lt;p&gt;Swift‚Äôs approach to strings in general seems well-thought-through and gives appropriate levels of attention to the details which make handling complex or non-Western languages much more manageable. As a typography geek, I appreciate this a great deal.&lt;/p&gt;
&lt;p&gt;That said, since Swift‚Äôs strings &lt;em&gt;do&lt;/em&gt; handle all those edge cases for Unicode, you lose some standard string access patterns and lose much (maybe all?) insight into the internal structure of the string. That may be good, and may be bad, depending on the circumstance. Like I said: trade-offs.&lt;/p&gt;
&lt;p&gt;Actually, on reading further, the way Swift handles Unicode strings is pretty nice. It &lt;em&gt;does&lt;/em&gt; give you insight into those, via specific methods for different representations. I particularly appreciate that it‚Äôs you deal with them as the standalone &lt;code&gt;String&lt;/code&gt; type as well as giving you direct access to the code points‚Äîand not just one Unicode code point set, but any of &lt;abbr&gt;UTF8&lt;/abbr&gt;, &lt;abbr&gt;UTF16&lt;/abbr&gt;, or &lt;abbr&gt;UTF32&lt;/abbr&gt; (Unicode scalars). Trust Apple to pay close attention to text.&lt;/p&gt;
&lt;p&gt;Rust‚Äôs strings are &lt;em&gt;good&lt;/em&gt;, but not quite as sophisticated (presumably for simplicity around the memory mapping). All Rust &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;str&lt;/code&gt; instances are composed of &lt;abbr&gt;UTF32&lt;/abbr&gt; Unicode scalars, encoded as &lt;abbr&gt;UTF8&lt;/abbr&gt; sequences. It doesn‚Äôt have some of the convenience methods Swift does for getting any of the other representations. That said, I expect this should show up rarely if at all in my ordinary usage. Importantly, the fundamental storage is the same: both use scalars.&lt;/p&gt;
&lt;p&gt;This was the first section where it didn‚Äôt feel like Rust was just a clear overall ‚Äúwinner‚Äù over Swift. Some of the trade offs between the language designs are more apparent here, and I do appreciate the ‚Äúergonomics‚Äù of Swift in a number of these things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Sep 2015 21:05:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-10:2015/rust-and-swift-iv.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (iii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I just hit operators in the Swift book. First question: are operators special syntax, or are they sugar for &lt;code&gt;protocol&lt;/code&gt;s? (Every modern language I use or even have played with handles them as sugar for another language construct‚ÄîPython, Ruby, Io, Elixir, and Rust, to name just a few ranging over a substantial variety of ages and styles.)&lt;/p&gt;
&lt;p&gt;Oh. I did the requisite digging, and operators are functions (which is okay) defined in the &lt;del&gt;global namespace (&lt;em&gt;:sigh:&lt;/em&gt;)&lt;/del&gt; Swift module.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I say ‚Äúokay‚Äù rather than good because the justification offered is that this is the only way to make the operators work as binary operators between existing instances of types. But that elides the fact that, if that‚Äôs the case, it is so because of other language design decisions. This seems like a perfect place to use a &lt;code&gt;protocol&lt;/code&gt;, but perhaps (unlike Rust‚Äôs &lt;code&gt;trait&lt;/code&gt;) they‚Äôre not sufficiently capable to handle this? That‚Äôs an open question; I have no idea about the answer.&lt;/p&gt;
&lt;p&gt;Interestingly, Rust has several fewer operators than Swift, even apart from those mentioned in my &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;previous post&lt;/a&gt;. It drops the pre- and post-increment operators entirely (as does Python), since their results can always be accomplished in other ways with less potential for confusion. Swift keeps them, no doubt in part because most (Objective) C programs are deeply familiar with them and with idioms associated with them.&lt;/p&gt;
&lt;p&gt;I learned a few new things about Rust‚Äôs operators as well: the Boolean &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators and its bitwise &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operators differ not only in that the former are &lt;em&gt;short-circuit&lt;/em&gt; operators and the latter are not. Obviously you can also do things like bit-wise flag operations with the latter, but the reference emphasizes the short-circuiting behavior. This makes perfect sense, but it wasn‚Äôt something I‚Äôd ever considered explicitly before.&lt;/p&gt;
&lt;p&gt;There is no ternary operator in Rust, because of how it handles the relationship between expressions and statements. Swift keeps it. That‚Äôs an interesting reflection of differences in design: Rust dropped it because &lt;code&gt;if&lt;/code&gt; blocks are expressions, so it‚Äôs redundant, and they have had a goal of removing unnecessary features. (See the discussion on dropping the ternary operator‚Äîwith an interesting aside from Brendan Eich on JavaScript‚Äî&lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;here&lt;/a&gt;). Note that this is not a criticism of Swift, just an observation, though I do really like Rust‚Äôs expression-driven approach.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; ‚Äúnil coalescing operator‚Äù, on the other hand, I actively dislike. This seems like shorthand for the sake of shorthand, partly necessitated by the existing drive toward shorthand with optional types in Swift. Sometimes brevity can lead to decreased clarity. Eliding too much, or subsuming it into shorthand, makes the language harder to hold in your head and requires you to slow down more for parsing each line.&lt;/p&gt;
&lt;p&gt;Nothing surprising (or different) between the standard boolean operators in the two languages.&lt;/p&gt;
&lt;p&gt;I wonder how many times the word ‚Äúconcise‚Äù (or synonyms of it) appear in the Swift book? It‚Äôs increasingly clear to me reading that brevity is one of the primary design goals. Maybe it‚Äôs just me, but that actually seems a little weird. Brevity is good so far as it goes, but &lt;em&gt;legibility&lt;/em&gt; is much better.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;See edit in discussion of functions and global namespace in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;part ii&lt;/a&gt;.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Mar 2016 23:10:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-09-07:2015/rust-and-swift-iii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (ii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I‚Äôd be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;At first blush, I find the extra syntax around optionals in Swift more confusing than helpful. I think this comes down to my preference for a more Python-like approach: ‚ÄúExplicit is better than implicit‚Äù and ‚ÄúThere should be one‚Äì and preferably only one ‚Äìobvious way to do it‚Äù both militate against the multiple different ways you can handle optional values in Swift. &lt;code&gt;Optional&lt;/code&gt; types are created in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with the &lt;code&gt;?&lt;/code&gt; operator on a type definition, creating an explicitly wrapped type which must be checked in some way.&lt;/li&gt;
&lt;li&gt;with the &lt;code&gt;!&lt;/code&gt; operator on a type definition, creating an ‚Äúimplicitly unwrapped optional‚Äù by forcibly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After creating an optional, you can get at its contents by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;while let&lt;/code&gt; constructs to bind the optional value‚Äôs non-&lt;code&gt;nil&lt;/code&gt; value for a block&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;!&lt;/code&gt; operator on a variable name, explicitly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By contrast, in Rust you always have to explicitly unwrap the item, using the &lt;code&gt;unwrap&lt;/code&gt; method or pattern matching. There are no implicitly unwrapped types. Moreover, there is no special syntax around creating optional types in Rust: you just declare them with an &lt;code&gt;Option&lt;/code&gt; type or another type that &lt;code&gt;impl&lt;/code&gt;s the &lt;code&gt;Option&lt;/code&gt; behavior. The ‚Äúshortcut‚Äù behavior around error handling, &lt;code&gt;try!&lt;/code&gt;, isn‚Äôt special syntax, but application of another standard language construct (in this case, a macro).&lt;/p&gt;
&lt;p&gt;The discussion of &lt;code&gt;assert&lt;/code&gt; in the Swift book re-raises the question about the global namespace:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ÄúYou write an assertion by calling the global &lt;code&gt;assert(_:_:)&lt;/code&gt; function.‚Äù&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This continues to suggest strongly that Swift does in fact have a true global namespace, &lt;em&gt;not&lt;/em&gt; an automatically-imported prelude. That can make a big difference for applications in certain spaces (e.g.¬†systems programming), when you might have good reason to want to replace the standard library‚Äôs approach with a different one. (See Rust‚Äôs &lt;a href="https://doc.rust-lang.org/book/no-stdlib.html"&gt;&lt;code&gt;#[no_std]&lt;/code&gt;&lt;/a&gt; docs and the &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md"&gt;related RFC&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; ‚Äústrongly suggests‚Äù or no, I have now been &lt;a href="https://twitter.com/jckarter/status/708765262309228544" title="Tweet by one of the Swift developers"&gt;reliably informed&lt;/a&gt; that I was mistaken‚Äîand am happy to have been wrong here. As in Haskell, these functions are implicitly imported and belong to the &lt;code&gt;Swift&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;In Rust, &lt;code&gt;assert!&lt;/code&gt; is a macro, not a function, which is an interesting but perhaps not &lt;em&gt;especially&lt;/em&gt; important distinction in this particular case. (It might be, though; I‚Äôd have to see the implementation of each to see how they play out differently.)&lt;/p&gt;
&lt;p&gt;In any case, this also highlights another large difference between the two: testing is &lt;a href="https://doc.rust-lang.org/stable/book/testing.html"&gt;front and center&lt;/a&gt; in Rust, and barely receives a mention so far in the Swift book (and isn‚Äôt in the table of contents). Having language-level support for testing is a big deal.&lt;/p&gt;
&lt;p&gt;Language tour and first chapter of the language guide down, my sense is that Swift is a substantially better language than C or C++ (and presumably than Objective C, but since I don‚Äôt know that language I can‚Äôt speak to it) for app design, but that Rust is a better language yet. Both a far more modern than their predecessors, but they approach the same problems in surprisingly different ways, relatively similar syntax notwithstanding. So far, I like the Rust approach better.&lt;/p&gt;
&lt;p&gt;In particular, more syntax is not my preferred way to tackle these things. Providing good language constructs and primitives on which to build seems better in &lt;em&gt;many&lt;/em&gt; ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It substantially reduces the cognitive load for the developer, by keeping the number of constructs small and simply varying how they are applied.&lt;/li&gt;
&lt;li&gt;It increases the quality of those primitives, because it forces the language deadness to make sure they actually address the full problem space.&lt;/li&gt;
&lt;li&gt;It lets developers approach the same problem in ways the language design team may not have anticipated, and over time the community may find shared conventions that improve on the &lt;code&gt;std&lt;/code&gt; approach, and nothing has to change in the language spec (or the compiler!) to adopt those changes.&lt;/li&gt;
&lt;li&gt;In general, then, it makes change much easier to manage, and change can be community-driven rather than requiring the language design team to manage it.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-i.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This may of course be intentional on Apple‚Äôs part with Swift. Maintaining tight control over its tooling is very typical of modern Apple.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Mar 2016 23:15:00 -0500</pubDate><guid>tag:www.chriskrycho.com,2015-09-06:2015/rust-and-swift-ii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (i)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-i.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I started writing these responses in a Slack channel of developers I participate in as I worked through the &lt;a href="https://developer.apple.com/swift/"&gt;Swift&lt;/a&gt; &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/"&gt;book&lt;/a&gt;. I realized after a bit that it would make a better blog post than chat room content, so here we are. This is all entirely off-the-cuff: me just thinking out loud as I read; this is by no means expert opinion.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;I later turned this into the first part of a whole &lt;a href="/rust-and-swift.html"&gt;series&lt;/a&gt; comparing Rust and Swift!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;..&amp;lt;&lt;/code&gt; ‚Äì seriously?&lt;/p&gt;
&lt;p&gt;That has to be one of the most annoying operators I‚Äôve ever seen. It ends up with cognitive noise because &lt;code&gt;&amp;lt;name&lt;/code&gt; initially processes as ‚Äústarting a generic‚Äù and you have to re-parse it visually and mentally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the first chapter of the Swift book, my impression is ‚Äúa poor man‚Äôs Rust‚Äù; my gut feel based on that first pass and everything I‚Äôve seen and read about Swift over the past two years is that it‚Äôs roughly what you would get if you took Rust‚Äôs syntax and replaced Rust‚Äôs hard safety goals with the aim of mapping to ObjC semantics. (To be fair to Apple, that interoperability was probably necessary.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An example that jumps out at me as immediately illustrative of the difference in approach the languages take is the way you pass structures by reference vs.¬†copy. In Swift, that‚Äôs done via two completely distinct language constructs, &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es respectively.&lt;/p&gt;
&lt;p&gt;In Rust, there is just the &lt;code&gt;struct&lt;/code&gt; type to handle both of those. They‚Äôre immutable unless you declare them with &lt;code&gt;mut&lt;/code&gt;, and you can pass them via copy simply by implementing the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt; (which seems roughly analogous to Swift‚Äôs &lt;code&gt;protocol&lt;/code&gt;, but I‚Äôve not yet dig deeply enough to see how they differ). Those things aren‚Äôt baked into the language, but use simpler language building blocks to define behavior into he library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I saw someone do a write up a while back arguing that Go isn‚Äôt a &lt;em&gt;bad&lt;/em&gt; language, it just isn‚Äôt a &lt;em&gt;good&lt;/em&gt; language. My first impression of Swift, after having spent the last month with Rust, is very much along those lines.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Huh. Here‚Äôs something that I appreciate about Rust, Haskell, and others now that I didn‚Äôt before: there‚Äôs a difference between implicitly/automatically importing a prelude or a given set of standard library functions, and having actually global functions. Does Swift actually have functions like &lt;code&gt;print&lt;/code&gt; in a global namespace, as the book seems to imply, or they being imported automatically &lt;em&gt;a la&lt;/em&gt; Rust/Haskell/etc.?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; it appears Swift does likewise, but that you can‚Äôt access the relevant module directly. Which is halfway there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hmm. Why have &lt;code&gt;Double&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;Float&lt;/code&gt;‚Äîjust for ObjC interop, I guess?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; follow-up from a conversation with a friend: it‚Äôs because you have 32- and 64-bit architectures out there; sometimes you don‚Äôt want 64 bits of floating point precision for that reason. Note that Rust &lt;em&gt;also&lt;/em&gt; has this distinction; you can declare things as &lt;code&gt;f32&lt;/code&gt; or &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending the above note on &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;protocol&lt;/code&gt;s vs.¬†Rust‚Äôs approach: the same thing is true about &lt;code&gt;extension&lt;/code&gt;, which is a distinct concept from implementing a &lt;code&gt;protocol&lt;/code&gt;; again, in Rust these are both just handled with a single language construct, &lt;code&gt;impl&lt;/code&gt;. That‚Äôs not because &lt;code&gt;impl&lt;/code&gt; is overloaded, but rather because the underlying language machinery is the same for the two things. (edited)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(I‚Äôve a feeling learning Swift is going to turn me into even more of a Rust fanboy.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reading the two books in close sequence like this is proving really productive mentally for thinking about how the two handle the same issues. I‚Äôve never done anything quite like this before, and it‚Äôs fascinating.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have an increased appreciation for Rust‚Äôs use of semi-colons to turn expressions into statements, and thereby to distinguish clearly between the two (among other things, allowing for implicit return of anything that‚Äôs an expression).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another interesting comparison: Rust‚Äôs &lt;code&gt;match&lt;/code&gt; and Swift‚Äôs &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; fill the same role of pattern matching. I‚Äôm curious to see how they differ. Does Swift do matching on arbitrary expressions?&lt;/p&gt;
&lt;p&gt;Also, I see where the syntax choices came from in both, and while I slightly prefer Rust‚Äôs, I think both make reasonably good sense; Swift‚Äôs will understandably be more familiar to C and ObjC programmers, and that‚Äôs a perfectly defensible approach. Seen that way, it is expanding on the C-style construct (even if it‚Äôs actually doing something substantially more sophisticated than that under the hood by being a form of actual pattern matching).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 13:45:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-04:2015/rust-and-swift-i.html</guid><category>listicles</category><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>2015-09-02 08:07</title><link>http://www.chriskrycho.com/2015/2015-09-02-0807.html</link><description>&lt;p&gt;I‚Äôm writing a bunch of C that &lt;em&gt;needs&lt;/em&gt; to handle error returns. I‚Äôm really wishing I had Rust‚Äôs &lt;code&gt;#[must_use]&lt;/code&gt; annotation right now. For that matter, I just want Rust‚Äôs &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type available.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 02 Sep 2015 08:07:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-09-02:2015/2015-09-02-0807.html</guid><category>programming languages</category><category>rust</category></item><item><title>2015/08/09 22:16</title><link>http://www.chriskrycho.com/2015/20150809-2216.html</link><description>&lt;p&gt;Tonight, Jaimie said that she thought Rust had turned me into a bit of a fanboy. Don‚Äôt tell anyone, but I think she‚Äôs basically right‚Ä¶&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 09 Aug 2015 22:16:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-08-09:2015/20150809-2216.html</guid><category>programming languages</category><category>rust</category></item><item><title>2015-08-08 18:11</title><link>http://www.chriskrycho.com/2015/2015-08-08-1811.html</link><description>&lt;p&gt;I can think of no more effective an argument for &lt;a href="http://www.rust-lang.org/"&gt;Rust&lt;/a&gt; and its &lt;a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html"&gt;memory safety guarantees&lt;/a&gt; than the time I spent this weekend hunting down bugs caused by buffer overruns in decades-old C code.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 08 Aug 2015 18:11:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-08-08:2015/2015-08-08-1811.html</guid><category>software development</category><category>programming languages</category><category>rust</category></item><item><title>High- and Low-Level Programming Languages</title><link>http://www.chriskrycho.com/2015/high-and-low-level-programming-languages.html</link><description>&lt;p&gt;It occurred to me while listening to &lt;a href="https://edwinb.wordpress.com"&gt;Edwin Brady&lt;/a&gt; talk about &lt;a href="http://www.idris-lang.org"&gt;Idris&lt;/a&gt; on the &lt;a href="http://typetheorypodcast.com"&gt;Type Theory Podcast&lt;/a&gt;,&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; having just spent a few weeks starting to learn &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: ‚Äúlow-level‚Äù has at least two meanings in software. One is whether something has manual memory management or is garbage collected, reference counted, or otherwise manages memory itself. This is what people often mean when they talk about C, C++, etc. as being ‚Äúlow-level‚Äù and languages like Python or Ruby or C‚ôØ being high-level.&lt;/p&gt;
&lt;p&gt;But then you toss in a language like &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;, and things start to get a little more complicated. Rust can do the same kind of direct memory management that makes C or C++ a good language for things like writing operating system kernels. [&lt;a href="https://github.com/torvalds/linux"&gt;1&lt;/a&gt;,&lt;a href="https://en.wikipedia.org/wiki/Architecture_of_Windows_NT"&gt;2&lt;/a&gt;,&lt;a href="http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/"&gt;3&lt;/a&gt;] But it is also memory-safe, at least in ordinary usage. Like C‚ôØ, you have to be explicit about any unsafe code, with the &lt;code&gt;unsafe&lt;/code&gt; keyword on any blocks that do memory management that isn‚Äôt safe. And the vast majority of Rust code &lt;em&gt;is&lt;/em&gt; safe.&lt;/p&gt;
&lt;p&gt;More than that, though, Rust &lt;em&gt;feels&lt;/em&gt; like a high-level language. It gives you higher-kinded functions, generics, traits-based composition of types, hygienic macros, and the implementation of many important parts the essentials of the language in the library. If you need to patch something, or extend something, you can do that in a straightforward way. In short, it gives you lots of good abstractions like you would expect in a high-level language.&lt;/p&gt;
&lt;p&gt;Rust is low-level in that you can write (and people are writing) systems-level programs in it. It is high-level in that it lets you express things in ways normally associated with languages like Haskell or OCaml or Python or Ruby. To put it simply: it‚Äôs &lt;em&gt;low-level&lt;/em&gt; in its ability to address the computer, and &lt;em&gt;high-level&lt;/em&gt; in the abstractions it hands to a programmer. That‚Äôs a powerful combination, and I hope more languages embrace it in the years to come.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Yes, I know that‚Äôs insanely nerdy. What did you expect?&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Aug 2015 20:00:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-08-07:2015/high-and-low-level-programming-languages.html</guid><category>programming languages</category><category>rust</category><category>python</category><category>ruby</category><category>c</category><category>cplusplus</category></item><item><title>2015-08-06 17:33</title><link>http://www.chriskrycho.com/2015/2015-08-06-1733.html</link><description>&lt;p&gt;‚òë Finished reading the &lt;a href="http://rustbyexample.com"&gt;Rust by Example&lt;/a&gt; book. ‚òë Submitted a couple &lt;a href="https://github.com/rust-lang/rust-by-example/pull/628"&gt;pull requests&lt;/a&gt;. ‚òë Concluded that I &lt;em&gt;really&lt;/em&gt; like this language.&lt;/p&gt;
&lt;div id="refs" class="references"&gt;

&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 06 Aug 2015 17:33:00 -0400</pubDate><guid>tag:www.chriskrycho.com,2015-08-06:2015/2015-08-06-1733.html</guid><category>programming languages</category><category>rust</category></item></channel></rss>