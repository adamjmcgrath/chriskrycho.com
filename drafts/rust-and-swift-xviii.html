<!DOCTYPE html>
<html lang="en">
<head>
    <title>Rust and Swift (xviii) &middot; Chris Krycho</title>
    <meta name="description" content="I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note …"/>

    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel='me' href='https://alpha.app.net/chriskrycho' data-type='follow' data-user-id='@chriskrycho'/>    <meta property="og:url" content="http://www.chriskrycho.com/drafts/rust-and-swift-xviii.html"/>
    <meta property="og:title" content="Rust and Swift (xviii)"/>
    <meta property="og:description" content="I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note …"/>
        <meta property="og:image" content="http://www.chriskrycho.com//assets/images/ck.png"/>
<link rel="author" href=""/>
<link rel="me" href=""/><meta name="twitter:card" content="summary"/>
<meta name="twitter:site" content="@chriskrycho"/>
<meta name="twitter:creator" content="@chriskrycho"/>
    <meta name="twitter:title" content="Rust and Swift (xviii)"/>
    <meta name="twitter:description" content="I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note …"/>
        <meta name="twitter:image" content="http://www.chriskrycho.com/assets/images/ck.png"/>
    <link rel="me" href="https://twitter.com/chriskrycho"/>
    <link rel="me" href="http://instagram.com/chriskrycho"/>
    <link rel="me" href="mailto:chris at chriskrycho dot com"/>
    <link rel="me" href="https://www.facebook.com/chriskrycho"/>
    <link rel="me" href="https://bitbucket.org/chriskrycho"/>
    <link rel="me" href="http://www.linkedin.com/in/chriskrycho"/>
    <link rel="me" href="https://medium.com/@chriskrycho"/>
    <link rel="me" href="https://vimeo.com/chriskrycho"/>
    <link rel="me" href="https://github.com/chriskrycho"/>
    <link rel="me" href="https://soundcloud.com/chriskrycho"/>
    <link rel="me" href="http://stackoverflow.com/users/564181/chris-krycho"/>

    <link rel="openid.delegate" href="http://www.chriskrycho.com/" />
    <link rel="openid.server" href="https://indieauth.com/openid" />

    <link rel="stylesheet" type="text/css" href="/assets/style.css"/>
    <link rel="stylesheet" type="text/css" href="/assets/fonts.css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <link href="/favicon.png" type="image/png" rel="icon" />
    <link href="/favicon.ico" type="image/ico" rel="icon" />

    <script type="text/javascript" src="/assets/js/mtiFontTrackingCode.js"></script>

    <link rel="alternate" href="/feed.xml" type="application/rss+xml" title="All posts">
        <link rel="alternate" href="/feeds/art.xml" type="application/rss+xml" title="Posts filed in in 'Art''">
        <link rel="alternate" href="/feeds/blog.xml" type="application/rss+xml" title="Posts filed in in 'Blog''">
        <link rel="alternate" href="/feeds/micro.xml" type="application/rss+xml" title="Posts filed in in 'Micro''">
        <link rel="alternate" href="/feeds/tech.xml" type="application/rss+xml" title="Posts filed in in 'Tech''">
        <link rel="alternate" href="/feeds/Theology.xml" type="application/rss+xml" title="Posts filed in in 'Theology''">
</head>
<body>
    <header id="site-header">
        <div class="hgroup">
            <h1 id="site-title">
<a href="http://www.chriskrycho.com"><img class="logotype" src="/assets/images/ck.png" alt="ck"/>Chris Krycho</a>
</h1>

            <h2 id="site-subtitle">Theology, technology, life & art</h2>
        </div>

        <nav>
            <ul>
                <li class="section-title"><a href="http://www.chriskrycho.com/about.html">About</a></li>
                <li class="section-title art"><a href="http://www.chriskrycho.com/art/">art</a></li>
                <li class="section-title tech"><a href="http://www.chriskrycho.com/tech/">tech</a></li>
                <li class="section-title theology"><a href="http://www.chriskrycho.com/theology/">Theology</a></li>
                <li class="section-title divider" role="presentation"></li>
                <li class="section-title"><a href="http://www.chriskrycho.com/series.html">Series</a></li>
            </ul>
        </nav>

    </header>


<article class="rust swift rust-and-swift programming-languages rust-and-swift">

    <header>
<h1>Rust and Swift (xviii)</h1>
<h2>Deinitialization: drop semantics and automatic reference counting</h2>    </header>

    <div class="meta">
<span class="date"><a href="http://www.chriskrycho.com/drafts/rust-and-swift-xviii.html"><i class="fa fa-fw fa-link"></i></a>July 29, 2016</span><span class="section">Filed under <a class="section-title" href="http://www.chriskrycho.com/rust-and-swift/">rust-and-swift</a></span><span class="hashtag"><a class="hashtags" href="http://www.chriskrycho.com/programming-languages/">#programming languages</a><a class="hashtags" href="http://www.chriskrycho.com/rust/">#rust</a><a class="hashtags" href="http://www.chriskrycho.com/rust-and-swift/">#rust-and-swift</a><a class="hashtags" href="http://www.chriskrycho.com/swift/">#swift</a></span><span><a href="http://www.chriskrycho.com/2016/rust-and-swift-xviii.txt">Markdown source</a></span>    </div>

    <div class="content-wrapper">


        <div class="content">

<p><i class="editorial">I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. <a href="http://www.chriskrycho.com/rust-and-swift.html">(See all parts in the series.)</a></i></p>
<hr />
<p>Perhaps unsurprisingly, the Swift book follows on from its discussion of initialization with a discussion of deinitialization, and here the differences between Rust and Swift are substantial, but (as has so often been the case) so are the analogies.</p>
<p>In Rust, memory is, by default, stack-allocated and -deallocated, but with a very impressive system for tracking the lifetime of that data and allowing its to be moved from one function to another. The Rust compiler tracks the <em>ownership</em> of every given item in the program as it is passed from one function to another, allowing other parts of the program to “borrow” the data safely, until a given piece of data goes out of scope entirely. At that point, Rust runs its destructors automatically. As part of its system for managing memory safely, Rust also tracks where and when a program attempts to access any given piece of data (whether directly or via reference), and will refuse to compile if you try to reference data in a place where it has already gone out of scope and been cleaned up (“dropped,” in Rust-speak).</p>
<p>If this was a bit fuzzy, don’t worry: there’s a lot to say here. It’s arguably the most distinctive feature of the language, and it’s also the main thing that tends to trip up newcomers to the language. If you’re interested in further material on the topic, My own most succinct treatment of it is in <a href="http://www.newrustacean.com/show_notes/e002/index.html" title="e002: Something borrowed, something... moved?">an early episode</a> of New Rustacean, my Rust developer podcast, and <a href="https://doc.rust-lang.org/book/ownership.html">the official documentation</a> is <em>very</em> good. For now, suffice it to say: Rust does extremely rigorous <em>compile-time</em> checks to let you do C or C++-style memory management, but with absolute guarantees that you won’t have e.g. use-after-free bugs, with a default to handling everything on the stack.</p>
<p>It is of course impossible to handle <em>everything</em> on the stack, so there are heap-allocated types (e.g. vectors, a dynamically sized array-like type), which are fundamentally reference (or pointer) types. But those follow the same basic rules: Rust tracks the <em>pointers</em> throughout their uses, and when they go out of scope, Rust automatically tears down not only the pointer but also the data behind it. There are times, though, when you can’t comply with Rust’s normal rules for handling multiple-access to the same data. For those situations, it also supplies some “smart pointer” container types, <code>Rc</code> and <code>Arc</code>, the <em>reference-counted</em> (non-thread-safe) and <em>atomically reference-counted</em> (thread-safe) types. Both types just wrap up a type that you intend to put on the heap with reference-counters, which increment and decrement as various pieces of a program get access to them. Note that, unlike the compiler-level, <em>compile-time</em> checks mentioned earlier, these are <em>run-time</em> counts and they therefore incur a small but real runtime performance penalty. (The distinctions between the two types have to do with how they guarantee their memory safety and what kinds of a guarantees are required for cross-thread safety, and they’re important for writing Rust but not so important for this comparison, so I’ll leave them aside.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>)</p>
<p>In Swift, all class instances (which are pass-by-reference types) are tracked with <em>automatic reference counting</em> and cleaned up automatically when there are no more references to them. Don’t confuse Rust’s “<em>atomically</em> reference-counted” type with Swift’s “<em>automatically</em> reference-counted” type. Unlike Rust’s behavior in having everything checked at compile-time. Reference counting is a run-time check in Swift, just as it is with the <code>Rc</code> and <code>Arc</code> types in Rust.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> But it happens for all reference types all the time in Swift, not just when specified manually as in Rust. It’s <em>automatic</em> in that the compiler and runtime handle it “behind the scenes” from the developer’s perspective.</p>
<p>Swift’s approach here isn’t quite the same as having a full-on garbage-collected runtime like you’d see in Java, C#, Python, Ruby, JavaScript, etc. (and so doesn’t have the performance issues those often can). But it also isn’t like Rust’s default of having <em>no</em> runtime cost. It’s somewhere in the middle, with a goal of very good performance but good developer ergonomics. I think it achieves that latter goal: for the most part, it means that you don’t have to think about memory allocation and deallocation explicitly. Certainly there are times when you have to think about how your program handles those issues, but neither is it right up in your face like it is in Rust,<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> nor does it come with the costs of a heavier runtime (from startup, to GC pauses, to non-deterministic performance characteristics).<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>To make it concrete, the following snippets do <em>basically</em> the same thing—but note that the reference counting is explicit in Rust. We’ll start with Rust: {&gt;&gt; TODO: validate &lt;&lt;}</p>
<pre class="rust"><code>pub struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

fn main() {
    let trainee = WouldBeJedi {
        name: &quot;Zayne Carrick&quot;.to_string(),
        rank: 1,
        description: &quot;not very competent, but a great hero&quot;.to_string()
    };
    let wrapped_trainee = Rc::new(trainee);

    // When calling the function, the reference count in the
    // wrapped trainee will go up by one. When the function
    // returns, it will go down by one.
    describe_a_trainee(wrapped_trainee);

    // When `main` ends, several things will happen in order:
    // 1. The reference count on the `wrapped_trainee` will go to zero.
    //    As a result, the `wrapped_trainee` pointer---the `Rc` type we
    //    created---will get cleaned up.
    // 2. Once `wrapped_trainee` has been cleaned up, Rust will notice
    //    that there are no more references anywhere to `trainee` and
    //    clean it up as well. (More on this below.)
}

fn describe_a_trainee(trainee: Rc&lt;WouldBeJedi&gt;) {
    // When we enter this function, Rust bumps the reference
    // count, from 1 to 2. Both `main` and `describe_a_trainee`
    // now have a reference to the data.

    // For convenience, we shadow the outer variable here.
    // We first unwrap it: `get()` gets the contents and returns
    // an `Option&lt;T&gt;` where `T` is whatever the `Rc` contains,
    // so in this case, `Option&lt;WouldBeJedi&gt;`. (We know there&#39;s
    // one here because it&#39;s a toy example.)
    let trainee = trainee.get().unwrap();
    println!(&quot;{} (rank {}) is {}.&quot;, 
             trainee.name, 
             trainee.rank, 
             trainee.description);

    // When we exit the function, Rust bumps the reference count
    // back down to 1 automatically.
}</code></pre>
<p>And here’s the (much briefer, because all the reference counting is automatic and behind the scenes) Swift code—note as well that we use a <code>class</code> not a <code>struct</code> here: {&gt;&gt; TODO: validate &lt;&lt;}</p>
<pre class="swift"><code>class WouldBeJedi {
    let name: String
    let rank: u8
    let description: String
}

func main() {
    let aTrainee = WouldBeJedi(
        &quot;Zayne Carrick&quot;,
        1,
        &quot;not very competent, but a great hero&quot;)

    // When calling the function, the reference count goes up
    // here, too, but it&#39;s implicit, rather than explicit.
    describe(aTrainee)

    // The implicit reference count Swift maintains for `aTrainee`
    // will go from 1 to 0 here, and Swift will do its cleanup of the
    // object data.
}

func describe(aTrainee trainee: WouldBeJedi) {
    // When we enter this function, Swift bumps the reference
    // count, from 1 to 2. Both `main` and `describe` now have a
    // reference to the data.

    // No need for the unwrapping or any of that; Swift handles it
    // all automatically... thus the name of the technology!
    print(&quot;\(trainee.name) (rank \(trainee.rank)) is \(trainee.description).&quot;)

    // When we exit the function, Swift bumps the reference count
    // back down to 1 automatically.
}</code></pre>
<p>Both Rust and Swift recognize that, the ordinary case notwithstanding, there are many times when you <em>do</em> need to run some cleanup as part of tearing down an object. For example, if you had an open database connection attached to an object, you should return it to the collection pool before finishing tear-down of the object.</p>
<p>In Rust, this is accomplished by implementing the <code>Drop</code> trait and supplying the requisite <code>drop</code> method. Imagine we had imported a type <code>Conn</code> for a database. Our implementation might look something like this (please never use anything as hopelessly naïve as this in a real app, though):</p>
<pre class="rust"><code>struct ThingThatConnects {
    conn: Option&lt;Conn&gt;,
}

impl ThingThatConnects {
    pub fn new() -&gt; ThingThatConnects {
        let conn = Conn::new();
        ThingThatConnects { conn: conn }
    }
}

impl Drop for ThingThatConnects {
    fn drop(self) {
        self.conn.close();
    }
}</code></pre>
<p>In Swift, class types can have deinitializers, which behave in much the same way:</p>
<pre class="swift"><code>class ThingThatConnects {
    var conn: Conn?
    init() {
        conn = Conn.new()
    }

    deinit {
        conn.close()
    }
}</code></pre>
<p>Curiously, <code>struct</code> and <code>enum</code> types <em>cannot</em> have deinitializers in Swift. I expect this has something to do with their being value types rather than reference types, but the book offers no comment. (If a reader knows the answer, I’d welcome clarification.)</p>
<p>Much as in the discussion of of initializers, the usual patterns with Rust and Swift’s approach come into play. Rust opts to build the pattern on the same basic language machinery (traits). Swift uses a bit of syntactical sugar dedicated to the purpose. It’s undeniable that the Swift is a bit briefer.</p>
<p>However, there are a couple upsides to Rust’s approach. First, it is applicable on <em>all</em> types, where Swift’s applies only to classes. Second, there is no additional syntax to remember. <code>Drop</code> is just a trait like any other, and <code>drop</code> a method like any other. Third, then, this means that you can run it explicitly elsewhere if you need to, and as a result you can define whatever kind of custom deconstruction behavior you might need. If we’d created <code>a_thing_that_connects</code> above in Rust, we could simply write <code>a_thing_that_connects.drop()</code> anywhere:</p>
<pre class="rust"><code>fn do_stuff_then_drop(a_thing: ThingThatConnects) {
    // do whatever else is needful
    a_thing.drop();
    // other stuff
}</code></pre>
<p>Or we could define a <code>might_need_to_drop()</code> method which called <code>drop()</code> itself:</p>
<pre class="rust"><code>impl ThingThatConnects {
    pub fn might_need_to_drop(self) {
        // do some other operation
        // then if it fails...
        self.drop();
    }
} </code></pre>
<p>Or, really, define <em>any</em> behavior which culminated in a <code>drop()</code> call. That’s extremely powerful, and it’s the upside that comes with its just being a trait whose behavior we have to define ourselves.</p>
<p>That takes us back to one of the fundamental differences in design between the two languages. Rust goes out of its way to leave power in the hands of the user, at the cost of requiring the user to be a bit more explicit. Swift prioritizes brevity and productivity, but it gets there by taking some of the power out of the hands of the developer. Neither of these is wrong, <em>per se</em>. They’re just aiming for (and in this case, I think, fairly successfully landing in) somewhat different spots on a spectrum of tradeoffs.</p>
<hr />
<ul>
<li><a href="http://www.chriskrycho.com/2016/rust-and-swift-xvii.html"><strong>Previous:</strong> More on initializers!</a></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I did, however, cover them <a href="http://www.newrustacean.com/show_notes/e015/index.html" title="e015: Not dumb pointers">quite recently</a> on my podcast. Snameless plug number 2!<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Mostly, anyway. I believe the Swift compiler also does some degree of static analysis similar to that done by Rust—though to a <em>much</em> lesser extent and, speaking purely descriptively, much less rigorously (it just has different goals). Swift then uses that analysis to handle things at compile time rather than via reference counts if it’s able to determine that it can do so.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>We could, if we so desired, get this same basic behavior in Rust. We can easily imagine a world in which every type was automatically wrapped in <code>Rc</code> or <code>Arc</code>, and in fact, I’d be very interested to see just such a language—something which was only a thin layer over Rust, keeping all its semantics but wrapping some or all non-stack-allocated types in <code>Rc</code> or <code>Arc</code> as appropriate. (Something like <a href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">this</a>, but done behind the scenes rather than manually opted into.) You’d incur some performance coasts, but with the benefit that you’d have an <em>extremely</em> ergonomic, practical, ML-descended language quite appropriate for slightly higher-level tasks, and without the radical shift required by switching to a lazily-evaluated, purely functional language like Haskell.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Notably, those tradeoffs are often entirely worth it, and high-performance VMs have astoundingly good characteristics in many ways. The JVM, the CLR, and all the JavaScript VMs have astonishingly excellent performance at this point.<a href="#fnref4">↩</a></p></li>
</ol>
</section>
        </div>
    </div>
</article>


    <footer id="site-footer"><section id="connect">
    <h2>Connect</h2>
    <ul class="icons">
        <li><a href="https://twitter.com/chriskrycho"><i class="fa fa-fw fa-twitter"></i>Twitter</a></li>
        <li><a href="mailto:chris at chriskrycho dot com"><i class="fa fa-fw fa-envelope"></i>Email</a></li>
        <li><a href="https://github.com/chriskrycho"><i class="fa fa-fw fa-github"></i>GitHub</a></li>
        <li><a href="https://medium.com/@chriskrycho"><i class="fa fa-fw fa-medium"></i>Medium</a></li>
        <li><a href="https://soundcloud.com/chriskrycho"><i class="fa fa-fw fa-soundcloud"></i>SoundCloud</a></li>
        <li><a href="http://instagram.com/chriskrycho"><i class="fa fa-fw fa-instagram"></i>Instagram</a></li>
        <li><a href="http://www.linkedin.com/in/chriskrycho"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a></li>
        <li><a href="https://vimeo.com/chriskrycho"><i class="fa fa-fw fa-vimeo"></i>Vimeo</a></li>
        <li><a href="http://stackoverflow.com/users/564181/chris-krycho"><i class="fa fa-fw fa-stack-overflow"></i>Stack Overflow</a></li>
    </ul>
</section>
<section id="subscribe">
    <h2>Subscribe</h2>
    <ul class="icons">
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feed.xml"><i class="fa fa-fw fa-rss"></i>Everything</a>
        </li>
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feeds/art.xml"><i class="fa fa-fw fa-rss"></i>art</a>
        </li>
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feeds/blog.xml"><i class="fa fa-fw fa-rss"></i>blog</a>
        </li>
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feeds/micro.xml"><i class="fa fa-fw fa-rss"></i>micro</a>
        </li>
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feeds/tech.xml"><i class="fa fa-fw fa-rss"></i>tech</a>
        </li>
        <li class="section-title">
            <a href="http://www.chriskrycho.com/feeds/Theology.xml"><i class="fa fa-fw fa-rss"></i>Theology</a>
        </li>
    </ul>
</section>
<section id="recent">
    <h2>Recent</h2>
    <ul>
        <li>Art: <a href="http://www.chriskrycho.com/2016/mornings-like-this.html">Mornings like this</a></li>
        <li>Blog: <a href="http://www.chriskrycho.com/2016/a-new-schedule.html">A New Schedule</a></li>
        <li>Tech: <a href="http://www.chriskrycho.com/2016/consistency-in-user-interfaces.html">Consistency in User Interfaces</a></li>
        <li>Theology: <a href="http://www.chriskrycho.com/2016/a-simple-childrens-catechism.html">A Simple Children's Catechism</a></li>
    </ul>
</section></footer>

    <script async src="http://code.bib.ly/bibly.min.js"></script>
    <link href="http://code.bib.ly/bibly.min.css" rel="stylesheet" />
    <script type="text/javascript">
    var MTIProjectId='a34d2e31-99b5-469a-9b81-128fc0bd9745';
    </script>

<link rel="stylesheet" href="/assets/tomorrow.min.css">
<script src="/assets/js/highlight.pack.js"></script>
<script type="text/javascript">
// Get all the <pre><code> elements, and use the <pre> element to set the <code>
// element's class so hljs will use it rather than trying to figure it out.
var preEls = document.getElementsByTagName('pre');
for (var e in preEls) {
    var pre = preEls[e];
    if (pre.firstChild && pre.firstChild.tagName === 'CODE') {
        var code = pre.firstChild;
        code.className = pre.className;
    }
}

// Then run hljs.
hljs.initHighlightingOnLoad();
</script>

<script type="text/javascript" src="/assets/js/lib.js"></script>
</body>
</html>